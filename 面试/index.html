<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.1.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.1.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="跳槽时时刻刻都在发生，但是我建议大家跳槽之前，先想清楚为什么要跳槽。切不可跟风，看到同事一个个都走了，自己也盲目的面试起来（期间也没有准备充分），到底是因为技术原因（影响自己的发展，偏移自己规划的轨迹），还是钱给少了，不受重视。 准备不充分的面试，完全是浪费时间，更是对自己的不负责（如果title很高，当我没说）。 今天给大家分享下chenssy在这次跳槽中整理的Java面试大纲，其中大部分都是面">
<meta property="og:type" content="article">
<meta property="og:title" content="面试">
<meta property="og:url" content="http://www.antizhou.com/面试/index.html">
<meta property="og:site_name" content="World of Anti Zhou">
<meta property="og:description" content="跳槽时时刻刻都在发生，但是我建议大家跳槽之前，先想清楚为什么要跳槽。切不可跟风，看到同事一个个都走了，自己也盲目的面试起来（期间也没有准备充分），到底是因为技术原因（影响自己的发展，偏移自己规划的轨迹），还是钱给少了，不受重视。 准备不充分的面试，完全是浪费时间，更是对自己的不负责（如果title很高，当我没说）。 今天给大家分享下chenssy在这次跳槽中整理的Java面试大纲，其中大部分都是面">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://www.antizhou.com/images/typora/image-201803192105336.png">
<meta property="og:image" content="http://www.antizhou.com/images/typora/image-201803192116377.png">
<meta property="og:image" content="http://www.antizhou.com/images/typora/image-201803192108265.png">
<meta property="og:image" content="http://www.antizhou.com/images/typora/image-201803192108365.png">
<meta property="og:image" content="http://www.antizhou.com/images/typora/image-201803192108442.png">
<meta property="og:image" content="http://www.antizhou.com/images/typora/image-201803192109284.png">
<meta property="og:image" content="http://www.antizhou.com/images/typora/image-201803192206453.png">
<meta property="og:image" content="http://www.antizhou.com/images/typora/image-201803192318116.png">
<meta property="og:image" content="http://www.antizhou.com/Users/joyo/Documents/面试/image-201803282306260.png">
<meta property="og:image" content="http://www.antizhou.com/images/typora/image-201803202344054.png">
<meta property="og:updated_time" content="2019-06-15T05:59:24.781Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试">
<meta name="twitter:description" content="跳槽时时刻刻都在发生，但是我建议大家跳槽之前，先想清楚为什么要跳槽。切不可跟风，看到同事一个个都走了，自己也盲目的面试起来（期间也没有准备充分），到底是因为技术原因（影响自己的发展，偏移自己规划的轨迹），还是钱给少了，不受重视。 准备不充分的面试，完全是浪费时间，更是对自己的不负责（如果title很高，当我没说）。 今天给大家分享下chenssy在这次跳槽中整理的Java面试大纲，其中大部分都是面">
<meta name="twitter:image" content="http://www.antizhou.com/images/typora/image-201803192105336.png">



  <link rel="alternate" href="/atom.xml" title="World of Anti Zhou" type="application/atom+xml" />




  <link rel="canonical" href="http://www.antizhou.com/面试/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>面试 | World of Anti Zhou</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">World of Anti Zhou</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>




<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.antizhou.com/面试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Anti Zhou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="World of Anti Zhou">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">面试
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-02T17:29:38+08:00">2018-04-02</time>
            

            
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/面试/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="面试/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>跳槽时时刻刻都在发生，但是我建议大家跳槽之前，先想清楚为什么要跳槽。切不可跟风，看到同事一个个都走了，自己也盲目的面试起来（期间也没有准备充分），到底是因为技术原因（影响自己的发展，偏移自己规划的轨迹），还是钱给少了，不受重视。</p>
<p>准备不充分的面试，完全是浪费时间，更是对自己的不负责（如果title很高，当我没说）。</p>
<p>今天给大家分享下chenssy在这次跳槽中整理的Java面试大纲，其中大部分都是面试过程中的面试题，可以对照这查漏补缺，当然了，这里所列的肯定不可能覆盖全部方式。</p>
<p>项目介绍<br>大部分情况，这是一场面试的开门题，面试官问这个问题，主要是考察你的概述能力和全局视野。有的人经常抱怨自己每天在堆业务，但没有成长。事实上，很多情况下确实在堆业务，但并不是没有成长的。并非做中间件或者技术架构才是成长，例如我们的需求分析能力，沟通协作能力，产品思维能力，抽象建模能力等都是一个非常重要的硬实力。</p>
<p>好的，现在进入正文。</p>
<p>1、明确项目是做什么的</p>
<p>2、明确项目的价值。（为什么做这个项目，它解决了用户什么痛点，它带来什么价值？）</p>
<p>3、明确项目的功能。（这个项目涉及哪些功能？）</p>
<p>4、明确项目的技术。（这个项目用到哪些技术？）</p>
<p>5、明确个人在项目中的位置和作用。（你在这个项目的承担角色？）</p>
<p>6、明确项目的整体架构。</p>
<p>7、明确项目的优缺点,如果重新设计你会如何设计。</p>
<p>8、明确项目的亮点。（这个项目有什么亮点？）</p>
<p>9、明确技术成长。（你通过这个项目有哪些技术成长？）</p>
<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="List-、-Set、Map-的区别"><a href="#List-、-Set、Map-的区别" class="headerlink" title="List 、 Set、Map 的区别"></a>List 、 Set、Map 的区别</h3><p><a href="/java/datastructure/ListSetMap">List、Set、Map</a></p>
<h3 id="HashSet-是如何保证不重复的"><a href="#HashSet-是如何保证不重复的" class="headerlink" title="HashSet 是如何保证不重复的"></a>HashSet 是如何保证不重复的</h3><p><a href="/java/datastructure/ListSetMap">List、Set、Map</a></p>
<h3 id="HashMap-是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）"><a href="#HashMap-是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）" class="headerlink" title="HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?"></a>HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?</h3><p><a href="/java/datastructure/ListSetMap">List、Set、Map</a></p>
<h3 id="HashMap-的扩容过程"><a href="#HashMap-的扩容过程" class="headerlink" title="HashMap 的扩容过程"></a>HashMap 的扩容过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a><br><a href="http://www.cnblogs.com/dpains/p/7169030.html" target="_blank" rel="noopener">HashMap原理-1.8</a></p>
<h3 id="HashMap-1-7-与-1-8-的-区别，说明-1-8-做了哪些优化，如何优化的？"><a href="#HashMap-1-7-与-1-8-的-区别，说明-1-8-做了哪些优化，如何优化的？" class="headerlink" title="HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？"></a>HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？</h3><ol>
<li>引入了红黑树</li>
<li>扩容hash的优化，利用扩容后的位置的特性，不需要像JDK1.7的实现那样重新计算hash。</li>
<li>resize的时候，不想1.7那样需要倒置元素</li>
</ol>
<p><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a><br><a href="https://juejin.im/post/5aa5d8d26fb9a028d2079264" target="_blank" rel="noopener">Java源码分析：HashMap 1.8 相对于1.7 到底更新了什么？</a><br><a href="http://www.cnblogs.com/dpains/p/7169030.html" target="_blank" rel="noopener">HashMap原理-1.8</a></p>
<h3 id="final-finally-finalize"><a href="#final-finally-finalize" class="headerlink" title="final finally finalize"></a>final finally finalize</h3><p>final：用于修饰类、成员变量和成员方法。final修饰的类，不能被继承（String、StringBuilder、StringBuffer、Math，不可变类）；<br>Final修饰的方法不能被重写，但是子类可以用父类中final修饰的方法；<br>Final修饰的成员变量是不可变的，如果成员变量是基本数据类型，初始化之后成员变量的值不能被改变，<br>如果成员变量是引用类型，那么它只能指向初始化时指向的那个对象，不能再指向别的对象，但是对象当中的内容是允许改变的。</p>
<p>finally：用于异常代码块执行完成之后执行，通常用于关闭资源</p>
<p>finalize：object类中的一个方法，Java虚拟机在垃圾回收之前会先调用垃圾对象的finalize方法用于使对象释放资源（如关闭连接、关闭文件），<br>之后才进行垃圾回收，这个方法一般不会显示的调用，在垃圾回收时垃圾回收器会主动调用。<br>并且，虚拟机并不承诺等待它允许结束，是为了避免其中一个执行缓慢，导致整个内存回收系统崩溃。</p>
<h3 id="强引用-、软引用、-弱引用、虚引用"><a href="#强引用-、软引用、-弱引用、虚引用" class="headerlink" title="强引用 、软引用、 弱引用、虚引用"></a><a href="https://www.jianshu.com/p/7200da8b043f" target="_blank" rel="noopener">强引用 、软引用、 弱引用、虚引用</a></h3><table>
<thead>
<tr>
<th>类型</th>
<th>生命周期</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>强引用</td>
<td>不会被GC</td>
<td>…</td>
</tr>
<tr>
<td>SoftReference</td>
<td>直到内存不足时</td>
<td>二级缓存</td>
</tr>
<tr>
<td>WeakReference</td>
<td>下次GC</td>
<td>缓存（WeakHashMap）</td>
</tr>
<tr>
<td>PhantomReference</td>
<td>下次GC</td>
<td>堆外内存管理</td>
</tr>
</tbody>
</table>
<p><a href="http://www.cnblogs.com/lcplcpjava/p/6594575.html" target="_blank" rel="noopener">关于java内存泄露的总结–引用的类型：强引用，弱引用，软引用</a><br><a href="https://cloud.tencent.com/developer/article/1031730" target="_blank" rel="noopener">从面试题中看Java的Reference（引用）</a><br><a href="/java/datastructure/ThreadLocal">ThreadLocal内存泄露</a></p>
<h3 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h3><p><a href="http://blog.jobbole.com/105299/" target="_blank" rel="noopener">说说 Java 反射机制</a><br><a href="https://www.jianshu.com/p/3ea4a6b57f87" target="_blank" rel="noopener">深入分析Java方法反射的实现原理</a><br><a href="https://www.ziwenxie.site/2017/03/22/java-reflection/" target="_blank" rel="noopener">Java反射机制应用实践</a></p>
<p>应用：</p>
<ul>
<li>AOP分离业务代码（jdk动态代理）</li>
<li>获取注解</li>
<li>泛型擦除</li>
<li>eclipse等IDE的代码智能提示</li>
</ul>
<h3 id="Arrays-sort-实现原理和-Collection-实现原理"><a href="#Arrays-sort-实现原理和-Collection-实现原理" class="headerlink" title="Arrays.sort 实现原理和 Collection 实现原理"></a>Arrays.sort 实现原理和 Collection 实现原理</h3><h3 id="LinkedHashMap的应用"><a href="#LinkedHashMap的应用" class="headerlink" title="LinkedHashMap的应用"></a>LinkedHashMap的应用</h3><p>LinkedHashMap 能够做到按照插入顺序或者访问顺序进行迭代，这样在我们以后的开发中遇到相似的问题，才能想到用 LinkedHashMap 来解决，否则就算对其内部结构非常了解，不去使用也是没有什么用的。</p>
<p><a href="/java/datastructure/ListSetMap">List、Set、Map</a></p>
<h3 id="cloneable接口实现原理"><a href="#cloneable接口实现原理" class="headerlink" title="cloneable接口实现原理"></a>cloneable接口实现原理</h3><p>克隆规则：<br>1、基本类型<br>如果变量是基本类型，则拷贝其值，比如int、float等。<br>2、 对象<br>如果变量是一个实例对象，则拷贝其地址引用，也就是说新对象和原来对象是共用实例变量的。<br>3、 String字符串<br>若变量为String字符串，则拷贝其地址引用。但是在修改时，它会从字符串池中重新生成一个新的字符串，原有的对象保持不变。</p>
<p>使用：<br>Object.java的clone()是一个native方法，当需要克隆时，子类实现Cloneable接口后，重写clone()，调用super.clone()。需要注意涉及到深、浅拷贝。</p>
<p>实现深克隆：<br>1、先对对象进行序列化，紧接着马上反序列化出<br>2、先调用super.clone()方法克隆出一个新对象来，然后在子类的clone()方法中手动给克隆出来的非基本数据类型（引用类型）赋值，比如ArrayList的clone()方法：<br>3、在clone方法里面，递归克隆非基本类型的成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Administrator</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="keyword">private</span> Boolean editable;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Administrator</span><span class="params">(User user, Boolean editable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">        <span class="keyword">this</span>.editable = editable;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Bean bean = (Bean) <span class="keyword">super</span>.clone();  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 实现深克隆，需要User实现了Cloneable接口</span></span><br><span class="line">        bean.user = (ChildBean) bean.user.clone();  </span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 老规矩</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 老规矩</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 老规矩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/lylodyf/article/details/52763720" target="_blank" rel="noopener">Java中的clone()和Cloneable接口</a></p>
<h3 id="Java创建对象的几种方式"><a href="#Java创建对象的几种方式" class="headerlink" title="Java创建对象的几种方式"></a>Java创建对象的几种方式</h3><p>(1) 用new语句创建对象，这是最常见的创建对象的方法。<br>(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。<br>(3) 调用对象的clone()方法。<br>(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。</p>
<p>(1)和(2)都会明确的显式的调用构造函数 ；(3)是在内存上对已有对象的影印，所以不会调用构造函数 ；(4)是从文件中还原类的对象，也不会调用构造函数。</p>
<h3 id="异常分类以及处理机制"><a href="#异常分类以及处理机制" class="headerlink" title="异常分类以及处理机制"></a>异常分类以及处理机制</h3><p><img src="/images/typora/image-201803192105336.png" alt="mage-20180319210533"></p>
<p><img src="/images/typora/image-201803192116377.png" alt="mage-20180319211637"></p>
<ul>
<li>Error是无法处理的异常，比如OutOfMemoryError，一般发生这种异常，JVM会选择终止程序。因此我们编写程序时不需要关心这类异常。</li>
<li>Exception，也就是我们经常见到的一些异常情况，这些异常是我们可以处理的异常，是所有异常类的父类。</li>
<li>unchecked exception（非受查异常），包括Error和RuntimeException，比如常见的NullPointerException、IndexOutOfBoundsException。对于RuntimeException，java编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。</li>
<li>checked exception（受查异常），也称非运行时异常（运行时异常以外的异常就是非运行时异常），由代码能力之外的因素导致的运行时错误。java编译器强制程序员必须进行捕获处理，比如常见的有IOExeption和SQLException。如果不进行捕获或者抛出声明处理，编译都不会通过。</li>
<li>典型的RuntimeException包括NullPointerException、IndexOutOfBoundsException、IllegalArgumentException等。</li>
<li>典型的非RuntimeException包括IOException、SQLException等。</li>
</ul>
<p><img src="/images/typora/image-201803192108265.png" alt="mage-20180319210826"></p>
<p><img src="/images/typora/image-201803192108365.png" alt="mage-20180319210836"></p>
<p><img src="/images/typora/image-201803192108442.png" alt="mage-20180319210844"></p>
<p><img src="/images/typora/image-201803192109284.png" alt="mage-20180319210928"></p>
<h3 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h3><p>wait：调用后，必须被通知才能重新运行，且释放锁资源。</p>
<p>sleep：睡眠一定时间后继续执行，且不释放锁资源。</p>
<ul>
<li>首先，要记住这个差别，“sleep是Thread类的方法,wait是Object类中定义的方法”。尽管这两个方法都会影响线程的执行行为，但是本质上是有区别的。</li>
<li>Thread.sleep不会导致锁行为的改变，如果当前线程是拥有锁的，那么Thread.sleep不会让线程释放锁。如果能够帮助你记忆的话，可以简单认为和锁相关的方法都定义在Object类中，因此调用Thread.sleep是不会影响锁的相关行为。</li>
<li>Thread.sleep和Object.wait都会暂停当前的线程，对于CPU资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要CPU的执行时间。OS会将执行时间分配给其它线程。区别是，调用wait后，需要别的线程执行notify/notifyAll才能够重新获得CPU执行时间。</li>
<li>线程的状态参考 Thread.State的定义。新创建的但是没有执行（还没有调用start())的线程处于“就绪”，或者说Thread.State.NEW状态。</li>
<li>Thread.State.BLOCKED（阻塞）表示线程正在获取锁时，因为锁不能获取到而被迫暂停执行下面的指令，一直等到这个锁被别的线程释放。BLOCKED状态下线程，OS调度机制需要决定下一个能够获取锁的线程是哪个，这种情况下，就是产生锁的争用，无论如何这都是很耗时的操作。</li>
</ul>
<h3 id="数组在内存中如何分配"><a href="#数组在内存中如何分配" class="headerlink" title="数组在内存中如何分配"></a>数组在内存中如何分配</h3><p>对象在堆上分配连续空间。</p>
<h2 id="Java-并发"><a href="#Java-并发" class="headerlink" title="Java 并发"></a>Java 并发</h2><h3 id="synchronized-的实现原理以及锁优化？"><a href="#synchronized-的实现原理以及锁优化？" class="headerlink" title="synchronized 的实现原理以及锁优化？"></a>synchronized 的实现原理以及锁优化？</h3><p>JVM基于进入和退出Monitor对象来实现方法同步和代码同步。使用monitorenter和monitorexit指令实现。</p>
<p>每个对象有一个监视器锁（monitor）；</p>
<p>偏向锁：使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点，没有字节码在执行）。</p>
<p>轻量级锁：轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁； </p>
<p>重量级锁。</p>
<p><img src="/images/typora/image-201803192206453.png" alt="mage-20180319220645"></p>
<h3 id="volatile-的实现原理？"><a href="#volatile-的实现原理？" class="headerlink" title="volatile 的实现原理？"></a>volatile 的实现原理？</h3><p>通过lock前缀实现，底层是通过总线锁定和缓存锁定来实现。</p>
<p>Lock前缀指令会引起处理器缓存回写到内存。一个处理器的缓存回写到内存会导致其他处理器的缓存无效。</p>
<h3 id="Java-的信号灯？"><a href="#Java-的信号灯？" class="headerlink" title="Java 的信号灯？"></a>Java 的信号灯？</h3><p>控制并发线程数量。</p>
<p>通过AQS来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span>  Semaphore sp = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            Runnable runnable = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        sp.acquire();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                        e1.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + </span><br><span class="line">                            <span class="string">"进入，当前已有"</span> + (<span class="number">3</span>-sp.availablePermits()) + <span class="string">"个并发"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>)(Math.random()*<span class="number">10000</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + </span><br><span class="line">                            <span class="string">"即将离开"</span>);					</span><br><span class="line">                    sp.release();</span><br><span class="line">                    <span class="comment">//下面代码有时候执行不准确，因为其没有和上面的代码合成原子单元</span></span><br><span class="line">                    System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + </span><br><span class="line">                            <span class="string">"已离开，当前已有"</span> + (<span class="number">3</span>-sp.availablePermits()) + <span class="string">"个并发"</span>);					</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            service.execute(runnable);			</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="synchronized-在静态方法和普通方法的区别？"><a href="#synchronized-在静态方法和普通方法的区别？" class="headerlink" title="synchronized 在静态方法和普通方法的区别？"></a>synchronized 在静态方法和普通方法的区别？</h3><p>静态方法和实例方法不是同一把锁</p>
<h3 id="怎么实现所有线程在等待某个事件的发生才会去执行？"><a href="#怎么实现所有线程在等待某个事件的发生才会去执行？" class="headerlink" title="怎么实现所有线程在等待某个事件的发生才会去执行？"></a>怎么实现所有线程在等待某个事件的发生才会去执行？</h3><p>CountDownLatch、CyclicBarrier</p>
<h3 id="CAS？CAS-有什么缺陷，如何解决？"><a href="#CAS？CAS-有什么缺陷，如何解决？" class="headerlink" title="CAS？CAS 有什么缺陷，如何解决？"></a>CAS？CAS 有什么缺陷，如何解决？</h3><p>CompareAndSwap，不用加锁</p>
<p>存在ABA问题，通过添加版本号来区分（AtomicStampedReference）；循环时间开销大；</p>
<h3 id="synchronized-和-lock-有什么区别？"><a href="#synchronized-和-lock-有什么区别？" class="headerlink" title="synchronized 和 lock 有什么区别？"></a>synchronized 和 lock 有什么区别？</h3><ul>
<li>lock能够非阻塞获取锁、中断地获取锁、超时获取锁、更加灵活。</li>
<li>悲观锁与乐观锁</li>
<li>synchronized由jvm自动释放，lock需要手动释放</li>
<li>在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；</li>
</ul>
<p><a href="http://hanhailong.com/2016/12/10/Synchronized%E4%B8%8ELock%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener">Synchronized与Lock锁的区别</a></p>
<h3 id="Hashtable-是怎么加锁的-？"><a href="#Hashtable-是怎么加锁的-？" class="headerlink" title="Hashtable 是怎么加锁的 ？"></a>Hashtable 是怎么加锁的 ？</h3><p>synchronized</p>
<h3 id="HashMap-的并发问题？"><a href="#HashMap-的并发问题？" class="headerlink" title="HashMap 的并发问题？"></a>HashMap 的并发问题？</h3><p>死循环导致CPU100%使用</p>
<p><a href="https://www.jianshu.com/p/1e9cf0ac07f4" target="_blank" rel="noopener">HashMap的死循环</a></p>
<h3 id="ConcurrenHashMap-介绍？1-8-中为什么要用红黑树？"><a href="#ConcurrenHashMap-介绍？1-8-中为什么要用红黑树？" class="headerlink" title="ConcurrenHashMap 介绍？1.8 中为什么要用红黑树？"></a>ConcurrenHashMap 介绍？1.8 中为什么要用红黑树？</h3><p><a href="/java/datastructure/treemap">彻底看懂 so called 红黑树</a><br><a href="https://tech.meituan.com/redblack-tree.html" target="_blank" rel="noopener">红黑树深入剖析及Java实现</a></p>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>抽象队列同步器，AbstractQueueSynchronizer。</p>
<ul>
<li>模板方法</li>
<li>volatile int 状态变量</li>
<li>CAS</li>
<li>同步队列（FIFO双向队列）</li>
<li>共享、独占获取同步状态</li>
</ul>
<h3 id="如何检测死锁？怎么预防死锁？"><a href="#如何检测死锁？怎么预防死锁？" class="headerlink" title="如何检测死锁？怎么预防死锁？"></a>如何检测死锁？怎么预防死锁？</h3><p>检测：</p>
<ol>
<li>cpu使用率低</li>
<li>io使用率低</li>
<li>jstack</li>
</ol>
<p>预防：</p>
<ol>
<li>资源使用顺序</li>
<li>增加资源</li>
<li>超时退出资源</li>
</ol>
<h3 id="Java-内存模型？"><a href="#Java-内存模型？" class="headerlink" title="Java 内存模型？"></a>Java 内存模型？</h3><p>Java内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。</p>
<p>Java内存模型定义了volatile和synchronized的行为，更重要的是保证了同步的java程序在所有的处理器架构下面都能正确的运行。</p>
<p><img src="/images/typora/image-201803192318116.png" alt="mage-20180319231811"></p>
<ol>
<li>happens-before规则</li>
<li>重排序、内存屏障</li>
</ol>
<h3 id="如何保证多线程下-i-结果正确？"><a href="#如何保证多线程下-i-结果正确？" class="headerlink" title="如何保证多线程下 i++ 结果正确？"></a>如何保证多线程下 i++ 结果正确？</h3><p>synchronized、lock</p>
<h3 id="线程池的种类，区别和使用场景？"><a href="#线程池的种类，区别和使用场景？" class="headerlink" title="线程池的种类，区别和使用场景？"></a>线程池的种类，区别和使用场景？</h3><ol>
<li>newCachedThreadPool：适用于执行很多的短期异步任务的小程序，或者负载比较轻的服务器;是一个根据需要创建线程的线程池</li>
<li>newFixedThreadPool：FixedThreadPool适用于为了满足管理资源的需求，而需要限制当前线程数量的应用场景，它适用于负载比较重的服务器。</li>
<li>newSingleThreadExecutor：适用于需要保证顺序地执行各个任务，并且在任意时间点不会有多个线程在活动的场景。</li>
<li>newScheduledThreadPool：适用于需要在多个后台线程执行周期任务，同时为了满足资源管理需求需要限制后台线程数量的应用场景。</li>
</ol>
<h3 id="分析线程池的实现原理和线程的调度过程？"><a href="#分析线程池的实现原理和线程的调度过程？" class="headerlink" title="分析线程池的实现原理和线程的调度过程？"></a>分析线程池的实现原理和线程的调度过程？</h3><p>worker从队列中不断取任务执行，当任务队列为空时，worker线程阻塞；</p>
<h3 id="线程池如何调优，最大数目如何确认？"><a href="#线程池如何调优，最大数目如何确认？" class="headerlink" title="线程池如何调优，最大数目如何确认？"></a>线程池如何调优，最大数目如何确认？</h3><p>取决于任务的类型，CPU密集型可以coreNum + 1；IO密集型可以2coreNum；</p>
<h3 id="ThreadLocal原理，用的时候需要注意什么？"><a href="#ThreadLocal原理，用的时候需要注意什么？" class="headerlink" title="ThreadLocal原理，用的时候需要注意什么？"></a>ThreadLocal原理，用的时候需要注意什么？</h3><p><a href="/java/datastructure/ThreadLocal">ThreadLocal</a></p>
<h3 id="CountDownLatch-和-CyclicBarrier-的用法，以及相互之间的差别"><a href="#CountDownLatch-和-CyclicBarrier-的用法，以及相互之间的差别" class="headerlink" title="CountDownLatch 和 CyclicBarrier 的用法，以及相互之间的差别?"></a>CountDownLatch 和 CyclicBarrier 的用法，以及相互之间的差别?</h3><p>区别：CyclicBarrier可以重复使用，CountDownLatch只能使用一次。</p>
<h3 id="LockSupport工具"><a href="#LockSupport工具" class="headerlink" title="LockSupport工具"></a>LockSupport工具</h3><p><a href="/java/LockSupport">LockSupport</a></p>
<h3 id="Condition接口及其实现原理"><a href="#Condition接口及其实现原理" class="headerlink" title="Condition接口及其实现原理"></a>Condition接口及其实现原理</h3><p>底层依赖LockSupport方法</p>
<p><a href="/java/锁">condition</a></p>
<h3 id="Fork-Join框架的理解"><a href="#Fork-Join框架的理解" class="headerlink" title="Fork/Join框架的理解"></a>Fork/Join框架的理解</h3><p>需要通过ForkJoinPool来提交任务。任务一般通过使用ForkJoinTask的子类来实现：</p>
<ol>
<li>RecursiveAction：用于没有返回结果的任务</li>
<li>RecursiveTask：用于有返回结果的任务</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool forkJoinPool = newForkJoinPool();</span><br><span class="line">Future result = forkJoinPool.submit(task);</span><br></pre></td></tr></table></figure>
<p>任务的切割:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分割任务</span></span><br><span class="line">task.fork();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">        <span class="comment">// ForkJoinPool.WorkQueue workQueue，workQueue是ForkJoinPool的全局变量</span></span><br><span class="line">        <span class="comment">// 所有分割出来的任务都在一个queue中</span></span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ForkJoinPool.common.externalPush(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分段锁的原理-锁力度减小的思考"><a href="#分段锁的原理-锁力度减小的思考" class="headerlink" title="分段锁的原理,锁力度减小的思考"></a>分段锁的原理,锁力度减小的思考</h3><h3 id="八种阻塞队列以及各个阻塞队列的特性"><a href="#八种阻塞队列以及各个阻塞队列的特性" class="headerlink" title="八种阻塞队列以及各个阻塞队列的特性"></a>八种阻塞队列以及各个阻塞队列的特性</h3><p>ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。<br>LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。<br>PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。<br>DelayQueue：使用优先级队列实现的无界阻塞队列。<br>SynchronousQueue：不存储元素的阻塞队列。<br>LinkedTransferQueue：链表结构组成的无界阻塞队列。<br>LinkedBlockingDeque：链表结构组成的双向阻塞队列。</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法/处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">插入</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td style="text-align:left">移除</td>
<td>remove()</td>
<td>poll ()</td>
<td>take()</td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td style="text-align:left">检查</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody>
</table>
<p>如果是无界阻塞队列，队列不可能会出现满的情况，所以使用put或offer方法永远不会被阻塞，而且使用offer方法时，该方法永远返回rue。</p>
<p>实现：</p>
<p>通过Lock和Condition实现，插入市判断容量调用LockSupport的await或signal方法</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="详细jvm内存模型"><a href="#详细jvm内存模型" class="headerlink" title="详细jvm内存模型"></a>详细jvm内存模型</h3><p><a href="/java/jvm内存模型">jvm内存模型</a></p>
<h3 id="讲讲什么情况下回出现内存溢出，内存泄漏？"><a href="#讲讲什么情况下回出现内存溢出，内存泄漏？" class="headerlink" title="讲讲什么情况下回出现内存溢出，内存泄漏？"></a>讲讲什么情况下回出现内存溢出，内存泄漏？</h3><p>内存溢出：指程序申请内存时,没有足够的内存空间使用</p>
<p>内存泄漏：指程序申请了内存后(new),用完的内存没有释放(delete),一直被某个或某些实例所持有却不再被使用导致 GC 不能回收</p>
<p><a href="https://www.jianshu.com/p/e97ed5d8a403" target="_blank" rel="noopener">https://www.jianshu.com/p/e97ed5d8a403</a><br><a href="http://www.cnblogs.com/lcplcpjava/p/6594575.html" target="_blank" rel="noopener">关于java内存泄露的总结–引用的类型：强引用，弱引用，软引用</a></p>
<h3 id="说说Java线程栈"><a href="#说说Java线程栈" class="headerlink" title="说说Java线程栈"></a>说说Java线程栈</h3><p><a href="https://blog.csdn.net/hust_superman/article/details/39402087" target="_blank" rel="noopener">https://blog.csdn.net/hust_superman/article/details/39402087</a></p>
<h3 id="JVM-年轻代到年老代的晋升过程的判断条件是什么呢？"><a href="#JVM-年轻代到年老代的晋升过程的判断条件是什么呢？" class="headerlink" title="JVM 年轻代到年老代的晋升过程的判断条件是什么呢？"></a>JVM 年轻代到年老代的晋升过程的判断条件是什么呢？</h3><ol>
<li>大对象直接进入老年代</li>
<li>存活一定时间的年轻代晋升老年代</li>
<li>同一年代的对象在monitor gc后，占用内存大于Survivor的二分之一，晋升老年代</li>
</ol>
<h3 id="JVM-出现-fullGC-很频繁，怎么去线上排查问题？"><a href="#JVM-出现-fullGC-很频繁，怎么去线上排查问题？" class="headerlink" title="JVM 出现 fullGC 很频繁，怎么去线上排查问题？"></a>JVM 出现 fullGC 很频繁，怎么去线上排查问题？</h3><ol>
<li>​</li>
</ol>
<h3 id="类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？"><a href="#类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？" class="headerlink" title="类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？"></a>类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？</h3><p><a href="http://www.cnblogs.com/lanxuezaipiao/p/4138511.html" target="_blank" rel="noopener">http://www.cnblogs.com/lanxuezaipiao/p/4138511.html</a></p>
<p>解决基础类的统一问题</p>
<p>打破场景：</p>
<ol>
<li><a href="https://blog.csdn.net/yangcheng33/article/details/52631940" target="_blank" rel="noopener">线程上下文类加载器（Thread Context Classloader）</a></li>
<li>OSGI</li>
</ol>
<h3 id="类的实例化顺序"><a href="#类的实例化顺序" class="headerlink" title="类的实例化顺序"></a>类的实例化顺序</h3><p><a href="https://blog.csdn.net/zd836614437/article/details/64126826" target="_blank" rel="noopener">https://blog.csdn.net/zd836614437/article/details/64126826</a></p>
<p><a href="https://segmentfault.com/a/1190000004527951" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004527951</a></p>
<h3 id="JVM垃圾回收机制，何时触发MinorGC等操作"><a href="#JVM垃圾回收机制，何时触发MinorGC等操作" class="headerlink" title="JVM垃圾回收机制，何时触发MinorGC等操作"></a>JVM垃圾回收机制，何时触发MinorGC等操作</h3><p>Minor GC触发条件：当Eden区满时，触发Minor GC。</p>
<p>Full GC触发条件：</p>
<p>（1）调用System.gc时，系统建议执行Full GC，但是不必然执行</p>
<p>（2）老年代空间不足</p>
<p>（3）方法区空间不足</p>
<p>（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存</p>
<p>（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p>
<h3 id="JVM-中一次完整的-GC-流程（从-ygc-到-fgc）是怎样的"><a href="#JVM-中一次完整的-GC-流程（从-ygc-到-fgc）是怎样的" class="headerlink" title="JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的"></a>JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的</h3><p>答：对象优先在Eden区中分配，若没有足够空间，Minor GC；<br>大对象（需要大量连续内存空间）直接进入老年态；长期存活的对象进入老年态。如果对象在新生代出生并经过第一次MGC后仍然存活，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。</p>
<p><a href="https://blog.csdn.net/zd836614437/article/details/64126826" target="_blank" rel="noopener">https://blog.csdn.net/zd836614437/article/details/64126826</a></p>
<h3 id="各种回收器，各自优缺点，重点CMS、G1"><a href="#各种回收器，各自优缺点，重点CMS、G1" class="headerlink" title="各种回收器，各自优缺点，重点CMS、G1"></a>各种回收器，各自优缺点，重点CMS、G1</h3><p><img src="/Users/joyo/Documents/面试/image-201803282306260.png" alt="mage-20180328230626"></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial</td>
<td>client机器上、简单而高效</td>
<td>单线程；STW</td>
</tr>
<tr>
<td>ParNew</td>
<td>多线程</td>
<td>STW</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>时间可控</td>
<td></td>
</tr>
<tr>
<td>Serial Old</td>
<td></td>
<td>单线程；STW</td>
</tr>
<tr>
<td>Parallel Old</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CMS</td>
<td>占用用户时间少；并发收集、低停顿</td>
<td>CPU资源非常敏感；无法处理浮动垃圾；空间碎片</td>
</tr>
<tr>
<td>G1</td>
<td>无空间碎片；低停顿；并发执行；支持大内存；</td>
<td>是的</td>
</tr>
</tbody>
</table>
<p><a href="https://blog.csdn.net/qq_25396633/article/details/72972008" target="_blank" rel="noopener">CMS收集器和G1收集器优缺点</a><br><a href="/java/G1GC">g1 gc</a></p>
<h3 id="各种回收算法"><a href="#各种回收算法" class="headerlink" title="各种回收算法"></a>各种回收算法</h3><ol>
<li>标记 - 清除</li>
<li>标记 - 整理</li>
<li>复制</li>
<li>分代收集算法</li>
</ol>
<h3 id="OOM错误，stackoverflow错误，permgen-space错误"><a href="#OOM错误，stackoverflow错误，permgen-space错误" class="headerlink" title="OOM错误，stackoverflow错误，permgen space错误"></a>OOM错误，stackoverflow错误，permgen space错误</h3><p><a href="https://my.oschina.net/liting/blog/476918" target="_blank" rel="noopener">https://my.oschina.net/liting/blog/476918</a></p>
<h3 id="JVM-之-OopMap-和-RememberedSet"><a href="#JVM-之-OopMap-和-RememberedSet" class="headerlink" title="JVM 之 OopMap 和 RememberedSet"></a><a href="http://dsxwjhf.iteye.com/blog/2201685" target="_blank" rel="noopener">JVM 之 OopMap 和 RememberedSet</a></h3><p>OopMap：记录了从栈到堆的引用关系，以避免全栈扫描，加快枚举根节点的速度。它的另外一个更根本的作用是，可以帮助 HotSpot 实现准确式 GC。</p>
<p>RememberSet：记录老年代对象引用新生代对象。</p>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="BeanFactory-和-FactoryBean？"><a href="#BeanFactory-和-FactoryBean？" class="headerlink" title="BeanFactory 和 FactoryBean？"></a>BeanFactory 和 FactoryBean？</h3><p><strong>BeanFactory</strong>:</p>
<p>BeanFactory，以Factory结尾，表示它是一个工厂类(接口)，用于管理Bean的一个工厂。在Spring中，BeanFactory是IOC容器的核心接口，它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</p>
<p>Spring为我们提供了许多易用的BeanFactory实现，XmlBeanFactory就是常用的一个，该实现将以XML方式描述组成应用的对象及对象间的依赖关系。XmlBeanFactory类将持有此XML配置元数据，并用它来构建一个完全可配置的系统或应用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// No.1</span></span><br><span class="line">Resource resource = <span class="keyword">new</span> FileSystemResource(<span class="string">"beans.xml"</span>);</span><br><span class="line">BeanFactory factory = <span class="keyword">new</span> XmlBeanFactory(resource);</span><br><span class="line"><span class="comment">// No.2</span></span><br><span class="line">ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"beans.xml"</span>);</span><br><span class="line">BeanFactory factory = <span class="keyword">new</span> XmlBeanFactory(resource);</span><br><span class="line"><span class="comment">// No.3</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[] &#123;<span class="string">"applicationContext.xml"</span>, <span class="string">"applicationContext-part2.xml"</span>&#125;);</span><br><span class="line">BeanFactory factory = (BeanFactory) context;</span><br></pre></td></tr></table></figure>
<p><strong>FactoryBean</strong>:</p>
<p>实现 <code>FactoryBean</code> 的类表明此类也是一个Bean，类型为工厂Bean（Spring中共有两种bean，一种为普通bean，另一种则为工厂bean）。顾名思义，它也是用来管理Bean的，而它本身由spring管理。</p>
<p>FactoryBean管理的bean实际上也是由spring进行配置、实例化、管理，因此由FactoryBean管理的bean不能再次配置到spring配置文件中（xml、java类配置、注解均不可以），否则会报异常。</p>
<h3 id="Spring-IOC-的理解，其初始化过程？"><a href="#Spring-IOC-的理解，其初始化过程？" class="headerlink" title="Spring IOC 的理解，其初始化过程？"></a>Spring IOC 的理解，其初始化过程？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext appContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"cjj/models/beans.xml"</span>);</span><br><span class="line">Person p = (Person)appContext.getBean(<span class="string">"person"</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，在创建ApplicationContext实例对象过程中会创建一个spring容器，该容器会读取配置文件”cjj/models/beans.xml”,并统一管理由该文件中定义好的所有bean实例对象，如果要获取某个bean实例，使用getBean方法就行了。例如我们只需要将Person提前配置在beans.xml文件中（可以理解为注入），之后我们可以不需使用new Person()的方式创建实例，而是通过容器来获取Person实例，这就相当于将Person的控制权交由spring容器了，差不多这就是控制反转的概念。</p>
<p>Spring中有两个主要的容器系列：</p>
<ol>
<li>实现BeanFactory接口的简单容器；</li>
<li>实现ApplicationContext接口的高级容器。ApplicationContext比较复杂，它不但继承了BeanFactory的大部分属性，还继承其它可扩展接口，扩展的了许多高级的属性。</li>
</ol>
<p><strong>初始化过程</strong>：</p>
<ol>
<li>Resource定位（Bean的定义文件定位）</li>
<li>将Resource定位好的资源载入到BeanDefinition</li>
<li>将BeanDefiniton注册到容器中</li>
</ol>
<p><img src="/images/typora/image-201803202344054.png" alt="mage-20180320234405"></p>
<p>容器初始化的时候会预先对单例和非延迟加载的对象进行预先初始化。其他的都是延迟加载是在第一次调用getBean 的时候被创建。</p>
<h4 id="第一步-Resource定位"><a href="#第一步-Resource定位" class="headerlink" title="第一步 Resource定位"></a>第一步 Resource定位</h4><p>可以通过先获取resource，再获取beanFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Resource resource = <span class="keyword">new</span> FileSystemResource(<span class="string">"beans.xml"</span>);</span><br><span class="line">BeanFactory factory = <span class="keyword">new</span> XmlBeanFactory(resource);</span><br></pre></td></tr></table></figure>
<p>　　<strong>FileSystemResource：</strong>以文件的绝对路径方式进行访问资源，效果类似于Java中的File;<br>　　<strong>ClassPathResourcee：</strong>以类路径的方式访问资源，效果类似于this.getClass().getResource(“/“).getPath();<br>　　<strong>ServletContextResource：</strong>web应用根目录的方式访问资源，效果类似于request.getServletContext().getRealPath(“”);<br>　　<strong>UrlResource：</strong>访问网络资源的实现类。例如file: http: ftp:等前缀的资源对象;<br>　　<strong>ByteArrayResource:</strong> 访问字节数组资源的实现类。</p>
<p>也可以直接创建applicationContext对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="comment">//super方法为容器设置好Bean资源加载器</span></span><br><span class="line">	<span class="comment">//该方法最终会调用到AbstractApplicationContext的无参构造方法</span></span><br><span class="line">	<span class="comment">//这里会默认设置解析路径的模式为Ant-style</span></span><br><span class="line">	<span class="keyword">super</span>(parent);</span><br><span class="line">	<span class="comment">//设置Bean定义资源文件的路径</span></span><br><span class="line">	setConfigLocations(configLocations);</span><br><span class="line">	<span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">		<span class="comment">//调用容器的refresh，载入BeanDefinition的入口</span></span><br><span class="line">		refresh();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：ApplicationContext的所有实现类都实现RecourceLoader接口，因此可以直接调用getResource（参数）获取Resoure对象<strong>。</strong>不同的ApplicatonContext实现类使用getResource方法取得的资源类型不同，例如：FileSystemXmlApplicationContext.getResource获取的就是FileSystemResource实例；ClassPathXmlApplicationContext.gerResource获取的就是ClassPathResource实例；XmlWebApplicationContext.getResource获取的就是ServletContextResource实例，另外像不需要通过xml直接使用注解@Configuation方式加载资源的AnnotationConfigApplicationContext等等。</p>
<h4 id="第二步-通过返回的resource对象，进行BeanDefinition的载入"><a href="#第二步-通过返回的resource对象，进行BeanDefinition的载入" class="headerlink" title="第二步 通过返回的resource对象，进行BeanDefinition的载入"></a>第二步 通过返回的resource对象，进行BeanDefinition的载入</h4><p>总之，BeanDefinition相当于一个数据结构，这个数据结构的生成过程是根据定位的resource资源对象中的bean而来的，这些bean在Spirng IoC容器内部表示成了的BeanDefintion这样的数据结构，IoC容器对bean的管理和依赖注入的实现都是通过操作BeanDefinition来进行的。</p>
<p>1.构造BeanFactory时，首先调用的是BeanDefinitionReader类型的reader属性的loadBeanDefinitions()方法，是整个资源加载的切入点。</p>
<ul>
<li>封装资源文件：当进入BeanDefinitionReader后首先对参数Resource进行EncodedResource类进行封装</li>
<li>获取输入流：从Resource中获取InputStream并构造InputSource</li>
<li>通过构造器的InputSource实例和Resource实例继续调用loadBeanDefinitions.</li>
</ul>
<p>2.loadBeanDefinition调用doLoadBeanDefinitons方法，完成以下三个方法</p>
<ul>
<li>对XML文档的验证模式</li>
<li>用DocumentLoader处理资源文件，生成Document</li>
<li>根据返回的Document信息注册bean信息</li>
</ul>
<h4 id="第三步，将BeanDefiniton注册到容器中"><a href="#第三步，将BeanDefiniton注册到容器中" class="headerlink" title="第三步，将BeanDefiniton注册到容器中"></a>第三步，将BeanDefiniton注册到容器中</h4><p>最终Bean配置会被解析成BeanDefinition并与beanName,Alias一同封装到BeanDefinitionHolder中,之后beanFactory.registerBeanDefinition(beanName, bdHolder.getBeanDefinition())，注册到DefaultListableBeanFactory.beanDefinitionMap中。之后客户端如果要获取Bean对象，Spring容器会根据注册的BeanDefinition信息进行实例化。</p>
<p><a href="https://www.cnblogs.com/chenjunjie12321/p/6124649.html" target="_blank" rel="noopener">参考1</a>   <a href="http://blog.csdn.net/u010796790/article/details/52623328" target="_blank" rel="noopener">参考2</a></p>
<h3 id="BeanFactory-和-ApplicationContext？"><a href="#BeanFactory-和-ApplicationContext？" class="headerlink" title="BeanFactory 和 ApplicationContext？"></a>BeanFactory 和 ApplicationContext？</h3><p>ApplicationContext 继承BeanFactory，添加了一些属性和方法。</p>
<ul>
<li>BeanFactory容器中，不会调用ApplicationContextAware接口的setApplicationContext()方法，</li>
<li>BeanPostProcessor接口的postProcessBeforeInitialzation()方法和postProcessAfterInitialization()方法不会自动调用，必须自己通过代码手动注册</li>
<li>BeanFactory容器启动的时候，不会去实例化所有Bean,包括所有scope为singleton且非懒加载的Bean也是一样，而是在调用的时候去实例化。</li>
</ul>
<h3 id="Spring-Bean-的生命周期，如何被管理的？"><a href="#Spring-Bean-的生命周期，如何被管理的？" class="headerlink" title="Spring Bean 的生命周期，如何被管理的？"></a>Spring Bean 的生命周期，如何被管理的？</h3><p><a href="https://www.jianshu.com/p/3944792a5fff" target="_blank" rel="noopener">https://www.jianshu.com/p/3944792a5fff</a></p>
<h3 id="Spring-Bean-的加载过程是怎样的？"><a href="#Spring-Bean-的加载过程是怎样的？" class="headerlink" title="Spring Bean 的加载过程是怎样的？"></a>Spring Bean 的加载过程是怎样的？</h3><p><a href="https://segmentfault.com/a/1190000012887776" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012887776</a></p>
<p><a href="http://www.cnblogs.com/xrq730/p/6285358.html" target="_blank" rel="noopener">http://www.cnblogs.com/xrq730/p/6285358.html</a></p>
<h3 id="如果要你实现Spring-AOP，请问怎么实现？"><a href="#如果要你实现Spring-AOP，请问怎么实现？" class="headerlink" title="如果要你实现Spring AOP，请问怎么实现？"></a>如果要你实现Spring AOP，请问怎么实现？</h3><h3 id="如果要你实现Spring-IOC，你会注意哪些问题？"><a href="#如果要你实现Spring-IOC，你会注意哪些问题？" class="headerlink" title="如果要你实现Spring IOC，你会注意哪些问题？"></a>如果要你实现Spring IOC，你会注意哪些问题？</h3><h3 id="Spring-是如何管理事务的，事务管理机制？"><a href="#Spring-是如何管理事务的，事务管理机制？" class="headerlink" title="Spring 是如何管理事务的，事务管理机制？"></a>Spring 是如何管理事务的，事务管理机制？</h3><ol>
<li>编程式事务管理<ol>
<li>TransactionDefinition</li>
<li>PlatformTransactionManager</li>
<li>TransactionStatus</li>
</ol>
</li>
<li>声明式事务管理(AOP和IOC)<ol>
<li>DataSource</li>
<li>TransactionManager</li>
</ol>
</li>
</ol>
<p><a href="https://blog.csdn.net/justloveyou_/article/details/73733278" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_/article/details/73733278</a></p>
<h3 id="Spring-的不同事务传播行为有哪些，干什么用的？"><a href="#Spring-的不同事务传播行为有哪些，干什么用的？" class="headerlink" title="Spring 的不同事务传播行为有哪些，干什么用的？"></a>Spring 的不同事务传播行为有哪些，干什么用的？</h3><p><a href="https://blog.csdn.net/it_wangxiangpan/article/details/24180085" target="_blank" rel="noopener">浅析Spring事务传播行为</a></p>
<h3 id="Spring中事务的隔离级别"><a href="#Spring中事务的隔离级别" class="headerlink" title="Spring中事务的隔离级别"></a>Spring中事务的隔离级别</h3><p>[<a href="https://blog.csdn.net/a837199685/article/details/54563740" target="_blank" rel="noopener">MySQL事务隔离级别和Spring事务关系介绍</a></p>
<h3 id="Spring-中用到了那些设计模式？"><a href="#Spring-中用到了那些设计模式？" class="headerlink" title="Spring 中用到了那些设计模式？"></a>Spring 中用到了那些设计模式？</h3><p><a href="https://www.cnblogs.com/yuefan/p/3763898.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuefan/p/3763898.html</a></p>
<p><a href="http://www.uml.org.cn/j2ee/201301074.asp" target="_blank" rel="noopener">http://www.uml.org.cn/j2ee/201301074.asp</a></p>
<p><a href="http://wiki.jikexueyuan.com/project/design-pattern-creation/" target="_blank" rel="noopener">设计模式之创建型模式</a></p>
<h3 id="Spring-MVC-的工作原理？"><a href="#Spring-MVC-的工作原理？" class="headerlink" title="Spring MVC 的工作原理？"></a>Spring MVC 的工作原理？</h3><p><a href="https://blog.csdn.net/liang5630/article/details/43733733" target="_blank" rel="noopener">SpringMVC工作原理</a></p>
<h3 id="Spring-循环注入的原理？"><a href="#Spring-循环注入的原理？" class="headerlink" title="Spring 循环注入的原理？"></a>Spring 循环注入的原理？</h3><h3 id="Spring-AOP的理解，各个术语，他们是怎么相互工作的？"><a href="#Spring-AOP的理解，各个术语，他们是怎么相互工作的？" class="headerlink" title="Spring AOP的理解，各个术语，他们是怎么相互工作的？"></a>Spring AOP的理解，各个术语，他们是怎么相互工作的？</h3><p>分离业务逻辑和系统逻辑；<br>有各种各样的常见的很好的方面的例子，如日志记录、审计、声明式事务、安全性和缓存等</p>
<p>原理：jdk动态代理、cglib动态代理<br>与AspectJ的静态代理不同，Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。<br>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。<br>如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p>
<p><a href="https://wiki.jikexueyuan.com/project/spring/aop-with-spring.html" target="_blank" rel="noopener">https://wiki.jikexueyuan.com/project/spring/aop-with-spring.html</a><br><a href="http://www.importnew.com/24305.html" target="_blank" rel="noopener">http://www.importnew.com/24305.html</a></p>
<h3 id="Spring-如何保证-Controller-并发的安全？"><a href="#Spring-如何保证-Controller-并发的安全？" class="headerlink" title="Spring 如何保证 Controller 并发的安全？"></a>Spring 如何保证 Controller 并发的安全？</h3><p><a href="https://blog.csdn.net/hejingyuan6/article/details/50363647" target="_blank" rel="noopener">https://blog.csdn.net/hejingyuan6/article/details/50363647</a></p>
<p><a href="http://www.cnblogs.com/duanxz/p/5051916.html" target="_blank" rel="noopener">http://www.cnblogs.com/duanxz/p/5051916.html</a></p>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><h3 id="BIO、NIO和AIO"><a href="#BIO、NIO和AIO" class="headerlink" title="BIO、NIO和AIO"></a>BIO、NIO和AIO</h3><h3 id="Netty-的各大组件"><a href="#Netty-的各大组件" class="headerlink" title="Netty 的各大组件"></a>Netty 的各大组件</h3><p><a href="http://cmsblogs.com/?p=2467" target="_blank" rel="noopener">【死磕Netty】—–Netty的核心组件</a></p>
<h3 id="Netty的线程模型"><a href="#Netty的线程模型" class="headerlink" title="Netty的线程模型"></a>Netty的线程模型</h3><p><a href="https://segmentfault.com/a/1190000007403873" target="_blank" rel="noopener">Netty 源码分析之 三 我就是大名鼎鼎的 EventLoop(一)</a><br><a href="https://www.jianshu.com/p/1a6d1a25e6cc" target="_blank" rel="noopener">Netty概述</a></p>
<h3 id="TCP-粘包-拆包的原因及解决方法"><a href="#TCP-粘包-拆包的原因及解决方法" class="headerlink" title="TCP 粘包/拆包的原因及解决方法"></a>TCP 粘包/拆包的原因及解决方法</h3><p><a href="https://blog.insanecoder.top/tcp-packet-splice-and-split-issue/" target="_blank" rel="noopener">TCP粘包，拆包及解决方法</a><br><a href="https://www.jianshu.com/p/1a6d1a25e6cc" target="_blank" rel="noopener">Netty概述</a></p>
<h3 id="了解哪几种序列化协议？包括使用场景和如何去选择"><a href="#了解哪几种序列化协议？包括使用场景和如何去选择" class="headerlink" title="了解哪几种序列化协议？包括使用场景和如何去选择"></a>了解哪几种序列化协议？包括使用场景和如何去选择</h3><p>影响序列化性能的关键因素：<br>1、序列化后的码流大小（网络带宽的占用）；<br>2、序列化的性能（CPU资源占用）；<br>3、是否支持跨语言（异构系统的对接和开发语言切换）。</p>
<p>1、json<br>2、xml<br>3、Protobuf<br>4、Avro<br>5、Thrift</p>
<p><a href="https://www.jianshu.com/p/1a6d1a25e6cc" target="_blank" rel="noopener">Netty概述</a></p>
<h3 id="Netty的零拷贝实现"><a href="#Netty的零拷贝实现" class="headerlink" title="Netty的零拷贝实现"></a>Netty的零拷贝实现</h3><p>Netty的零拷贝体现在三个方面： </p>
<ol>
<li>Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。 </li>
<li>Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。 </li>
<li>Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。</li>
</ol>
<p><a href="/netty/netty相关概念">netty相关概念</a></p>
<h3 id="Netty的高性能表现在哪些方面"><a href="#Netty的高性能表现在哪些方面" class="headerlink" title="Netty的高性能表现在哪些方面"></a>Netty的高性能表现在哪些方面</h3><p>1、并发高<br>nio、reactor模型<br>2、传输快<br>zero copy<br>3、封装好<br>api简单</p>
<p><a href="https://www.jianshu.com/p/b9f3f6a16911" target="_blank" rel="noopener">Netty入门教程——认识Netty</a></p>
<h2 id="分布式相关"><a href="#分布式相关" class="headerlink" title="分布式相关"></a>分布式相关</h2><h3 id="Zookeeper的用途，选举的原理是什么？"><a href="#Zookeeper的用途，选举的原理是什么？" class="headerlink" title="Zookeeper的用途，选举的原理是什么？"></a>Zookeeper的用途，选举的原理是什么？</h3><h3 id="zookeeper原理和适用场景"><a href="#zookeeper原理和适用场景" class="headerlink" title="zookeeper原理和适用场景"></a>zookeeper原理和适用场景</h3><h3 id="zookeeper-watch机制"><a href="#zookeeper-watch机制" class="headerlink" title="zookeeper watch机制"></a>zookeeper watch机制</h3><h3 id="zookeeper的选举策略"><a href="#zookeeper的选举策略" class="headerlink" title="zookeeper的选举策略"></a>zookeeper的选举策略</h3><h3 id="redis-zk节点宕机如何处理"><a href="#redis-zk节点宕机如何处理" class="headerlink" title="redis/zk节点宕机如何处理"></a>redis/zk节点宕机如何处理</h3><h3 id="如何做一个分布式锁"><a href="#如何做一个分布式锁" class="headerlink" title="如何做一个分布式锁"></a>如何做一个分布式锁</h3><h3 id="Dubbo的底层实现原理和机制"><a href="#Dubbo的底层实现原理和机制" class="headerlink" title="Dubbo的底层实现原理和机制"></a>Dubbo的底层实现原理和机制</h3><h3 id="Dubbo的服务请求失败怎么处理"><a href="#Dubbo的服务请求失败怎么处理" class="headerlink" title="Dubbo的服务请求失败怎么处理"></a>Dubbo的服务请求失败怎么处理</h3><h3 id="描述一个服务从发布到被消费的详细过程"><a href="#描述一个服务从发布到被消费的详细过程" class="headerlink" title="描述一个服务从发布到被消费的详细过程"></a>描述一个服务从发布到被消费的详细过程</h3><h3 id="分布式系统怎么做服务治理"><a href="#分布式系统怎么做服务治理" class="headerlink" title="分布式系统怎么做服务治理"></a>分布式系统怎么做服务治理</h3><h3 id="接口的幂等性的概念"><a href="#接口的幂等性的概念" class="headerlink" title="接口的幂等性的概念"></a>接口的幂等性的概念</h3><h3 id="重连机制会不会造成错误"><a href="#重连机制会不会造成错误" class="headerlink" title="重连机制会不会造成错误"></a>重连机制会不会造成错误</h3><h3 id="如何实现负载均衡，有哪些算法可以实现？"><a href="#如何实现负载均衡，有哪些算法可以实现？" class="headerlink" title="如何实现负载均衡，有哪些算法可以实现？"></a>如何实现负载均衡，有哪些算法可以实现？</h3><h3 id="用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗"><a href="#用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗" class="headerlink" title="用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗"></a>用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗</h3><h3 id="消息中间件如何解决消息丢失问题"><a href="#消息中间件如何解决消息丢失问题" class="headerlink" title="消息中间件如何解决消息丢失问题"></a>消息中间件如何解决消息丢失问题</h3><h3 id="MQ系统的数据如何保证不丢失"><a href="#MQ系统的数据如何保证不丢失" class="headerlink" title="MQ系统的数据如何保证不丢失"></a>MQ系统的数据如何保证不丢失</h3><h3 id="数据的垂直拆分水平拆分。"><a href="#数据的垂直拆分水平拆分。" class="headerlink" title="数据的垂直拆分水平拆分。"></a>数据的垂直拆分水平拆分。</h3><h3 id="列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询的问题"><a href="#列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询的问题" class="headerlink" title="列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询的问题"></a>列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询的问题</h3><h3 id="对分布式事务的理解"><a href="#对分布式事务的理解" class="headerlink" title="对分布式事务的理解"></a>对分布式事务的理解</h3><h3 id="分布式集群下如何做到唯一序列号"><a href="#分布式集群下如何做到唯一序列号" class="headerlink" title="分布式集群下如何做到唯一序列号"></a>分布式集群下如何做到唯一序列号</h3><h3 id="全局ID"><a href="#全局ID" class="headerlink" title="全局ID"></a>全局ID</h3><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="mysql分页有什么优化"><a href="#mysql分页有什么优化" class="headerlink" title="mysql分页有什么优化"></a>mysql分页有什么优化</h3><p><a href="https://blog.csdn.net/bingduanlbd/article/details/51767850" target="_blank" rel="noopener">https://blog.csdn.net/bingduanlbd/article/details/51767850</a></p>
<p><a href="https://my.oschina.net/No5stranger/blog/158202" target="_blank" rel="noopener">https://my.oschina.net/No5stranger/blog/158202</a></p>
<h3 id="两阶段锁协议"><a href="#两阶段锁协议" class="headerlink" title="两阶段锁协议"></a>两阶段锁协议</h3><p><a href="https://www.cnblogs.com/zszmhd/p/3365220.html" target="_blank" rel="noopener">https://www.cnblogs.com/zszmhd/p/3365220.html</a></p>
<h3 id="悲观锁、乐观锁"><a href="#悲观锁、乐观锁" class="headerlink" title="悲观锁、乐观锁"></a>悲观锁、乐观锁</h3><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p>
<p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。</p>
<p><a href="https://www.jianshu.com/p/f5ff017db62a" target="_blank" rel="noopener">MySQL 乐观锁与悲观锁</a></p>
<p><a href="http://www.hollischuang.com/archives/934" target="_blank" rel="noopener">深入理解乐观锁与悲观锁</a></p>
<p>MySQL InnoDB中使用悲观锁<br>要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0;</p>
<h3 id="组合索引，最左原则"><a href="#组合索引，最左原则" class="headerlink" title="组合索引，最左原则"></a>组合索引，最左原则</h3><p><a href="/mysql/mysql索引及查询优化">mysql索引及查询优化</a></p>
<h3 id="mysql-的表锁、行锁"><a href="#mysql-的表锁、行锁" class="headerlink" title="mysql 的表锁、行锁"></a>mysql 的表锁、行锁</h3><p>行锁：<br>使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。<strong>行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。</strong></p>
<h3 id="mysql-性能优化"><a href="#mysql-性能优化" class="headerlink" title="mysql 性能优化"></a>mysql 性能优化</h3><p>1、建索引<br>2、查询优化<br>3、数据类型（比如用ENUM代替VARCHAR等）</p>
<p><a href="/mysql/mysql索引及查询优化">mysql索引及查询优化</a></p>
<h3 id="mysql的索引分类：B-，hash；什么情况用什么索引"><a href="#mysql的索引分类：B-，hash；什么情况用什么索引" class="headerlink" title="mysql的索引分类：B+，hash；什么情况用什么索引"></a>mysql的索引分类：B+，hash；什么情况用什么索引</h3><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p>
<h3 id="事务的特性和隔离级别"><a href="#事务的特性和隔离级别" class="headerlink" title="事务的特性和隔离级别"></a>事务的特性和隔离级别</h3><ol>
<li>原子性</li>
<li>一致性</li>
<li>持久性</li>
<li>隔离性</li>
</ol>
<ol>
<li>Serializable（串行化）：可避免脏读、不可重复读、幻读的发生。（级别最高）</li>
<li>Repeatable-read（可重复读）：可避免脏读、不可重复读的发生。</li>
<li>Read-committed（读已提交）：可避免脏读的发生。</li>
<li>Read-uncommitted（读未提交）：最低级别，任何情况都无法保证。（级别最低）</li>
</ol>
<p><a href="https://blog.csdn.net/lamp_yang_3533/article/details/79344736" target="_blank" rel="noopener">https://blog.csdn.net/lamp_yang_3533/article/details/79344736</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_8020e4110101bfc6.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_8020e4110101bfc6.html</a></p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="Redis用过哪些数据数据，以及Redis底层怎么实现"><a href="#Redis用过哪些数据数据，以及Redis底层怎么实现" class="headerlink" title="Redis用过哪些数据数据，以及Redis底层怎么实现"></a>Redis用过哪些数据数据，以及Redis底层怎么实现</h3><p>String: int、SDS<br>list: linkedlist、ziplist<br>map: hashtable、ziplist<br>set: hashtable、intset<br>sorted-set：ziplist、skiplist + hashtable</p>
<h3 id="Redis缓存穿透，缓存雪崩"><a href="#Redis缓存穿透，缓存雪崩" class="headerlink" title="Redis缓存穿透，缓存雪崩"></a>Redis缓存穿透，缓存雪崩</h3><p><a href="/redis/redis缓存">redis缓存</a></p>
<h3 id="如何使用Redis来实现分布式锁"><a href="#如何使用Redis来实现分布式锁" class="headerlink" title="如何使用Redis来实现分布式锁"></a>如何使用Redis来实现分布式锁</h3><ol>
<li>setNX、getSET、get</li>
<li>redlock</li>
</ol>
<h3 id="Redis的并发竞争问题如何解决"><a href="#Redis的并发竞争问题如何解决" class="headerlink" title="Redis的并发竞争问题如何解决"></a>Redis的并发竞争问题如何解决</h3><p>Redis的并发通过队列模式，编程串行模式执行</p>
<p>客户端实现：</p>
<ol>
<li>synchronized</li>
</ol>
<p>redis服务端实现：</p>
<ol>
<li>setNX锁</li>
<li>watch + 事务</li>
</ol>
<h3 id="Redis持久化的几种方式，优缺点是什么，怎么实现的"><a href="#Redis持久化的几种方式，优缺点是什么，怎么实现的" class="headerlink" title="Redis持久化的几种方式，优缺点是什么，怎么实现的"></a>Redis持久化的几种方式，优缺点是什么，怎么实现的</h3><p>AOF：丢失数据少；文件大、恢复慢、有bug；<br>RDB：文件小、恢复快；丢失数据多<br><a href="/redis/redis持久化">redis持久化</a></p>
<h3 id="Redis的缓存过期策略"><a href="#Redis的缓存过期策略" class="headerlink" title="Redis的缓存过期策略"></a>Redis的缓存过期策略</h3><p><a href="/redis/Redis的缓存过期策略">Redis的缓存过期策略</a></p>
<h3 id="Redis集群，高可用，原理"><a href="#Redis集群，高可用，原理" class="headerlink" title="Redis集群，高可用，原理"></a>Redis集群，高可用，原理</h3><h3 id="Redis缓存分片"><a href="#Redis缓存分片" class="headerlink" title="Redis缓存分片"></a>Redis缓存分片</h3><p>优点</p>
<ul>
<li>性能的提升，单机Redis的网络I/O能力和计算资源是有限的，将请求分散到多台机器，充分利用多台机器的计算能力可网络带宽，有助于提高Redis总体的服务能力。</li>
<li>存储的横向扩展，即使Redis的服务能力能够满足应用需求，但是随着存储数据的增加，单台机器受限于机器本身的存储容量，将数据分散到多台机器上存储使得Redis服务可以横向扩展。 </li>
</ul>
<p>缺点</p>
<ul>
<li>多键操作是不被支持的，比如我们将要批量操作的键被映射到了不同的Redis实例中。</li>
<li>多键的Redis事务是不被支持的。</li>
<li>分区的最小粒度是键，因此我们不能将关联到一个键的很大的数据集映射到不同的实例。</li>
<li>当应用分区的时候，数据的处理是非常复杂的，比如我们需要处理多个rdb/aof文件，将分布在不同实例的文件聚集到一起备份。</li>
<li>添加和删除机器是很复杂的，例如Redis集群支持几乎运行时透明的因为增加或减少机器而需要做的rebalancing,然而像客户端和代理分区这种方式是不支持这种功能的。</li>
</ul>
<p>分布方式</p>
<ul>
<li>范围分区</li>
<li>hash分区</li>
</ul>
<p>Pre-Sharding：<br>我们可以开启多个Redis实例，尽管是一台物理机器，我们在刚开始的时候也可以开启多个实例。我们可以从中选择一些实例，比如32或64个实例来作为我们的工作集群。当一台物理机器存储不够的时候，我们可以将一般的实例移动到我们的第二台物理机上，依次类对，我们可以保证集群中Redis的实例数不变，又可以达到扩充机器的目的。</p>
<p><a href="https://my.oschina.net/andylucc/blog/675986" target="_blank" rel="noopener">Redis分区实现原理</a></p>
<h3 id="Redis的数据淘汰策略"><a href="#Redis的数据淘汰策略" class="headerlink" title="Redis的数据淘汰策略"></a>Redis的数据淘汰策略</h3><p>volatile-lru -&gt; Evict using approximated LRU among the keys with an expire set.<br>allkeys-lru -&gt; Evict any key using approximated LRU.<br>volatile-lfu -&gt; Evict using approximated LFU among the keys with an expire set.<br>allkeys-lfu -&gt; Evict any key using approximated LFU.<br>volatile-random -&gt; Remove a random key among the ones with an expire set.<br>allkeys-random -&gt; Remove a random key, any key.<br>volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)<br>noeviction -&gt; Don’t evict anything, just return an error on write operations.</p>
<p><a href="https://github.com/bingbo/blog/wiki/Redis%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">Redis数据淘汰机制</a></p>
<h3 id="redis的过期策略如何实现"><a href="#redis的过期策略如何实现" class="headerlink" title="redis的过期策略如何实现"></a>redis的过期策略如何实现</h3><p><a href="/redis/redis的过期策略如何实现" target="_blank">redis的过期策略如何实现</a></p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="如何保证缓存与数据库的双写一致性"><a href="#如何保证缓存与数据库的双写一致性" class="headerlink" title="如何保证缓存与数据库的双写一致性"></a>如何保证缓存与数据库的双写一致性</h3><p><a href="/cache/如何保证缓存与数据库的双写一致性" target="_blank">如何保证缓存与数据库的双写一致性</a></p>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="为什么Kafka不支持读写分离"><a href="#为什么Kafka不支持读写分离" class="headerlink" title="为什么Kafka不支持读写分离"></a>为什么Kafka不支持读写分离</h3><p><a href="/kafka/为什么Kafka不支持读写分离" target="_blank">为什么Kafka不支持读写分离</a></p>
<h3 id="消息传递模型"><a href="#消息传递模型" class="headerlink" title="消息传递模型"></a>消息传递模型</h3><p><a href="/kafka/消息传递模型" target="_blank">为什么Kafka不支持读写分离</a></p>
<h3 id="Push-vs-Pull"><a href="#Push-vs-Pull" class="headerlink" title="Push vs. Pull"></a>Push vs. Pull</h3><p>对于消息的消费，ActiveMQ使用PUSH模型，而Kafka使用PULL模型，两者各有利弊，对于PUSH，broker很难控制数据发送给不同消费者的速度，而PULL可以由消费者自己控制，但是PULL模型可能造成消费者在没有消息的情况下盲等，这种情况下可以通过long polling机制缓解，而对于几乎每时每刻都有消息传递的流式系统，这种影响可以忽略。</p>
<h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>很多系统、组件为了提升效率一般恨不得把所有数据都扔到内存里，然后定期flush到磁盘上；可实际上，现代操作系统也是这样，所有的现代操作系统都乐于将空闲内存转作磁盘缓存（页面缓存），想不用都难；对于这样的系统，他的数据在内存中保存了一份，同时也在OS的页面缓存中保存了一份，这样不但多了一个步骤还让内存的使用率下降了一半；因此，Kafka决定直接使用页面缓存；但是随机写入的效率很慢，为了维护彼此的关系顺序还需要额外的操作和存储，而线性的写入可以避免这些，实际上，线性写入（linear write）的速度大约是300MB/秒，但随即写入却只有50k/秒，其中的差别接近10000倍。这样，Kafka以页面缓存为中间的设计在保证效率的同时还提供了消息的持久化，每个消费者自己维护当前读取数据的offser（也可委托给zookeeper），以此可同时支持在线和离线的消费。</p>
<h3 id="消息投递可靠性"><a href="#消息投递可靠性" class="headerlink" title="消息投递可靠性"></a>消息投递可靠性</h3><p> 一个消息如何算投递成功，Kafka提供了三种模式：</p>
<ul>
<li>第一种是啥都不管，发送出去就当作成功，这种情况当然不能保证消息成功投递到broker；</li>
<li>第二种是Master-Slave模型，只有当Master和所有Slave都接收到消息时，才算投递成功，这种模型提供了最高的投递可靠性，但是损伤了性能；</li>
<li>第三种模型，即只要Master确认收到消息就算投递成功；实际使用时，根据应用特性选择，绝大多数情况下都会中和可靠性和性能选择第三种模型</li>
</ul>
<p>消息在broker上的可靠性，因为消息会持久化到磁盘上，所以如果正常stop一个broker，其上的数据不会丢失；但是如果不正常stop，可能会使存在页面缓存来不及写入磁盘的消息丢失，这可以通过配置flush页面缓存的周期、阈值缓解，但是同样会频繁的写磁盘会影响性能，又是一个选择题，根据实际情况配置。</p>
<p>消息消费的可靠性，Kafka提供的是“At least once”模型，因为消息的读取进度由offset提供，offset可以由消费者自己维护也可以维护在zookeeper里，但是当消息消费后consumer挂掉，offset没有即时写回，就有可能发生重复读的情况，这种情况同样可以通过调整commit offset周期、阈值缓解，甚至消费者自己把消费和commit offset做成一个事务解决，但是如果你的应用不在乎重复消费，那就干脆不要解决，以换取最大的性能。</p>
<h3 id="Kafka服务器能接收到的最大信息是多少"><a href="#Kafka服务器能接收到的最大信息是多少" class="headerlink" title="Kafka服务器能接收到的最大信息是多少"></a>Kafka服务器能接收到的最大信息是多少</h3><p>Kafka服务器可以接收到的消息的最大大小是1000000字节。</p>
<h3 id="解释Kafka的Zookeeper是什么-我们可以在没有Zookeeper的情况下使用Kafka吗"><a href="#解释Kafka的Zookeeper是什么-我们可以在没有Zookeeper的情况下使用Kafka吗" class="headerlink" title="解释Kafka的Zookeeper是什么?我们可以在没有Zookeeper的情况下使用Kafka吗?"></a>解释Kafka的Zookeeper是什么?我们可以在没有Zookeeper的情况下使用Kafka吗?</h3><p>Zookeeper是一个开放源码的、高性能的协调服务，它用于Kafka的分布式应用。不，不可能越过Zookeeper，直接联系Kafka broker。一旦Zookeeper停止工作，它就不能服务客户端请求。</p>
<ul>
<li>Zookeeper主要用于在集群中不同节点之间进行通信</li>
<li>在Kafka中，它被用于提交偏移量，因此如果节点在任何情况下都失败了，它都可以从之前提交的偏移量中获取</li>
<li>除此之外，它还执行其他活动，如: leader检测、分布式同步、配置管理、识别新节点何时离开或连接、集群、节点实时状态等等。</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s/tDmBPPk0LAbNZ8d809-2ZA" target="_blank" rel="noopener">原文</a>   <a href="https://mp.weixin.qq.com/s?__biz=MzIwMzY1OTU1NQ==&amp;mid=2247484038&amp;idx=1&amp;sn=a31c83f3a132ee8fa816f7b1db3839eb&amp;chksm=96cd42caa1bacbdc807724ab48e5ce085f368fd17c1da7f7845c8faf2f1a39138c242d0161a8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">原文</a></p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/java/datastructure/ListSetMap/" rel="next" title="List、Set、Map">
                <i class="fa fa-chevron-left"></i> List、Set、Map
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/java/datastructure/treemap/" rel="prev" title="彻底看懂 so called 红黑树">
                彻底看懂 so called 红黑树 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Anti Zhou</p>
              <p class="site-description motion-element" itemprop="description">一入java深似海，从此娱乐是路人。</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">102</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">44</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://yakirchen.com/" title="yakir's notes" target="_blank">yakir's notes</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java基础"><span class="nav-number">1.</span> <span class="nav-text">Java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#List-、-Set、Map-的区别"><span class="nav-number">1.1.</span> <span class="nav-text">List 、 Set、Map 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashSet-是如何保证不重复的"><span class="nav-number">1.2.</span> <span class="nav-text">HashSet 是如何保证不重复的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）"><span class="nav-number">1.3.</span> <span class="nav-text">HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-的扩容过程"><span class="nav-number">1.4.</span> <span class="nav-text">HashMap 的扩容过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-1-7-与-1-8-的-区别，说明-1-8-做了哪些优化，如何优化的？"><span class="nav-number">1.5.</span> <span class="nav-text">HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final-finally-finalize"><span class="nav-number">1.6.</span> <span class="nav-text">final finally finalize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#强引用-、软引用、-弱引用、虚引用"><span class="nav-number">1.7.</span> <span class="nav-text">强引用 、软引用、 弱引用、虚引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java反射"><span class="nav-number">1.8.</span> <span class="nav-text">Java反射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Arrays-sort-实现原理和-Collection-实现原理"><span class="nav-number">1.9.</span> <span class="nav-text">Arrays.sort 实现原理和 Collection 实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashMap的应用"><span class="nav-number">1.10.</span> <span class="nav-text">LinkedHashMap的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cloneable接口实现原理"><span class="nav-number">1.11.</span> <span class="nav-text">cloneable接口实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java创建对象的几种方式"><span class="nav-number">1.12.</span> <span class="nav-text">Java创建对象的几种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常分类以及处理机制"><span class="nav-number">1.13.</span> <span class="nav-text">异常分类以及处理机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait和sleep的区别"><span class="nav-number">1.14.</span> <span class="nav-text">wait和sleep的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组在内存中如何分配"><span class="nav-number">1.15.</span> <span class="nav-text">数组在内存中如何分配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-并发"><span class="nav-number">2.</span> <span class="nav-text">Java 并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-的实现原理以及锁优化？"><span class="nav-number">2.1.</span> <span class="nav-text">synchronized 的实现原理以及锁优化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile-的实现原理？"><span class="nav-number">2.2.</span> <span class="nav-text">volatile 的实现原理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-的信号灯？"><span class="nav-number">2.3.</span> <span class="nav-text">Java 的信号灯？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-在静态方法和普通方法的区别？"><span class="nav-number">2.4.</span> <span class="nav-text">synchronized 在静态方法和普通方法的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#怎么实现所有线程在等待某个事件的发生才会去执行？"><span class="nav-number">2.5.</span> <span class="nav-text">怎么实现所有线程在等待某个事件的发生才会去执行？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS？CAS-有什么缺陷，如何解决？"><span class="nav-number">2.6.</span> <span class="nav-text">CAS？CAS 有什么缺陷，如何解决？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-和-lock-有什么区别？"><span class="nav-number">2.7.</span> <span class="nav-text">synchronized 和 lock 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hashtable-是怎么加锁的-？"><span class="nav-number">2.8.</span> <span class="nav-text">Hashtable 是怎么加锁的 ？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-的并发问题？"><span class="nav-number">2.9.</span> <span class="nav-text">HashMap 的并发问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrenHashMap-介绍？1-8-中为什么要用红黑树？"><span class="nav-number">2.10.</span> <span class="nav-text">ConcurrenHashMap 介绍？1.8 中为什么要用红黑树？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS"><span class="nav-number">2.11.</span> <span class="nav-text">AQS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何检测死锁？怎么预防死锁？"><span class="nav-number">2.12.</span> <span class="nav-text">如何检测死锁？怎么预防死锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-内存模型？"><span class="nav-number">2.13.</span> <span class="nav-text">Java 内存模型？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何保证多线程下-i-结果正确？"><span class="nav-number">2.14.</span> <span class="nav-text">如何保证多线程下 i++ 结果正确？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池的种类，区别和使用场景？"><span class="nav-number">2.15.</span> <span class="nav-text">线程池的种类，区别和使用场景？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分析线程池的实现原理和线程的调度过程？"><span class="nav-number">2.16.</span> <span class="nav-text">分析线程池的实现原理和线程的调度过程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池如何调优，最大数目如何确认？"><span class="nav-number">2.17.</span> <span class="nav-text">线程池如何调优，最大数目如何确认？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal原理，用的时候需要注意什么？"><span class="nav-number">2.18.</span> <span class="nav-text">ThreadLocal原理，用的时候需要注意什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch-和-CyclicBarrier-的用法，以及相互之间的差别"><span class="nav-number">2.19.</span> <span class="nav-text">CountDownLatch 和 CyclicBarrier 的用法，以及相互之间的差别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LockSupport工具"><span class="nav-number">2.20.</span> <span class="nav-text">LockSupport工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition接口及其实现原理"><span class="nav-number">2.21.</span> <span class="nav-text">Condition接口及其实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fork-Join框架的理解"><span class="nav-number">2.22.</span> <span class="nav-text">Fork/Join框架的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分段锁的原理-锁力度减小的思考"><span class="nav-number">2.23.</span> <span class="nav-text">分段锁的原理,锁力度减小的思考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#八种阻塞队列以及各个阻塞队列的特性"><span class="nav-number">2.24.</span> <span class="nav-text">八种阻塞队列以及各个阻塞队列的特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">3.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#详细jvm内存模型"><span class="nav-number">3.1.</span> <span class="nav-text">详细jvm内存模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#讲讲什么情况下回出现内存溢出，内存泄漏？"><span class="nav-number">3.2.</span> <span class="nav-text">讲讲什么情况下回出现内存溢出，内存泄漏？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#说说Java线程栈"><span class="nav-number">3.3.</span> <span class="nav-text">说说Java线程栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-年轻代到年老代的晋升过程的判断条件是什么呢？"><span class="nav-number">3.4.</span> <span class="nav-text">JVM 年轻代到年老代的晋升过程的判断条件是什么呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-出现-fullGC-很频繁，怎么去线上排查问题？"><span class="nav-number">3.5.</span> <span class="nav-text">JVM 出现 fullGC 很频繁，怎么去线上排查问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？"><span class="nav-number">3.6.</span> <span class="nav-text">类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的实例化顺序"><span class="nav-number">3.7.</span> <span class="nav-text">类的实例化顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM垃圾回收机制，何时触发MinorGC等操作"><span class="nav-number">3.8.</span> <span class="nav-text">JVM垃圾回收机制，何时触发MinorGC等操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-中一次完整的-GC-流程（从-ygc-到-fgc）是怎样的"><span class="nav-number">3.9.</span> <span class="nav-text">JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#各种回收器，各自优缺点，重点CMS、G1"><span class="nav-number">3.10.</span> <span class="nav-text">各种回收器，各自优缺点，重点CMS、G1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#各种回收算法"><span class="nav-number">3.11.</span> <span class="nav-text">各种回收算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OOM错误，stackoverflow错误，permgen-space错误"><span class="nav-number">3.12.</span> <span class="nav-text">OOM错误，stackoverflow错误，permgen space错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-之-OopMap-和-RememberedSet"><span class="nav-number">3.13.</span> <span class="nav-text">JVM 之 OopMap 和 RememberedSet</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring"><span class="nav-number">4.</span> <span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanFactory-和-FactoryBean？"><span class="nav-number">4.1.</span> <span class="nav-text">BeanFactory 和 FactoryBean？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-IOC-的理解，其初始化过程？"><span class="nav-number">4.2.</span> <span class="nav-text">Spring IOC 的理解，其初始化过程？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一步-Resource定位"><span class="nav-number">4.2.1.</span> <span class="nav-text">第一步 Resource定位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二步-通过返回的resource对象，进行BeanDefinition的载入"><span class="nav-number">4.2.2.</span> <span class="nav-text">第二步 通过返回的resource对象，进行BeanDefinition的载入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第三步，将BeanDefiniton注册到容器中"><span class="nav-number">4.2.3.</span> <span class="nav-text">第三步，将BeanDefiniton注册到容器中</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanFactory-和-ApplicationContext？"><span class="nav-number">4.3.</span> <span class="nav-text">BeanFactory 和 ApplicationContext？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Bean-的生命周期，如何被管理的？"><span class="nav-number">4.4.</span> <span class="nav-text">Spring Bean 的生命周期，如何被管理的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Bean-的加载过程是怎样的？"><span class="nav-number">4.5.</span> <span class="nav-text">Spring Bean 的加载过程是怎样的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果要你实现Spring-AOP，请问怎么实现？"><span class="nav-number">4.6.</span> <span class="nav-text">如果要你实现Spring AOP，请问怎么实现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果要你实现Spring-IOC，你会注意哪些问题？"><span class="nav-number">4.7.</span> <span class="nav-text">如果要你实现Spring IOC，你会注意哪些问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-是如何管理事务的，事务管理机制？"><span class="nav-number">4.8.</span> <span class="nav-text">Spring 是如何管理事务的，事务管理机制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-的不同事务传播行为有哪些，干什么用的？"><span class="nav-number">4.9.</span> <span class="nav-text">Spring 的不同事务传播行为有哪些，干什么用的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring中事务的隔离级别"><span class="nav-number">4.10.</span> <span class="nav-text">Spring中事务的隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-中用到了那些设计模式？"><span class="nav-number">4.11.</span> <span class="nav-text">Spring 中用到了那些设计模式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-MVC-的工作原理？"><span class="nav-number">4.12.</span> <span class="nav-text">Spring MVC 的工作原理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-循环注入的原理？"><span class="nav-number">4.13.</span> <span class="nav-text">Spring 循环注入的原理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-AOP的理解，各个术语，他们是怎么相互工作的？"><span class="nav-number">4.14.</span> <span class="nav-text">Spring AOP的理解，各个术语，他们是怎么相互工作的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-如何保证-Controller-并发的安全？"><span class="nav-number">4.15.</span> <span class="nav-text">Spring 如何保证 Controller 并发的安全？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Netty"><span class="nav-number">5.</span> <span class="nav-text">Netty</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO、NIO和AIO"><span class="nav-number">5.1.</span> <span class="nav-text">BIO、NIO和AIO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Netty-的各大组件"><span class="nav-number">5.2.</span> <span class="nav-text">Netty 的各大组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Netty的线程模型"><span class="nav-number">5.3.</span> <span class="nav-text">Netty的线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-粘包-拆包的原因及解决方法"><span class="nav-number">5.4.</span> <span class="nav-text">TCP 粘包/拆包的原因及解决方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#了解哪几种序列化协议？包括使用场景和如何去选择"><span class="nav-number">5.5.</span> <span class="nav-text">了解哪几种序列化协议？包括使用场景和如何去选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Netty的零拷贝实现"><span class="nav-number">5.6.</span> <span class="nav-text">Netty的零拷贝实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Netty的高性能表现在哪些方面"><span class="nav-number">5.7.</span> <span class="nav-text">Netty的高性能表现在哪些方面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式相关"><span class="nav-number">6.</span> <span class="nav-text">分布式相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Zookeeper的用途，选举的原理是什么？"><span class="nav-number">6.1.</span> <span class="nav-text">Zookeeper的用途，选举的原理是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zookeeper原理和适用场景"><span class="nav-number">6.2.</span> <span class="nav-text">zookeeper原理和适用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zookeeper-watch机制"><span class="nav-number">6.3.</span> <span class="nav-text">zookeeper watch机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zookeeper的选举策略"><span class="nav-number">6.4.</span> <span class="nav-text">zookeeper的选举策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-zk节点宕机如何处理"><span class="nav-number">6.5.</span> <span class="nav-text">redis/zk节点宕机如何处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何做一个分布式锁"><span class="nav-number">6.6.</span> <span class="nav-text">如何做一个分布式锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dubbo的底层实现原理和机制"><span class="nav-number">6.7.</span> <span class="nav-text">Dubbo的底层实现原理和机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dubbo的服务请求失败怎么处理"><span class="nav-number">6.8.</span> <span class="nav-text">Dubbo的服务请求失败怎么处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#描述一个服务从发布到被消费的详细过程"><span class="nav-number">6.9.</span> <span class="nav-text">描述一个服务从发布到被消费的详细过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式系统怎么做服务治理"><span class="nav-number">6.10.</span> <span class="nav-text">分布式系统怎么做服务治理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口的幂等性的概念"><span class="nav-number">6.11.</span> <span class="nav-text">接口的幂等性的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重连机制会不会造成错误"><span class="nav-number">6.12.</span> <span class="nav-text">重连机制会不会造成错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何实现负载均衡，有哪些算法可以实现？"><span class="nav-number">6.13.</span> <span class="nav-text">如何实现负载均衡，有哪些算法可以实现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗"><span class="nav-number">6.14.</span> <span class="nav-text">用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息中间件如何解决消息丢失问题"><span class="nav-number">6.15.</span> <span class="nav-text">消息中间件如何解决消息丢失问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MQ系统的数据如何保证不丢失"><span class="nav-number">6.16.</span> <span class="nav-text">MQ系统的数据如何保证不丢失</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据的垂直拆分水平拆分。"><span class="nav-number">6.17.</span> <span class="nav-text">数据的垂直拆分水平拆分。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询的问题"><span class="nav-number">6.18.</span> <span class="nav-text">列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对分布式事务的理解"><span class="nav-number">6.19.</span> <span class="nav-text">对分布式事务的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式集群下如何做到唯一序列号"><span class="nav-number">6.20.</span> <span class="nav-text">分布式集群下如何做到唯一序列号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全局ID"><span class="nav-number">6.21.</span> <span class="nav-text">全局ID</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库"><span class="nav-number">7.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql分页有什么优化"><span class="nav-number">7.1.</span> <span class="nav-text">mysql分页有什么优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两阶段锁协议"><span class="nav-number">7.2.</span> <span class="nav-text">两阶段锁协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#悲观锁、乐观锁"><span class="nav-number">7.3.</span> <span class="nav-text">悲观锁、乐观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组合索引，最左原则"><span class="nav-number">7.4.</span> <span class="nav-text">组合索引，最左原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql-的表锁、行锁"><span class="nav-number">7.5.</span> <span class="nav-text">mysql 的表锁、行锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql-性能优化"><span class="nav-number">7.6.</span> <span class="nav-text">mysql 性能优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql的索引分类：B-，hash；什么情况用什么索引"><span class="nav-number">7.7.</span> <span class="nav-text">mysql的索引分类：B+，hash；什么情况用什么索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事务的特性和隔离级别"><span class="nav-number">7.8.</span> <span class="nav-text">事务的特性和隔离级别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis"><span class="nav-number">8.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis用过哪些数据数据，以及Redis底层怎么实现"><span class="nav-number">8.1.</span> <span class="nav-text">Redis用过哪些数据数据，以及Redis底层怎么实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis缓存穿透，缓存雪崩"><span class="nav-number">8.2.</span> <span class="nav-text">Redis缓存穿透，缓存雪崩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何使用Redis来实现分布式锁"><span class="nav-number">8.3.</span> <span class="nav-text">如何使用Redis来实现分布式锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis的并发竞争问题如何解决"><span class="nav-number">8.4.</span> <span class="nav-text">Redis的并发竞争问题如何解决</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis持久化的几种方式，优缺点是什么，怎么实现的"><span class="nav-number">8.5.</span> <span class="nav-text">Redis持久化的几种方式，优缺点是什么，怎么实现的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis的缓存过期策略"><span class="nav-number">8.6.</span> <span class="nav-text">Redis的缓存过期策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis集群，高可用，原理"><span class="nav-number">8.7.</span> <span class="nav-text">Redis集群，高可用，原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis缓存分片"><span class="nav-number">8.8.</span> <span class="nav-text">Redis缓存分片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis的数据淘汰策略"><span class="nav-number">8.9.</span> <span class="nav-text">Redis的数据淘汰策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis的过期策略如何实现"><span class="nav-number">8.10.</span> <span class="nav-text">redis的过期策略如何实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存"><span class="nav-number">9.</span> <span class="nav-text">缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何保证缓存与数据库的双写一致性"><span class="nav-number">9.1.</span> <span class="nav-text">如何保证缓存与数据库的双写一致性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka"><span class="nav-number">10.</span> <span class="nav-text">Kafka</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么Kafka不支持读写分离"><span class="nav-number">10.1.</span> <span class="nav-text">为什么Kafka不支持读写分离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息传递模型"><span class="nav-number">10.2.</span> <span class="nav-text">消息传递模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Push-vs-Pull"><span class="nav-number">10.3.</span> <span class="nav-text">Push vs. Pull</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息持久化"><span class="nav-number">10.4.</span> <span class="nav-text">消息持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息投递可靠性"><span class="nav-number">10.5.</span> <span class="nav-text">消息投递可靠性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka服务器能接收到的最大信息是多少"><span class="nav-number">10.6.</span> <span class="nav-text">Kafka服务器能接收到的最大信息是多少</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解释Kafka的Zookeeper是什么-我们可以在没有Zookeeper的情况下使用Kafka吗"><span class="nav-number">10.7.</span> <span class="nav-text">解释Kafka的Zookeeper是什么?我们可以在没有Zookeeper的情况下使用Kafka吗?</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Anti Zhou</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Mist</a> v6.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.1.0"></script>



  

  
    <script id="dsq-count-scr" src="https://zj23qq.disqus.com/count.js" async></script>
  

  
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'http://www.antizhou.com/面试/';
        this.page.identifier = '面试/';
        this.page.title = '面试';
      };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://zj23qq.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        loadComments();
      
    </script>
  





	





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
  

  

  

  

  

</body>
</html>
