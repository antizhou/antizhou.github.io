<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>joyo&#39;s world</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.iforfee.com/"/>
  <updated>2018-04-27T08:44:09.000Z</updated>
  <id>http://www.iforfee.com/</id>
  
  <author>
    <name>joyo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>类加载机制</title>
    <link href="http://www.iforfee.com/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.iforfee.com/java/jvm/类加载机制/</id>
    <published>2018-04-27T08:21:32.000Z</published>
    <updated>2018-04-27T08:44:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要关注点：</p><ul><li>什么是类的加载</li><li>类的生命周期</li><li>类加载器</li><li>双亲委派模型</li></ul><h1 id="什么是类的加载"><a href="#什么是类的加载" class="headerlink" title="什么是类的加载"></a>什么是类的加载</h1><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p><h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>类的生命周期包括这几个部分，加载、连接、初始化、使用和卸载，其中前三部是类的加载的过程,如下图；</p><p><img src="/images/java/jvm/class.png" alt="img"></p><ul><li>加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象</li><li>连接，连接又包含三块内容：验证、准备、初始化。1）验证，文件格式、元数据、字节码、符号引用验证；2）准备，为类的静态变量分配内存，并将其初始化为默认值；3）解析，把类中的符号引用转换为直接引用</li><li>初始化，为类的静态变量赋予正确的初始值</li><li>使用，new出对象程序中使用</li><li>卸载，执行垃圾回收</li></ul><p>其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备、初始化和卸载这5个阶段发生的顺序是确定的，<strong>而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持 Java 语言的运行时绑定（也成为动态绑定或晚期绑定）。</strong>另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（比如从jar包和war包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP文件转换成对应的Class类）。</p><ol><li>通过一个类的全限定名获取描述此类的二进制字节流；</li><li>将这个字节流所代表的静态存储结构保存为方法区的运行时数据结构；</li><li>在内存（并不一定是java堆，可能在方法区，取决于vm的实现）中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>这一阶段的主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><ol><li>文件格式</li><li>元数据</li><li>字节码</li><li>符号引用验证</li></ol><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> v = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure><p>实际上变量v在准备阶段过后的初始值为0而不是8080，将v赋值为8080的putstatic指令是程序被编译后，存放于类构造器<clinit>方法之中，这里我们后面会解释。<br>但是注意如果声明为：</clinit></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> v = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure><p>在编译阶段会为v生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将v赋值为8080。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是class文件中的：</p><ul><li>CONSTANT_Class_info</li><li>CONSTANT_Field_info</li><li>CONSTANT_Method_info</li></ul><p>等类型的常量。</p><p>下面我们解释一下符号引用和直接引用的概念：</p><ul><li>符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</li><li>直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>何时开始初始化：</p><p><strong>Java并没有规定什么时候开始第一个阶段：加载，但是Java虚拟机规范规定有且只有5种情况必须立即对类进行初始化（而加载、验证、准备自然需要在此之前开始）</strong><br>1）遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。<br>2）使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。<br>3）当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类初始化。<br>4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的），虚拟机会优先初始化这个主类。<br>5）当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic等时， 这个方法的类还没有进行过初始化，则需要先触发其初始化。</p><p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由JVM主导。到了初始阶段，才开始真正执行类中定义的Java程序代码。</p><p>初始化阶段是执行类构造器<clinit>方法的过程。<clinit>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。<clinit>方法不需要显式调用父类的构造器，虚拟机会保证<clinit>方法执行之前，父类的<clinit>方法已经执行完毕。p.s: 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<clinit>()方法。</clinit></clinit></clinit></clinit></clinit></clinit></p><p>最后看一下接口的初始化过程与类初始化过程的不同。</p><p> 接口也有初始化过程，上面的代码中我们都是用静态语句块来输出初始化信息的，而在接口中不能使用“static{}”语句块，但编译器仍然会为接口生成<clinit>类构造器，用于初始化接口中定义的成员变量（实际上是static final修饰的全局常量）。</clinit></p><p>二者在初始化时最主要的区别是：当一个类在初始化时，要求其父类全部已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量），才会初始化该父接口。这点也与类初始化的情况很不同，调用类中的static final常量时并不会 触发该类的初始化，但是调用接口中的static final常量时便会触发该接口的初始化。</p><p>注意以下几种情况不会执行类初始化：</p><ul><li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</li><li>定义对象数组，不会触发该类的初始化。</li><li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。</li><li>通过类名获取Class对象，不会触发类的初始化。</li><li>通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。</li><li>通过ClassLoader默认的loadClass方法，也不会触发初始化动作。</li></ul><blockquote><p><em>几个小问题？</em><br><em>1、JVM初始化步骤 ？ 2、类初始化时机 ？3、哪几种情况下，Java虚拟机将结束生命周期？</em><br><em>答案参考这篇文章</em><a href="http://www.importnew.com/?p=23742" target="_blank" rel="noopener">JVM（1）：Java 类的加载机制</a></p></blockquote><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p><img src="/images/java/jvm/calssloader.png" alt="img"></p><ul><li>启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库</li><li>扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</li><li>应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器</li></ul><p>类加载机制</p><ul><li>全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li>父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li><li>缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li></ul><p>好处：</p><p>解决基础类的统一问题。比如位于rt.jar包中的类java.lang.Object，无论哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，确保了Object类在各种加载器环境中都是同一个类。</p><p>双亲委托模型打破：</p><ol><li><a href="https://blog.csdn.net/yangcheng33/article/details/52631940" target="_blank" rel="noopener">线程上下文类加载器（Thread Context Classloader）</a></li><li>OSGI</li></ol><p><a href="https://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">https://blog.csdn.net/briblue/article/details/54973413</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要关注点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是类的加载&lt;/li&gt;
&lt;li&gt;类的生命周期&lt;/li&gt;
&lt;li&gt;类加载器&lt;/li&gt;
&lt;li&gt;双亲委派模型&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;什么是类的加载&quot;&gt;&lt;a href=&quot;#什么是类的加载&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="java" scheme="http://www.iforfee.com/categories/java/"/>
    
    
      <category term="jvm" scheme="http://www.iforfee.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvm梳理</title>
    <link href="http://www.iforfee.com/java/jvm/jvm%E6%A2%B3%E7%90%86/"/>
    <id>http://www.iforfee.com/java/jvm/jvm梳理/</id>
    <published>2018-04-27T06:57:36.000Z</published>
    <updated>2018-04-27T08:25:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在江湖中要练就绝世武功必须内外兼备，精妙的招式和深厚的内功，武功的基础是内功。对于武功低（就像江南七怪）的人，招式更重要，因为他们不能靠内功直接去伤人，只能靠招式，利刃上优势来取胜了，但是练到高手之后，内功就更主要了。一个内功低的人招式在奇妙也打不过一个内功高的人。比如，你剑法再厉害，一剑刺过来，别人一掌打断你的剑，你还怎么使剑法，你一掌打到一个武功高的人身上，那人没什么事，却把你震伤了，你还怎么打。同样两者也是相辅相成的，内功深厚之后，原来普通的一招一式威力也会倍增。</p><p>对于搞开发的我们其实也是一样，现在流行的框架越来越多，封装的也越来越完善，各种框架可以搞定一切，几乎不用关注底层的实现，初级程序员只要熟悉基本的使用方法，便可以快速的开发上线；但对于高级程序员来讲，内功的修炼却越发的重要，比如算法、<a href="http://www.amazon.cn/gp/product/B001130JN8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=importnew-23&amp;linkCode=as2&amp;camp=536&amp;creative=3200&amp;creativeASIN=B001130JN8" target="_blank" rel="noopener">设计模式</a>、底层原理等，只有把这些基础熟练之后，才能在开发过程中知其然知其所以然，出现问题时能快速定位到问题的本质。</p><p>对于Java程序员来讲，spring全家桶几乎可以搞定一切，spring全家桶便是精妙的招式，jvm就是内功心法很重要的一块，线上出现性能问题，jvm调优更是不可回避的问题。因此JVM基础知识对于高级程序员的重要性不必言语，我司在面试高级开发的时候，jvm相关知识也必定是考核的标准之一。本篇文章会根据之前写的jvm系列文章梳理出jvm需要关注的所有考察点。</p><h2 id="jvm-总体梳理"><a href="#jvm-总体梳理" class="headerlink" title="jvm 总体梳理"></a>jvm 总体梳理</h2><p>jvm体系总体分四大块：</p><ul><li>类的加载机制</li><li>jvm内存结构</li><li>GC算法 垃圾回收</li><li>GC分析 命令调优</li></ul><p><em>当然这些知识点在之前的文章中都有详细的介绍，这里只做主干的梳理</em></p><p>这里画了一个思维导图，将所有的知识点进行了陈列，因为图比较大可以点击右键下载了放大查看。</p><p><img src="/images/java/jvm/JVM.jpg" alt="img"></p><h2 id="类的加载机制"><a href="#类的加载机制" class="headerlink" title="类的加载机制"></a>类的加载机制</h2><p>主要关注点：</p><ul><li>什么是类的加载</li><li>类的生命周期</li><li>类加载器</li><li>双亲委派模型</li></ul><p><a href="/java/jvm/类加载机制">类加载机制</a></p><h2 id="jvm内存结构"><a href="#jvm内存结构" class="headerlink" title="jvm内存结构"></a>jvm内存结构</h2><p>主要关注点：</p><ul><li>jvm内存结构都是什么</li><li>对象分配规则</li></ul><p>jvm内存结构</p><p><a href="/java/jvm内存模型">jvm内存模型</a></p><p>对象分配规则</p><p><a href="/java/jvm内存模型">对象分配规则</a></p><blockquote><p><em>如何通过参数来控制个各个内存区域</em><br><em>参考此文章：</em><a href="http://www.importnew.com/?p=23746" target="_blank" rel="noopener">JVM（2）：JVM内存结构</a></p></blockquote><h2 id="GC算法-垃圾回收"><a href="#GC算法-垃圾回收" class="headerlink" title="GC算法 垃圾回收"></a>GC算法 垃圾回收</h2><p>主要关注点：</p><ul><li>对象存活判断</li><li>GC算法</li><li>垃圾回收器</li></ul><p><a href="/java/jvm/GC/">GC</a></p><blockquote><p><em>GC算法和垃圾回收器算法图解以及更详细内容参考</em><a href="http://www.importnew.com/?p=23752" target="_blank" rel="noopener">JVM（3）：Java GC算法 垃圾收集器</a></p></blockquote><h2 id="GC分析-命令调优"><a href="#GC分析-命令调优" class="headerlink" title="GC分析 命令调优"></a>GC分析 命令调优</h2><p>主要关注点：</p><ul><li>GC日志分析</li><li>调优命令</li><li>调优工具</li></ul><p>GC日志分析</p><p>摘录GC日志一部分（前部分为年轻代gc回收；后部分为full gc回收）：</p><p>通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数</p><p>young gc 日志:</p><p><img src="/images/java/jvm/yong.jpg" alt="img"></p><p>Full GC日志:</p><p><img src="/images/java/jvm/full.jpg" alt="img"></p><p>调优命令</p><p>Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo</p><ul><li>jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</li><li>jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</li><li>jmap，JVM Memory Map命令用于生成heap dump文件</li><li>jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看</li><li>jstack，用于生成java虚拟机当前时刻的线程快照。</li><li>jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。</li></ul><blockquote><p><em>详细的命令使用参考这里</em><a href="http://www.importnew.com/?p=23761" target="_blank" rel="noopener">JVM（4）：Jvm调优-命令篇</a></p></blockquote><p>调优工具</p><p>常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。</p><ul><li>jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控</li><li>jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。</li><li>MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗</li><li>GChisto，一款专业分析gc日志的工具</li></ul><blockquote><p><em>工具使用参考</em><a href="http://www.importnew.com/?p=23786" target="_blank" rel="noopener">JVM（7）：JVM调优-工具篇</a></p></blockquote><h3 id="本系列："><a href="#本系列：" class="headerlink" title="本系列："></a>本系列：</h3><ul><li><a href="http://www.importnew.com/?p=23742" target="_blank" rel="noopener">JVM（1）：Java 类的加载机制</a></li><li><a href="http://www.importnew.com/?p=23746" target="_blank" rel="noopener">JVM（2）：JVM内存结构</a></li><li><a href="http://www.importnew.com/?p=23752" target="_blank" rel="noopener">JVM（3）：Java GC算法 垃圾收集器</a></li><li><a href="http://www.importnew.com/?p=23761" target="_blank" rel="noopener">JVM（4）：Jvm调优-命令篇</a></li><li><a href="http://www.importnew.com/?p=23774" target="_blank" rel="noopener">JVM（5）：tomcat性能调优和性能监控（visualvm）</a></li><li><a href="http://www.importnew.com/?p=23780" target="_blank" rel="noopener">JVM（6）：JVM调优-从eclipse开始</a></li><li><a href="http://www.importnew.com/?p=23786" target="_blank" rel="noopener">JVM（7）：JVM调优-工具篇</a></li><li><a href="http://www.importnew.com/?p=23792" target="_blank" rel="noopener">JVM（8）：JVM知识点总览-高级Java工程师面试必备</a></li><li><a href="http://www.importnew.com/25295.html" target="_blank" rel="noopener">http://www.importnew.com/25295.html</a></li><li><a href="https://www.ziwenxie.site/2017/06/07/java-jvm-classloader/" target="_blank" rel="noopener">https://www.ziwenxie.site/2017/06/07/java-jvm-classloader/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在江湖中要练就绝世武功必须内外兼备，精妙的招式和深厚的内功，武功的基础是内功。对于武功低（就像江南七怪）的人，招式更重要，因为他们不能靠内功直接去伤人，只能靠招式，利刃上优势来取胜了，但是练到高手之后，内功就更主要了。一个内功低的人招式在奇妙也打不过一个内功高的人。比如，你
      
    
    </summary>
    
      <category term="java" scheme="http://www.iforfee.com/categories/java/"/>
    
    
      <category term="jvm" scheme="http://www.iforfee.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>关于幽默</title>
    <link href="http://www.iforfee.com/%E5%B9%BD%E9%BB%98/"/>
    <id>http://www.iforfee.com/幽默/</id>
    <published>2018-04-27T06:23:13.000Z</published>
    <updated>2018-04-27T06:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>男生怎么让自己变得幽默风趣</p><p>要练口才,内功第一</p><p>很多人觉得,风趣幽默就好像一种技能一样,能够速成。其实没那么简单的,就像所有武功一样,要练招式,必须内功先行。对于口才而言,所谓的内功,就是内涵,就是阅读量,就是多读书。</p><p>要活用段子</p><p>在这里举个例子吧:男:Hi,我想借一下纸巾。女:给你。男:谢谢,你电话多少,我改天还你。女:不用了。接下来要怎么破呢?你是不是就放弃了?千万不要啊。你可以这样接话:早知道问你借钱了。总之,想变得幽默,就不能按照套路出牌啊!</p><p>零门槛幽默大法,自黑无底线</p><p>有一句话说得好,黑到深处自然粉,被黑到深处自然红。懂自黑、自嘲的人,更自信、更大度,表现出来更懂得分寸和尊重别人,简直就是活生生的段子手啊!自己有什么缺点,比如矮,比如黑,比如学历低,比如挣得少,比如不聪明……。不要等别人拿你开涮,自己先拿自己开涮,这样其他人也就无话可说了!</p><p>熟悉各种网络梗,很有必要</p><p>如果说80后是互联网移民,现在的90后、00后妹子,就是互联网的原住民,她们天然地熟悉各种网络梗、各种网络段子。比如”不管你信不信,反正我信了”,”100块钱都不给我”,”我只想做一个安静的美男子”等句子,一定要在生活中活学活用,会很容易拉进与妹子的距离的!</p><p>善于运用逆向思维</p><p>比如和妹子在一起,迎面走来一只小狗,妹子想必会抱住它亲切交流,这时候,你上去亲切地叫一声”喵”,妹子会是什么反应呢?一定会觉得你这个人挺有意思的,很有生活情趣。</p><p>男生必学的5种幽默方式</p><p>曲解式幽默</p><p>什么叫曲解?就是把意思理解歪了。尤其是在恋爱中。举个例子:男:你吃饭了吗?女:干嘛?男:不干!</p><p>上面的例子大家看出来了吗?歪曲女孩的话的意思。这里不仅在在和女孩聊天,朋友,公共场合都可以使用的。看了这条回复,都会认为你是个很幽默的人,并不是色。</p><p>夸大式幽默</p><p>什么叫夸大?就是一件平常的事扩大化。尤其是对方在做某一件事的时候。例:女:你蹲在那里干嘛呢?男:我在测试地球的吸引力有多大。</p><p>这样的一件平常的事,蹲在那里还能干嘛?找东西,厕所,这都是平常的事说的跟专家似的,听起来是不是让人笑呢?可以去和女孩子试试哦。</p><p>缩小式幽默</p><p>既然有扩大,那么必有缩小。可以让大事化小小事化了的幽默。例子:女:你今天彻底把我惹毛了,我以后再也不理你了。男:我哪有惹毛你了。你的头发我都没碰一下!女:滚!男:好呀,晚上我滚床单给你暖床。</p><p>女生很怒火了,可是在你简简单单的两句话中,就直接转移话题,大事化小,最后直接说成你们两个人别的事了。是不是很强大呢?可以去试试。效果威力绝对大!</p><p>目的式曲解</p><p>目的是,把别人说话的目的直接曲解,引起对方的好奇与笑点。例:女:我现在只想把你送到外星球上!男:这样做是不是太花钱了呀?</p><p>目的式曲解,一种是迎着对方的目的去说,一种是嘲讽对方。大家谨慎使用。</p><p>日常式幽默</p><p>这种幽默用的太多了。我们平常是不是用过呢?举例:女:谢谢你。男:不用谢,请叫我雷锋。女:你看我是不是很漂亮呢?男:仔细看很漂亮。不过得仔细看!(内涵式幽默)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;男生怎么让自己变得幽默风趣&lt;/p&gt;
&lt;p&gt;要练口才,内功第一&lt;/p&gt;
&lt;p&gt;很多人觉得,风趣幽默就好像一种技能一样,能够速成。其实没那么简单的,就像所有武功一样,要练招式,必须内功先行。对于口才而言,所谓的内功,就是内涵,就是阅读量,就是多读书。&lt;/p&gt;
&lt;p&gt;要活用段子&lt;
      
    
    </summary>
    
      <category term="聊天" scheme="http://www.iforfee.com/categories/%E8%81%8A%E5%A4%A9/"/>
    
    
      <category term="幽默" scheme="http://www.iforfee.com/tags/%E5%B9%BD%E9%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>拒绝输出是荒废一个人最好的办法</title>
    <link href="http://www.iforfee.com/%E8%81%8A%E5%A4%A9/%E6%8B%92%E7%BB%9D%E8%BE%93%E5%87%BA%E6%98%AF%E8%8D%92%E5%BA%9F%E4%B8%80%E4%B8%AA%E4%BA%BA%E6%9C%80%E5%A5%BD%E7%9A%84%E5%8A%9E%E6%B3%95/"/>
    <id>http://www.iforfee.com/聊天/拒绝输出是荒废一个人最好的办法/</id>
    <published>2018-04-27T06:17:06.000Z</published>
    <updated>2018-04-27T06:21:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>你是这样的人么？</p><p>沉溺于「轻易获得高成就感」的事情，比如打游戏比如等朋友圈的点赞。</p><p>只接收「低信息密度」的信息源。比如不看书，就爱看新闻和八卦。</p><p>习惯用「错位成就感」麻痹自己。比如把自己擅长的和别人不擅长的比，甚至总爱和别人比，没有内部计分卡，不关心自我成长。</p><p><img src="http://m.gmw.cn/thumb/d/data/attachement/jpg/site2/20180316/2108794795406965349.jpg" alt="拒绝输出是荒废一个人最好的办法"></p><p>我们每个人的生活，基本上都是信息的投入产出组成的，你看视频，刷新闻，读公众号，都是一种输入，当你开始输出的时候，你的投入才会通过大脑的思考和逻辑，内化成对你而言有价值的东西。</p><p>因此，不论是打游戏成瘾，还是看电视剧看到疯魔，在我眼里，都是一种失控的输入，是一种零输出，是一种对生活完全的透支。</p><p>最可怕的地方在于，输出的能力是需要培养和训练的。就好比我们高中的时候，练作文，你光看范文半点用没有，必须自己动笔写才会有提高。</p><p>一个人如果很长时间不输出自己的知识，自然就没有兴趣去做这件事，继而更加不会锻炼到这种能力，这样的恶性循环，就会导致被吸收的知识不断被遗忘，知识变成废料。</p><p>而这，也是生活中大多数人每天在做的事。想想你上次看的公众号内容，你还记得多少呢？</p><p>但是碎片化的内容也是能够让你保持成长的，只要你这么做↓</p><p><img src="http://m.gmw.cn/thumb/d/data/attachement/jpg/site2/20180316/821851032469483690.jpg" alt="拒绝输出是荒废一个人最好的办法"></p><p>1、先花一点时间，建立自己的知识体系。</p><p>把你已经知道的东西梳理一遍。如何梳理呢？以你能够说出某个知识点的影响因素，以及它对其他事物的影响为准。顺着这样的知识点捋一遍，这个网络就是你已经构建完成的知识网络。</p><p>2、找到知识网络的触点。</p><p>亦即自己感兴趣的、但尚未进行探索和了解的知识点。</p><p>阅读、学习的时候，有意识地去接触这些触点的知识，延展自己的知识网络。</p><p>3、当接触到一个新的知识点时，先考虑如何将其纳入知识体系。</p><p>亦即在脑子里回想你的知识网络，思考它可以如何跟你已经知道的东西联系起来。</p><p>4、如果找到了对应的点，弄通路径。</p><p>亦即，将这个新的知识点，跟已经知道的某个点之间的路径，查清楚、弄清楚，将它们连接起来，使这个知识点成为你新的“触点”，拓展你的思维网络。</p><p>5、检验并输出。</p><p>将这两个点之间的联系讲清楚。最简单的办法，就是通过口述、写文章，去教会别人这个知识。或者，在心里把它讲一遍，看是否能够讲得清晰易懂，没有障碍。只有能够输出的东西，才是真正属于你的东西。</p><p>6、不符合以上方式的内容，果断舍弃。</p><p>如果一个东西无法纳入你的认知体系，那说明你现在还不能掌握它，那就果断放弃，因为它对你来说是没有价值的，或者说（记忆的）成本是远高于收益的。</p><p><img src="http://m.gmw.cn/thumb/d/data/attachement/jpg/site2/20180316/9035705576979975622.jpg" alt="拒绝输出是荒废一个人最好的办法"></p><p>再多谈几点：</p><p>1、读书不用追求“读完一本书”，而应该追求“从这本书中获得了什么东西”。</p><p>一本书的内容不可能100%对你有用，其中肯定有你所不感兴趣的东西，也有你所无法接受的东西，没关系，接受你所能接受的即可。不用务求全部读完。甚至，读一半，放回去，再跳着读别的书，也是很好的方式。读书应该为自己所用，而不是让自己去迁就它。</p><p>2、如何处理微博上、知乎上那些有趣的碎片化知识？</p><p>个人建议，最好的方式，是将它们作为起点。如果你觉得一个知识很有趣，就以它为出发点，去探索它背后的原理、背景、应用，去查资料、GOOGLE，顺藤摸瓜。这个知识点本身是没有太大价值的，有价值的是你去探索的过程。你经过探索了解到的东西，才能纳入你的知识体系，成为你思维的一部分。</p><p>3、以上种种都需要不菲的时间，但学习本就是一件艰难的事情，所以优秀的人永远是凤毛麟角，所谓聪明的人，无非他们把走路、等车、休息等更多的时间花在这上面罢了。再说，学习本身，岂非也是一件很有趣的事情？</p><p>版权声明：如涉及版权问题，请作者持权属证明与本网联系</p><p><a href="http://m.gmw.cn/toutiao/2018-04/26/content_120791964.htm" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你是这样的人么？&lt;/p&gt;
&lt;p&gt;沉溺于「轻易获得高成就感」的事情，比如打游戏比如等朋友圈的点赞。&lt;/p&gt;
&lt;p&gt;只接收「低信息密度」的信息源。比如不看书，就爱看新闻和八卦。&lt;/p&gt;
&lt;p&gt;习惯用「错位成就感」麻痹自己。比如把自己擅长的和别人不擅长的比，甚至总爱和别人比，没有
      
    
    </summary>
    
      <category term="阅读" scheme="http://www.iforfee.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="碎片化" scheme="http://www.iforfee.com/tags/%E7%A2%8E%E7%89%87%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>生活语录</title>
    <link href="http://www.iforfee.com/%E7%94%9F%E6%B4%BB%E8%AF%AD%E5%BD%95/"/>
    <id>http://www.iforfee.com/生活语录/</id>
    <published>2018-04-26T06:34:20.000Z</published>
    <updated>2018-04-26T06:35:17.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>关于读书，掌握重点就好，细节的东西，往往来自经验。</li><li>事务的出现是因为有使用的需要，所以掌握事务的第一关键是学会使用。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;关于读书，掌握重点就好，细节的东西，往往来自经验。&lt;/li&gt;
&lt;li&gt;事务的出现是因为有使用的需要，所以掌握事务的第一关键是学会使用。&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>G1Gc</title>
    <link href="http://www.iforfee.com/java/G1Gc/"/>
    <id>http://www.iforfee.com/java/G1Gc/</id>
    <published>2018-04-24T07:29:17.000Z</published>
    <updated>2018-04-24T07:29:17.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>G1 GC</title>
    <link href="http://www.iforfee.com/java/G1GC/"/>
    <id>http://www.iforfee.com/java/G1GC/</id>
    <published>2018-04-24T07:29:17.000Z</published>
    <updated>2018-04-24T13:38:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GarbageFirst（G1）"><a href="#GarbageFirst（G1）" class="headerlink" title="GarbageFirst（G1）"></a>GarbageFirst（G1）</h1><p><strong>G1（Garbage-First）</strong>收集器是当今收集器技术发展最前沿的成果之一，它是一款<strong>面向服务端应用</strong>的垃圾收集器，HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：</p><ul><li><strong>并行与并发</strong> G1 能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li><li><strong>分代收集</strong> 与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次GC的旧对象来获取更好的收集效果。</li><li><strong>空间整合</strong> G1从整体来看是基于<strong>“标记-整理”</strong>算法实现的收集器，从局部（两个Region之间）上来看是基于<strong>“复制”</strong>算法实现的。这意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。此特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</li><li><strong>可预测的停顿</strong> 这是G1相对CMS的一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li></ul><h2 id="内存划分Region"><a href="#内存划分Region" class="headerlink" title="内存划分Region"></a>内存划分Region</h2><p>G1算法将堆划分为若干个区域（Region），它仍然属于分代收集器。不过，这些区域的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间。老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了。</p><p><img src="/images/image-20180420173712264.png" alt="image-20180420173712264"></p><p>在G1中，还有一种特殊的区域，叫Humongous区域。 <strong>如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象</strong>。这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。</p><p>PS：在java 8中，持久代也移动到了普通的堆内存空间中，改为元空间。</p><p><strong>对象分配策略</strong></p><p>说起大对象的分配，我们不得不谈谈对象的分配策略。它分为3个阶段：</p><ol><li>TLAB(Thread Local Allocation Buffer)线程本地分配缓冲区</li><li>Eden区中分配</li><li>Humongous区分配</li></ol><p>TLAB为线程本地分配缓冲区，它的目的为了使对象尽可能快的分配出来。如果对象在一个共享的空间中分配，我们需要采用一些同步机制来管理这些空间内的空闲空间指针。在Eden空间中，每一个线程都有一个固定的分区用于分配对象，即一个TLAB。分配对象时，线程之间不再需要进行任何的同步。</p><p>对TLAB空间中无法分配的对象，JVM会尝试在Eden空间中进行分配。如果Eden空间无法容纳该对象，就只能在老年代中进行分配空间。</p><p><strong>建立可预测的时间模型</strong></p><p>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以<strong>有计划地避免在整个Java堆中进行全区域的垃圾收集</strong>。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），<strong>在后台维护一个优先列表</strong>，每次根据允许的收集时间，<strong>优先回收价值最大的Region（这也就是Garbage-First名称的来由）</strong>。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p><p><strong>避免全堆扫描——Remembered Set</strong></p><p>G1把Java堆分为多个Region，就是“化整为零”。但是Region不可能是孤立的，一个对象分配在某个Region中，可以与整个Java堆任意的对象发生引用关系。在做可达性分析确定对象是否存活的时候，需要扫描整个Java堆才能保证准确性，这显然是对GC效率的极大伤害。</p><p>为了避免全堆扫描的发生，虚拟机<strong>为G1中每个Region维护了一个与之对应的Remembered Set</strong>。虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable<strong>把相关引用信息记录到被引用对象所属的Region的Remembered Set之中</strong>。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p><p>如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：</p><ul><li><strong>初始标记（Initial Marking）</strong> 仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改<strong>TAMS（Nest Top Mark Start）</strong>的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要<strong>停顿线程</strong>，但耗时很短。</li><li><strong>并发标记（Concurrent Marking）</strong> 从GC Root 开始对堆中对象进行<strong>可达性分析</strong>，找到存活对象，此阶段耗时较长，但<strong>可与用户程序并发执行</strong>。</li><li><strong>最终标记（Final Marking）</strong> 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在<strong>线程的Remembered Set Logs</strong>里面，最终标记阶段需要<strong>把Remembered Set Logs的数据合并到Remembered Set中</strong>，这阶段需要<strong>停顿线程</strong>，但是<strong>可并行执行</strong>。</li><li><strong>筛选回收（Live Data Counting and Evacuation）</strong> 首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p><img src="/images/0bce1667.png" alt="img"></p><h2 id="GC模式"><a href="#GC模式" class="headerlink" title="GC模式"></a>GC模式</h2><h3 id="G1-Young-GC"><a href="#G1-Young-GC" class="headerlink" title="G1 Young GC"></a>G1 Young GC</h3><p>Young GC主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。在这种情况下，Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到年老代空间。Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。最终Eden空间的数据为空，GC停止工作，应用线程继续执行。</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/50877d4b41c80010b1f131de5759b689.png" target="_blank" rel="noopener"><img src="/images/50877d4b41c80010b1f131de5759b689.png" alt="3"></a></p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/a245f9decda81cbf12f69412d38f3177.png" target="_blank" rel="noopener"><img src="/images/a245f9decda81cbf12f69412d38f3177.png" alt="4"></a></p><p>这时，我们需要考虑一个问题，如果仅仅GC 新生代对象，我们如何找到所有的根对象呢？ 老年代的所有对象都是根么？那这样扫描下来会耗费大量的时间。于是，G1引进了RSet的概念。它的全称是Remembered Set，作用是跟踪指向某个heap区内的对象引用。</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/bd7d9f4a8e43312cb189863a568c4630.png" target="_blank" rel="noopener"><img src="/images/bd7d9f4a8e43312cb189863a568c4630.png" alt="5"></a></p><p>在CMS中，也有RSet的概念，在老年代中有一块区域用来记录指向新生代的引用。这是一种point-out，在进行Young GC时，扫描根时，仅仅需要扫描这一块区域，而不需要扫描整个老年代。</p><p>但在G1中，并没有使用point-out，这是由于一个分区太小，分区数量太多，如果是用point-out的话，会造成大量的扫描浪费，有些根本不需要GC的分区引用也扫描了。于是G1中使用point-in来解决。point-in的意思是哪些分区引用了当前分区中的对象。这样，仅仅将这些对象当做根来扫描就避免了无效的扫描。由于新生代有多个，那么我们需要在新生代之间记录引用吗？这是不必要的，原因在于每次GC时，所有新生代都会被扫描，所以只需要记录老年代到新生代之间的引用即可。</p><p>需要注意的是，如果引用的对象很多，赋值器需要对每个引用做处理，赋值器开销会很大，为了解决赋值器开销这个问题，在G1 中又引入了另外一个概念，卡表（Card Table）。一个Card Table将一个分区在逻辑上划分为固定大小的连续区域，每个区域称之为卡。卡通常较小，介于128到512字节之间。Card Table通常为字节数组，由Card的索引（即数组下标）来标识每个分区的空间地址。默认情况下，每个卡都未被引用。当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为”0″，即标记为脏被引用，此外RSet也将这个数组下标记录下来。一般情况下，这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。</p><p>Young GC 阶段：</p><ul><li>阶段1：根扫描<br>静态和本地对象被扫描</li><li>阶段2：更新RS<br>处理dirty card队列更新RS</li><li>阶段3：处理RS<br>检测从年轻代指向年老代的对象</li><li>阶段4：对象拷贝<br>拷贝存活的对象到survivor/old区域</li><li>阶段5：处理引用队列<br>软引用，弱引用，虚引用处理</li></ul><h3 id="G1-Mix-GC"><a href="#G1-Mix-GC" class="headerlink" title="G1 Mix GC"></a>G1 Mix GC</h3><p>Mix GC是伴随着Young GC一起发生的。</p><p>Mix GC不仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的老年代分区。</p><p>它的GC步骤分2步：</p><ol><li>全局并发标记（global concurrent marking）</li><li>拷贝存活对象（evacuation）</li></ol><p>在进行Mix GC之前，会先进行global concurrent marking（全局并发标记）。 global concurrent marking的执行过程是怎样的呢？</p><p>在G1 GC中，它主要是为Mixed GC提供标记服务的，并不是一次GC过程的一个必须环节。global concurrent marking的执行过程分为五个步骤：</p><table><thead><tr><th>Phase</th><th>Description</th></tr></thead><tbody><tr><td>(1) Initial Mark<em>(Stop the World Event)</em><br>初始标记</td><td>This is a stop the world event. With G1, it is piggybacked on a normal young GC. Mark survivor regions (root regions) which may have references to objects in old generation.<br>是STW的事件，并且依赖于young GC的发生。标记survivor regions作为root regions，因为它可能有指向老年代的引用。</td></tr><tr><td>(2) Root Region Scanning<br>root region 扫描</td><td>Scan survivor regions for references into the old generation. This happens while the application continues to run. The phase must be completed before a young GC can occur.<br>扫描survivor regions 中指向 old generation 的引用。同时，应用还在继续执行。这个阶段必须在young GC发生之前完成。</td></tr><tr><td>(3) Concurrent Marking<br>并发标记</td><td>Find live objects over the entire heap. This happens while the application is running. This phase can be interrupted by young generation garbage collections.<br>找到整个heap 中存活的对象。同时，应用程序继续执行。这个阶段可以被young GC中断。</td></tr><tr><td>(4) Remark<em>(Stop the World Event)</em><br>最终标记</td><td>Completes the marking of live object in the heap. Uses an algorithm called snapshot-at-the-beginning (SATB) which is much faster than what was used in the CMS collector.<br>使用SATB算法完成heap中活对象的标记。</td></tr><tr><td>(5) Cleanup<em>(Stop the World Event and Concurrent)</em></td><td>- Performs accounting on live objects and completely free regions. (Stop the world)<br>- Scrubs the Remembered Sets. (Stop the world)<br>- Reset the empty regions and return them to the free list. (Concurrent)<br>- 计算存活对象和完全空闲的regions。<br>- 重置remember set。 <br>- 重置空闲regions，并放入空闲列表中。</td></tr><tr><td>(<em>) Copying</em>(Stop the World Event)*</td><td>These are the stop the world pauses to evacuate or copy live objects to new unused regions. This can be done with young generation regions which are logged as <code>[GC pause (young)]</code>. Or both young and old generation regions which are logged as <code>[GC Pause (mixed)]</code>.<br>计算并拷贝存活对象到新的regions中。这个阶段可能发生在yong GC 和mixed GC 中。</td></tr></tbody></table><p><strong>三色标记算法</strong></p><p>提到并发标记，我们不得不了解并发标记的三色标记算法。它是描述追踪式回收器的一种有用的方法，利用它可以推演回收器的正确性。 首先，我们将对象分成三种类型的。</p><ul><li>黑色:根对象，或者该对象与它的子对象都被扫描</li><li>灰色:对象本身被扫描,但还没扫描完该对象中的子对象</li><li>白色:未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象</li></ul><p>当GC开始扫描对象时，按照如下图步骤进行对象的扫描：</p><p>根对象被置为黑色，子对象被置为灰色。</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/8efbc44ba3b845e6086a83377e912bb9.png" target="_blank" rel="noopener"><img src="/images/8efbc44ba3b845e6086a83377e912bb9.png" alt="6"></a></p><p>继续由灰色遍历,将已扫描了子对象的对象置为黑色。</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/f56ab01de2138dc3b4a4bb3d50f54594.png" target="_blank" rel="noopener"><img src="/images/f56ab01de2138dc3b4a4bb3d50f54594.png" alt="7"></a></p><p>遍历了所有可达的对象后，所有可达的对象都变成了黑色。不可达的对象即为白色，需要被清理。<br><a href="http://jbcdn2.b0.upaiyun.com/2016/12/c4f581fd4a8877375d54a55e4af27841.png" target="_blank" rel="noopener"><img src="/images/c4f581fd4a8877375d54a55e4af27841.png" alt="8"></a></p><p>这看起来很美好，但是如果在标记过程中，应用程序也在运行，那么对象的指针就有可能改变。这样的话，我们就会遇到一个问题：对象丢失问题</p><p>我们看下面一种情况，当垃圾收集器扫描到下面情况时：</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/5dd0686b02e1898ec1a987c2e1571548.png" target="_blank" rel="noopener"><img src="/images/5dd0686b02e1898ec1a987c2e1571548.png" alt="9"></a></p><p>这时候应用程序执行了以下操作：</p><blockquote><p>A.c=C<br>B.c=null</p></blockquote><p>这样，对象的状态图变成如下情形：</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/78ad6fbc199fca514a5336b2167bd8f7.png" target="_blank" rel="noopener"><img src="/images/78ad6fbc199fca514a5336b2167bd8f7.png" alt="10"></a></p><p>这时候垃圾收集器再标记扫描的时候就会下图成这样：</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/f4765bacd1941792df63c6296ad12e3a.png" target="_blank" rel="noopener"><img src="/images/f4765bacd1941792df63c6296ad12e3a.png" alt="11"></a></p><p>很显然，此时C是白色，被认为是垃圾需要清理掉，显然这是不合理的。那么我们如何保证应用程序在运行的时候，GC标记的对象不丢失呢？有如下2中可行的方式：</p><ol><li>在插入的时候记录对象</li><li>在删除的时候记录对象</li></ol><p>刚好这对应CMS和G1的2种不同实现方式：</p><p>在CMS采用的是增量更新（Incremental update），只要在写屏障（write barrier）里发现要有一个白对象的引用被赋值到一个黑对象 的字段里，那就把这个白对象变成灰色的。即插入的时候记录下来。</p><p>在G1中，使用的是STAB（snapshot-at-the-beginning）的方式，删除的时候记录所有的对象，它有3个步骤：</p><p>1，在开始标记的时候生成一个快照图标记存活对象</p><p>2，在并发标记的时候所有被改变的对象入队（在write barrier里把所有旧的引用所指向的对象都变成非白的）</p><p>3，可能存在游离的垃圾，将在下次被收集</p><p>这样，G1到现在可以知道哪些老的分区可回收垃圾最多。 当全局并发标记完成后，在某个时刻，就开始了Mix GC。这些垃圾回收被称作“混合式”是因为他们不仅仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的分区。混合式垃圾收集如下图：</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/0860c63775ccbc265095b5a844f0d381.png" target="_blank" rel="noopener"><img src="/images/0860c63775ccbc265095b5a844f0d381.png" alt="12"></a></p><p>混合式GC也是采用的复制的清理策略，当GC完成后，会重新释放空间。</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/599b50c478126754a1cc614a85b149bd.png" target="_blank" rel="noopener"><img src="/images/599b50c478126754a1cc614a85b149bd.png" alt="13"></a></p><p>至此，混合式GC告一段落了。下一小节我们讲进入调优实践。</p><h3 id="G1-Full-GC"><a href="#G1-Full-GC" class="headerlink" title="G1 Full GC"></a>G1 Full GC</h3><p>如果对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发一次full gc，G1的full gc算法就是单线程执行的serial old gc，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免full gc.</p><h1 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h1><h2 id="Remember-Set和Card-Table"><a href="#Remember-Set和Card-Table" class="headerlink" title="Remember Set和Card Table"></a>Remember Set和Card Table</h2><p>RS(Remember Set)是一种抽象概念，用于记录从非收集部分指向收集部分的指针的集合。<br>在传统的分代垃圾回收算法里面，RS(Remember Set)被用来记录分代之间的指针。在G1回收器里面，RS被用来记录从其他Region指向一个Region的指针情况。因此，一个Region就会有一个RS。这种记录可以带来一个极大的好处：在回收一个Region的时候不需要执行全堆扫描，只需要检查它的RS就可以找到外部引用，而这些引用就是initial mark的根之一。</p><p>那么，如果一个线程修改了Region内部的引用，就必须要去通知RS，更改其中的记录。为了达到这种目的，G1回收器引入了一种新的结构，CT(Card Table)——卡表。每一个Region，又被分成了固定大小的若干张卡(Card)。每一张卡，都用一个Byte来记录是否修改过。卡表即这些byte的集合。实际上，如果把RS理解成一个概念模型，那么CT就可以说是RS的一种实现方式。</p><blockquote><p>从第一感觉，或者出于直觉的考虑，使用一个bit来记录一张卡是否被修改过，就已经足够了。而使用一个byte会造成更多的空间开销。但是实际上，使用一个byte来记录一张卡是否被修改过，会比使用一个bit来记录效率更高。更多细节参阅资料3。</p></blockquote><p>在RS的修改上也会遇到并发的问题。因为一个Region可能有多个线程在并发修改，因此它们也会并发修改RS。为了避免这样一种冲突，G1垃圾回收器进一步把RS划分成了多个哈希表。每一个线程都在各自的哈希表里面修改。最终，从逻辑上来说，RS就是这些哈希表的集合。哈希表是实现RS的一种通常的方式之一。它有一个极大的好处就是能够去除重复。这意味着，RS的大小将和修改的指针数量相当。而在不去重的情况下，RS的数量和写操作的数量相当。</p><p>整个关系如下：</p><p><img src="/images/693.png" alt="img"></p><p>Remember Set</p><p>图中RS的虚线表名的是，RS并不是一个和Card Table独立的，不同的数据结构，而是指RS是一个概念模型。实际上，Card Table是RS的一种实现方式。</p><h3 id="Remember-Set的写屏障"><a href="#Remember-Set的写屏障" class="headerlink" title="Remember Set的写屏障"></a>Remember Set的写屏障</h3><p>写屏障是指，在改变特定内存的值（实际上也就是写入内存）的时候额外执行的一些动作。在大多数的垃圾回收算法中，都利用到了写屏障。写屏障通常用于在运行时探测并记录回收相关指针(interesting pointer)，在回收器只回收堆中部分区域的时候，任何来自该区域外的指针都需要被写屏障捕获，这些指针将会在垃圾回收的时候作为标记开始的根。JAVA使用的其余的分代的垃圾回收器，都有写屏障。举例来说，每一次将一个老年代对象的引用修改为指向年轻代对象，都会被写屏障捕获，并且记录下来。因此在年轻代回收的时候，就可以避免扫描整个老年代来查找根。</p><p>G1垃圾回收器的写屏障和RS是相辅相成的，也就是记录Region内部的指针。这种记录发生在写操作之后。对于一个写屏障来说，过滤掉不必要的写操作是十分有必要的。这种过滤既能加快赋值器的速度，也能减轻回收器的负担。G1垃圾回收器采用的双重过滤</p><ol><li>过滤掉同一个Region内部引用；</li><li>过滤掉空引用；</li></ol><p>过滤掉这两个部分之后，可以使RS的大小大大减小。</p><p>G1的垃圾回收器的写屏障使用一种两级的log buffer结构：</p><ol><li>global set of filled buffer：所有线程共享的一个全局的，存放填满了的log buffer的集合；</li><li>thread log buffer：每个线程自己的log buffer。所有的线程都会把写屏障的记录先放进去自己的log buffer中，装满了之后，就会把log buffer放到 global set of filled buffer中，而后再申请一个log buffer；</li></ol><h2 id="Collect-Set"><a href="#Collect-Set" class="headerlink" title="Collect Set"></a>Collect Set</h2><p>Collect Set(CSet)是指，在Evacuation阶段，由G1垃圾回收器选择的待回收的Region集合。G1垃圾回收器的软实时的特性就是通过CSet的选择来实现的。对应于算法的两种模式fully-young generational mode和partially-young mode，CSet的选择可以分成两种：</p><ol><li>在fully-young generational mode下：顾名思义，该模式下CSet将只包含young的Region。G1将调整young的Region的数量来匹配软实时的目标；</li><li>在partially-young mode下：该模式会选择所有的young region，并且选择一部分的old region。old region的选择将依据在Marking cycle phase中对存活对象的计数。G1选择存活对象最少的Region进行回收。</li></ol><h2 id="SATB-snapshot-at-the-beginning"><a href="#SATB-snapshot-at-the-beginning" class="headerlink" title="SATB(snapshot-at-the-beginning)"></a>SATB(snapshot-at-the-beginning)</h2><p>SATB(snapshot-at-the-beginning)，是最开始用于实时垃圾回收器的一种技术。G1垃圾回收器使用该技术在标记阶段记录一个存活对象的快照(“logically takes a snapshot of the set of live objects in the heap at the start of marking cycle”)。然而在并发标记阶段，应用可能修改了原本的引用，比如删除了一个原本的引用。这就会导致并发标记结束之后的存活对象的快照和SATB不一致。G1是通过在并发标记阶段引入一个写屏障来解决这个问题的：每当存在引用更新的情况，G1会将修改之前的值写入一个log buffer（这个记录会过滤掉原本是空引用的情况），在最终标记(final marking phase)阶段扫描SATB，修正SATB的误差。</p><p>SATB的log buffer如RS的写屏障使用的log buffer一样，都是两级结构，作用机制也是一样的。</p><blockquote><p>细节可以参阅资料2，6</p></blockquote><h2 id="Marking-bitmaps和TAMS"><a href="#Marking-bitmaps和TAMS" class="headerlink" title="Marking bitmaps和TAMS"></a>Marking bitmaps和TAMS</h2><p>Marking bitmap是一种数据结构，其中的每一个bit代表的是一个可用于分配给对象的起始地址。举例来说：</p><p><img src="/images/700.png" alt="img"></p><p>其中addrN代表的是一个对象的起始地址。绿色的块代表的是在该起始地址处的对象是存活对象，而其余白色的块则代表了垃圾对象。<br>G1使用了两个bitmap，一个叫做previous bitmap，另外一个叫做next bitmap。previous bitmap记录的是上一次的标记阶段完成之后的构造的bitmap；next bitmap则是当前正在标记阶段正在构造的bitmap。在当前标记阶段结束之后，当前标记的next bitmap就变成了下一次标记阶段的previous bitmap。<br>TAMS(top at mark start)变量，是一对用于区分在标记阶段新分配对象的变量，分别被称为previous TAMS和next TAMS。在previous TAMS和next TAMS之间的对象则是本次标记阶段时候新分配的对象。如图：</p><p><img src="/images/700-20180424103245937.png" alt="img"></p><p>白色region代表的是空闲空间，绿色region代表是存活对象，橙色region代表的在此次标记阶段新分配的对象。注意的是，在橙色区域的对象，并不能确保它们都事实上是存活的。</p><h2 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h2><p>整个算法可以分成两大部分：</p><ol><li>Marking cycle phase：标记阶段，该阶段是不断循环进行的；</li><li>Evacuation phase：该阶段是负责把一部分region的活对象拷贝到空Region里面去，然后回收原本的Region空间，该阶段是STW(stop-the-world)的；</li></ol><p>而算法也可以分成两种模式：</p><ol><li>fully-young generational mode：有时候也会被称为young GC，该模式只会回收young region，算法是通过调整young region的数量来达到软实时目标的；</li><li>partially-young mode：也被称为Mixed GC，该阶段会回收young region和old region，算法通过调整old region的数量来达到软实时目标；</li></ol><p>有趣的地方是不论处在何种模式之下，yong region都在被回收的范围内。而old region只能期望于Mixed GC。但是，如同在CMS垃圾回收器中遇到的困境一样，Mixed GC可能来不及回收old region。也就说，在需要分配老年代的对象的时候，并没有足够的空间。这个时候就只能触发一次full GC。</p><p>算法会自动在young GC和mixed GC之间切换，并且定期触发Marking cycle phase。HotSpot的G1实现允许指定一个参数InitiatingHeapOccupancyPercent，在达到该参数的情况下，就会执行marking cycle phase。</p><p>算法并不使用在对象头增加字段来标记该对象，而是采用bitmap的方式来记录一个对象被标记的情况。这种记录方法的好处就是在使用这些标记信息的时候，仅仅需要扫描bitmap而已。G1统计一个region的存活的对象，就是依赖于bitmap的标记。</p><h1 id="调优实践"><a href="#调优实践" class="headerlink" title="调优实践"></a>调优实践</h1><p>MaxGCPauseMillis调优</p><p>前面介绍过使用GC的最基本的参数：</p><blockquote><p>-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=200</p></blockquote><p>前面2个参数都好理解，后面这个MaxGCPauseMillis参数该怎么配置呢？这个参数从字面的意思上看，就是允许的GC最大的暂停时间。G1尽量确保每次GC暂停的时间都在设置的MaxGCPauseMillis范围内。 那G1是如何做到最大暂停时间的呢？这涉及到另一个概念，CSet(collection set)。它的意思是在一次垃圾收集器中被收集的区域集合。</p><ul><li>Young GC：选定所有新生代里的region。通过控制新生代的region个数来控制young GC的开销。</li><li>Mixed GC：选定所有新生代里的region，外加根据global concurrent marking统计得出收集收益高的若干老年代region。在用户指定的开销目标范围内尽可能选择收益高的老年代region。</li></ul><p>在理解了这些后，我们再设置最大暂停时间就好办了。 首先，我们能容忍的最大暂停时间是有一个限度的，我们需要在这个限度范围内设置。但是应该设置的值是多少呢？我们需要在吞吐量跟MaxGCPauseMillis之间做一个平衡。如果MaxGCPauseMillis设置的过小，那么GC就会频繁，吞吐量就会下降。如果MaxGCPauseMillis设置的过大，应用程序暂停时间就会变长。G1的默认暂停时间是200毫秒，我们可以从这里入手，调整合适的时间。</p><p><strong>其他调优参数</strong></p><p>-XX:G1HeapRegionSize=n</p><p>设置的 G1 区域的大小。值是 2 的幂，范围是 1 MB 到 32 MB 之间。目标是根据最小的 Java 堆大小划分出约 2048 个区域。</p><p>-XX:ParallelGCThreads=n</p><p>设置 STW 工作线程数的值。将 n 的值设置为逻辑处理器的数量。n 的值与逻辑处理器的数量相同，最多为 8。</p><p>如果逻辑处理器不止八个，则将 n 的值设置为逻辑处理器数的 5/8 左右。这适用于大多数情况，除非是较大的 SPARC 系统，其中 n 的值可以是逻辑处理器数的 5/16 左右。</p><p>-XX:ConcGCThreads=n</p><p>设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (ParallelGCThreads) 的 1/4 左右。</p><p>-XX:InitiatingHeapOccupancyPercent=45</p><p>设置触发标记周期的 Java 堆占用率阈值。默认占用率是整个 Java 堆的 45%。</p><p>避免使用以下参数：</p><p>避免使用 -Xmn 选项或 -XX:NewRatio 等其他相关选项显式设置年轻代大小。固定年轻代的大小会覆盖暂停时间目标。</p><p><strong>触发Full GC</strong></p><p>在某些情况下，G1触发了Full GC，这时G1会退化使用Serial收集器来完成垃圾的清理工作，它仅仅使用单线程来完成GC工作，GC暂停时间将达到秒级别的。整个应用处于假死状态，不能处理任何请求，我们的程序当然不希望看到这些。那么发生Full GC的情况有哪些呢？</p><ul><li>并发模式失败</li></ul><p>G1启动标记周期，但在Mix GC之前，老年代就被填满，这时候G1会放弃标记周期。这种情形下，需要增加堆大小，或者调整周期（例如增加线程数-XX:ConcGCThreads等）。</p><ul><li>晋升失败或者疏散失败</li></ul><p>G1在进行GC的时候没有足够的内存供存活对象或晋升对象使用，由此触发了Full GC。可以在日志中看到(to-space exhausted)或者（to-space overflow）。解决这种问题的方式是：</p><p>a,增加 -XX:G1ReservePercent 选项的值（并相应增加总的堆大小），为“目标空间”增加预留内存量。</p><p>b,通过减少 -XX:InitiatingHeapOccupancyPercent 提前启动标记周期。</p><p>c,也可以通过增加 -XX:ConcGCThreads 选项的值来增加并行标记线程的数目。</p><ul><li>巨型对象分配失败</li></ul><p>当巨型对象找不到合适的空间进行分配时，就会启动Full GC，来释放空间。这种情况下，应该避免分配大量的巨型对象，增加内存或者增大-XX:G1HeapRegionSize，使巨型对象不再是巨型对象。</p><p>由于篇幅有限，G1还有很多调优实践，在此就不一一列出了，大家在平常的实践中可以慢慢探索。最后，期待java 9能正式发布，默认使用G1为垃圾收集器的java性能会不会又提高呢？</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>The first focus of G1 is to provide a solution for users running applications that require large heaps with limited GC latency. This means heap sizes of around 6GB or larger, and stable and predictable pause time below 0.5 seconds.</p><p>Applications running today with either the CMS or the ParallelOldGC garbage collector would benefit switching to G1 if the application has one or more of the following traits.</p><ul><li>Full GC durations are too long or too frequent.</li><li>The rate of object allocation rate or promotion varies significantly.</li><li>Undesired long garbage collection or compaction pauses (longer than 0.5 to 1 second)</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>regions 划分：Eden、Survivor、Old、Humongous</li><li>young gc 和 mixed gc</li><li>remember set、card table、satb(snapshot-at-the-beginning)</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://crowhawk.github.io/2017/08/15/jvm_3/" target="_blank" rel="noopener">https://crowhawk.github.io/2017/08/15/jvm_3/</a><br><a href="http://blog.jobbole.com/109170/" target="_blank" rel="noopener">http://blog.jobbole.com/109170/</a><br><a href="https://www.jianshu.com/p/8bd15969a641" target="_blank" rel="noopener">https://www.jianshu.com/p/8bd15969a641</a><br><a href="http://www.importnew.com/27793.html" target="_blank" rel="noopener">http://www.importnew.com/27793.html</a><br><a href="https://tech.meituan.com/g1.html" target="_blank" rel="noopener">https://tech.meituan.com/g1.html</a><br><a href="http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html</a><br><a href="https://blog.csdn.net/renfufei/article/details/41897113" target="_blank" rel="noopener">https://blog.csdn.net/renfufei/article/details/41897113</a><br><a href="https://www.jianshu.com/p/870abddaba41" target="_blank" rel="noopener">https://www.jianshu.com/p/870abddaba41</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GarbageFirst（G1）&quot;&gt;&lt;a href=&quot;#GarbageFirst（G1）&quot; class=&quot;headerlink&quot; title=&quot;GarbageFirst（G1）&quot;&gt;&lt;/a&gt;GarbageFirst（G1）&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;G1（Gar
      
    
    </summary>
    
      <category term="java" scheme="http://www.iforfee.com/categories/java/"/>
    
    
      <category term="gc" scheme="http://www.iforfee.com/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机字节码执行引擎</title>
    <link href="http://www.iforfee.com/java/jvm/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>http://www.iforfee.com/java/jvm/虚拟机字节码执行引擎/</id>
    <published>2018-04-20T07:33:07.000Z</published>
    <updated>2018-04-20T07:36:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多态性实现机制——静态分派与动态分派"><a href="#多态性实现机制——静态分派与动态分派" class="headerlink" title="多态性实现机制——静态分派与动态分派"></a>多态性实现机制——静态分派与动态分派</h1><h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><p>Class 文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。这个特性给 Java 带来了更强大的动态扩展能力，使得可以在类运行期间才能确定某些目标方法的直接引用，称为动态连接，也有一部分方法的符号引用在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析。这在前面的“<a href="http://wiki.jikexueyuan.com/project/java-vm/storage.html" target="_blank" rel="noopener">Java 内存区域与内存溢出</a>”一文中有提到。</p><p>静态解析成立的前提是：方法在程序真正执行前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在编译器进行编译时就必须确定下来，这类方法的调用称为解析。</p><p>在 Java 语言中，符合“编译器可知，运行期不可变”这个要求的方法主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法都不可能通过继承或别的方式重写出其他的版本，因此它们都适合在类加载阶段进行解析。</p><p>Java 虚拟机里共提供了四条方法调用字节指令，分别是：</p><ul><li>invokestatic：调用静态方法。</li><li>invokespecial：调用实例构造器方法、私有方法和父类方法。</li><li>invokevirtual：调用所有的虚方法。</li><li>invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。</li></ul><p>只要能被 invokestatic 和 invokespecial 指令调用的方法，都可以在解析阶段确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器和父类方法四类，它们在类加载时就会把符号引用解析为该方法的直接引用。这些方法可以称为非虚方法（还包括 final 方法），与之相反，其他方法就称为虚方法（final 方法除外）。这里要特别说明下 final 方法，虽然调用 final 方法使用的是 invokevirtual 指令，但是由于它无法覆盖，没有其他版本，所以也无需对方发接收者进行多态选择。Java 语言规范中明确说明了 final 方法是一种非虚方法。</p><p>解析调用一定是个静态过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用转化为可确定的直接引用，不会延迟到运行期再去完成。而分派调用则可能是静态的也可能是动态的，根据分派依据的宗量数（<strong>方法的调用者和方法的参数统称为方法的宗量</strong>）又可分为单分派和多分派。两类分派方式两两组合便构成了静态单分派、静态多分派、动态单分派、动态多分派四种分派情况。</p><h2 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h2><p><strong>所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派</strong>，静态分派的最典型应用就是多态性中的方法重载。静态分派发生在编译阶段，因此确定静态分配的动作实际上不是由虚拟机来执行的。下面通过一段方法重载的示例程序来更清晰地说明这种分派机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;  </span><br><span class="line">&#125;    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticPai</span></span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Human hum)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"I am human"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Man hum)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"I am man"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Woman hum)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"I am woman"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Human man = <span class="keyword">new</span> Man();  </span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();  </span><br><span class="line">        StaticPai sp = <span class="keyword">new</span> StaticPai();  </span><br><span class="line">        sp.say(man);  </span><br><span class="line">        sp.say(woman);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的执行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am human</span><br><span class="line">I am human</span><br></pre></td></tr></table></figure><p>以上结果的得出应该不难分析。在分析为什么会选择参数类型为 Human 的重载方法去执行之前，先看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man（）;</span><br></pre></td></tr></table></figure><p>我们把上面代码中的“Human”称为变量的静态类型，后面的“Man”称为变量的实际类型。静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的，而实际类型变化的结果在运行期才可确定。</p><p>回到上面的代码分析中，在调用 say()方法时，方法的调用者（回忆上面关于宗量的定义，<strong>方法的调用者属于宗量</strong>）都为 sp 的前提下，使用哪个重载版本，完全取决于传入参数的数量和数据类型（<strong>方法的参数也是属于宗量</strong>）。代码中刻意定义了两个静态类型相同、实际类型不同的变量，可见编译器（不是虚拟机，因为如果是根据静态类型做出的判断，那么在编译期就确定了）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。并且静态类型是编译期可知的，所以在编译阶段，javac 编译器就根据参数的静态类型决定使用哪个重载版本。这就是静态分派最典型的应用。</p><h2 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h2><p>动态分派与多态性的另一个重要体现——方法覆写有着很紧密的关系。向上转型后调用子类覆写的方法便是一个很好地说明动态分派的例子。这种情况很常见，因此这里不再用示例程序进行分析。很显然，在判断执行父类中的方法还是子类中覆盖的方法时，如果用静态类型来判断，那么无论怎么进行向上转型，都只会调用父类中的方法，但实际情况是，根据对父类实例化的子类的不同，调用的是不同子类中覆写的方法，很明显，这里是要根据变量的实际类型来分派方法的执行版本的。而实际类型的确定需要在程序运行时才能确定下来，<strong>这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派</strong>。</p><h2 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h2><p>前面给出：方法的接受者（亦即方法的调用者）与方法的参数统称为方法的宗量。单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。</p><p>为了方便理解，下面给出一段示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eat</span></span>&#123;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drink</span></span>&#123;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Eat arg)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"爸爸在吃饭"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Drink arg)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"爸爸在喝水"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Eat arg)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"儿子在吃饭"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Drink arg)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"儿子在喝水"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDoublePai</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Father father = <span class="keyword">new</span> Father();  </span><br><span class="line">        Father child = <span class="keyword">new</span> Child();  </span><br><span class="line">        father.doSomething(<span class="keyword">new</span> Eat());  </span><br><span class="line">        child.doSomething(<span class="keyword">new</span> Drink());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果应该很容易预测到，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">爸爸在吃饭</span><br><span class="line">儿子在喝水</span><br></pre></td></tr></table></figure><p>我们首先来看编译阶段编译器的选择过程，即静态分派过程。这时候选择目标方法的依据有两点：一是方法的接受者（即调用者）的静态类型是 Father 还是 Child，二是方法参数类型是 Eat 还是 Drink。因为是根据两个宗量进行选择，所以 Java 语言的静态分派属于多分派类型。</p><p>再来看运行阶段虚拟机的选择，即动态分派过程。由于编译期已经了确定了目标方法的参数类型（编译期根据参数的静态类型进行静态分派），因此唯一可以影响到虚拟机选择的因素只有此方法的接受者的实际类型是 Father 还是 Child。因为只有一个宗量作为选择依据，所以 Java 语言的动态分派属于单分派类型。</p><p><img src="/images/child.png" alt="img"></p><p>根据以上论证，我们可以总结如下：<strong>目前的</strong>Java 语言（JDK1.6）是一门<strong>静态多分派、动态单分派</strong>的语言。</p><h2 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h2><p>其实上面的叙述已经把虚拟机重写与重载的本质讲清楚了，那么Java虚拟机是如何做到这点的呢？</p><p>由于动态分派是非常频繁的操作，实际实现中不可能真正如此实现。Java虚拟机是通过“稳定优化”的手段——在方法区中建立一个虚方法表（Virtual Method Table），通过使用方法表的索引来代替元数据查找以提高性能。虚方法表中存放着各个方法的实际入口地址（由于Java虚拟机自己建立并维护的方法表，所以没有必要使用符号引用，那不是跟自己过不去嘛），如果子类没有覆盖父类的方法，那么子类的虚方法表里面的地址入口与父类是一致的；如果重写父类的方法，那么子类的方法表的地址将会替换为子类实现版本的地址。</p><p>方法表是在类加载的连接阶段（验证、准备、解析）进行初始化，准备了子类的初始化值后，虚拟机会把该类的虚方法表也进行初始化。</p><h2 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h2><p><a href="https://my.oschina.net/itblog/blog/538748" target="_blank" rel="noopener">https://my.oschina.net/itblog/blog/538748</a></p><p><a href="https://blog.souche.com/invokedynamic/" target="_blank" rel="noopener">https://blog.souche.com/invokedynamic/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多态性实现机制——静态分派与动态分派&quot;&gt;&lt;a href=&quot;#多态性实现机制——静态分派与动态分派&quot; class=&quot;headerlink&quot; title=&quot;多态性实现机制——静态分派与动态分派&quot;&gt;&lt;/a&gt;多态性实现机制——静态分派与动态分派&lt;/h1&gt;&lt;h2 id=&quot;方
      
    
    </summary>
    
      <category term="java" scheme="http://www.iforfee.com/categories/java/"/>
    
    
      <category term="jvm" scheme="http://www.iforfee.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>SPI和DriverManager</title>
    <link href="http://www.iforfee.com/java/SPI%E5%92%8CDriverManager/"/>
    <id>http://www.iforfee.com/java/SPI和DriverManager/</id>
    <published>2018-04-19T07:16:02.000Z</published>
    <updated>2018-04-19T07:31:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">Java中SPI机制深入及源码解析</a><br><a href="https://blog.csdn.net/yangcheng33/article/details/52631940" target="_blank" rel="noopener">真正理解线程上下文类加载器（多案例分析）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/&quot; t
      
    
    </summary>
    
      <category term="java" scheme="http://www.iforfee.com/categories/java/"/>
    
    
      <category term="spi" scheme="http://www.iforfee.com/tags/spi/"/>
    
      <category term="driver manager" scheme="http://www.iforfee.com/tags/driver-manager/"/>
    
  </entry>
  
  <entry>
    <title>LockSupport</title>
    <link href="http://www.iforfee.com/java/LockSupport/"/>
    <id>http://www.iforfee.com/java/LockSupport/</id>
    <published>2018-04-17T10:15:02.000Z</published>
    <updated>2018-04-17T10:55:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LockSupport-用法简介"><a href="#LockSupport-用法简介" class="headerlink" title="LockSupport 用法简介"></a>LockSupport 用法简介</h2><p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。LockSupport 提供park()和unpark()方法实现阻塞线程和解除线程阻塞，LockSupport和每个使用它的线程都与一个许可(permit)关联。permit相当于1，0的开关，默认是0，调用一次unpark就加1变成1，调用一次park会消费permit, 也就是将1变成0，同时park立即返回。再次调用park会变成block（因为permit为0了，会阻塞在这里，直到permit变为1）, 这时调用unpark会把permit置为1。每个线程都有一个相关的permit, permit最多只有一个，重复调用unpark也不会积累。</p><p>park()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。</p><p>如果调用线程被中断，则park方法会返回。同时park也拥有可以设置超时时间的版本。</p><p>三种形式的 park 还各自支持一个 blocker 对象参数。此对象在线程受阻塞时被记录，以允许监视工具和诊断工具确定线程受阻塞的原因。（这样的工具可以使用方法 getBlocker(java.lang.Thread) 访问 blocker。）建议最好使用这些形式，而不是不带此参数的原始形式。在锁实现中提供的作为 blocker 的普通参数是 this。<br>看下线程dump的结果来理解blocker的作用。</p><p><img src="/images/java/1467374850-58aba3ef836ab_articlex.png" alt=""></p><h2 id="LockSupport-源码解读"><a href="#LockSupport-源码解读" class="headerlink" title="LockSupport 源码解读"></a>LockSupport 源码解读</h2><ol><li>LockSupport中主要的两个成员变量：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hotspot implementation via intrinsics API</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> parkBlockerOffset;</span><br></pre></td></tr></table></figure><p>再来看parkBlockerOffset:<br>parkBlocker就是第一部分说到的用于记录线程被谁阻塞的，用于线程监控和分析工具来定位原因的，可以通过LockSupport的getBlocker获取到阻塞的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; tk = Thread.class;</span><br><span class="line">        parkBlockerOffset = UNSAFE.objectFieldOffset</span><br><span class="line">            (tk.getDeclaredField(<span class="string">"parkBlocker"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个静态语句块可以看的出来，先是通过反射机制获取Thread类的parkBlocker字段对象。然后通过sun.misc.Unsafe对象的objectFieldOffset方法获取到parkBlocker在内存里的偏移量，parkBlockerOffset的值就是这么来的.</p><p>JVM的实现可以自由选择如何实现Java对象的“布局”，也就是在内存里Java对象的各个部分放在哪里，包括对象的实例字段和一些元数据之类。 sun.misc.Unsafe里关于对象字段访问的方法把对象布局抽象出来，它提供了objectFieldOffset()方法用于获取某个字段相对 Java对象的“起始地址”的偏移量，也提供了getInt、getLong、getObject之类的方法可以使用前面获取的偏移量来访问某个Java 对象的某个字段。</p><p>为什么要用偏移量来获取对象？干吗不要直接写个get，set方法。多简单？<br>仔细想想就能明白，这个parkBlocker就是在线程处于阻塞的情况下才会被赋值。线程都已经阻塞了，如果不通过这种内存的方法，而是直接调用线程内的方法，线程是不会回应调用的。</p><p>2.LockSupport的方法：</p><p><img src="/images/java/bVJu1i.png" alt="img"></p><p>可以看到，LockSupport中主要是park和unpark方法以及设置和读取parkBlocker方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBlocker</span><span class="params">(Thread t, Object arg)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Even though volatile, hotspot doesn't need a write barrier here.</span></span><br><span class="line">       UNSAFE.putObject(t, parkBlockerOffset, arg);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>对给定线程t的parkBlocker赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBlocker</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.getObjectVolatile(t, parkBlockerOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从线程t中获取它的parkBlocker对象，即返回的是阻塞线程t的Blocker对象。</p><p>接下来主查两类方法，一类是阻塞park方法，一类是解除阻塞unpark方法</p><p><strong>阻塞线程</strong></p><ul><li>park()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用native方法阻塞当前线程。</p><ul><li>parkNanos(long nanos)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(<span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>)</span><br><span class="line">            UNSAFE.park(<span class="keyword">false</span>, nanos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阻塞当前线程，最长不超过nanos纳秒，返回条件在park()的基础上增加了超时返回。</p><ul><li>parkUntil(long deadline)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(<span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">  UNSAFE.park(<span class="keyword">true</span>, deadline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阻塞当前线程，知道deadline时间（deadline - 毫秒数）。</p><p>JDK1.6引入这三个方法对应的拥有Blocker版本。</p><ul><li>park(Object blocker)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  setBlocker(t, blocker);</span><br><span class="line">  UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">  setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1) 记录当前线程等待的对象（阻塞对象）；<br>2) 阻塞当前线程；<br>3) 当前线程等待对象置为null。</p><ul><li>parkNanos(Object blocker, long nanos)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(Object blocker, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      Thread t = Thread.currentThread();</span><br><span class="line">      setBlocker(t, blocker);</span><br><span class="line">      UNSAFE.park(<span class="keyword">false</span>, nanos);</span><br><span class="line">      setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阻塞当前线程，最长等待时间不超过nanos毫秒，同样，在阻塞当前线程的时候做了记录当前线程等待的对象操作。</p><ul><li>parkUntil(Object blocker, long deadline)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(Object blocker, <span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  setBlocker(t, blocker);</span><br><span class="line">  UNSAFE.park(<span class="keyword">true</span>, deadline);</span><br><span class="line">  setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阻塞当前线程直到deadline时间，相同的，也做了阻塞前记录当前线程等待对象的操作。</p><p><strong>唤醒线程</strong></p><ul><li>unpark(Thread thread)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">      UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唤醒处于阻塞状态的线程Thread。</p><h2 id="Locksupport-底层"><a href="#Locksupport-底层" class="headerlink" title="Locksupport 底层"></a>Locksupport 底层</h2><p>在Linux系统下，是用的Posix线程库pthread中的mutex（互斥量），condition（条件变量）来实现的。<br><strong>mutex和condition保护了一个_counter的变量，当park时，这个变量被设置为0，当unpark时，这个变量被设置为1。</strong></p><p>看看Locksupport的源码中的注释可知，Locksupport是实现别的锁和同步类的基本原语。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Parker : public os::PlatformParker &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> _counter ;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">park</span><span class="params">(bool isAbsolute, jlong time)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unpark</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">class PlatformParker : public CHeapObj&lt;mtInternal&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    pthread_mutex_t _mutex [<span class="number">1</span>] ;</span><br><span class="line">    pthread_cond_t  _cond  [<span class="number">1</span>] ;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Parker类实际上用Posix的mutex，condition来实现的。<br>在Parker类里的_counter字段，就是用来记录“许可”的。</p><ul><li><strong>park 过程</strong></li></ul><p>当调用park时，先尝试能否直接拿到“许可”，即_counter&gt;0时，如果成功，则把_counter设置为0，并返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Parker::park(bool isAbsolute, jlong time) &#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Ideally we'd do something useful while spinning, such  </span></span><br><span class="line">  <span class="comment">// as calling unpackTime().  </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Optional fast-path check:  </span></span><br><span class="line">  <span class="comment">// Return immediately if a permit is available.  </span></span><br><span class="line">  <span class="comment">// We depend on Atomic::xchg() having full barrier semantics  </span></span><br><span class="line">  <span class="comment">// since we are doing a lock-free update to _counter.  </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (Atomic::xchg(<span class="number">0</span>, &amp;_counter) &gt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>如果不成功，则构造一个ThreadBlockInVM，然后检查_counter是不是&gt;0，如果是，则把_counter设置为0，unlock mutex并返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadBlockInVM <span class="title">tbivm</span><span class="params">(jt)</span></span>;  </span><br><span class="line"><span class="keyword">if</span> (_counter &gt; <span class="number">0</span>)  &#123; <span class="comment">// no wait needed  </span></span><br><span class="line">  _counter = <span class="number">0</span>;  </span><br><span class="line">  status = pthread_mutex_unlock(_mutex);</span><br></pre></td></tr></table></figure><p>否则，再判断等待的时间，然后再调用pthread_cond_wait函数等待，如果等待返回，则把_counter设置为0，unlock mutex并返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (time == <span class="number">0</span>) &#123;  </span><br><span class="line">  status = pthread_cond_wait (_cond, _mutex) ;  </span><br><span class="line">&#125;  </span><br><span class="line">_counter = <span class="number">0</span> ;  </span><br><span class="line">status = pthread_mutex_unlock(_mutex) ;  </span><br><span class="line">assert_status(status == <span class="number">0</span>, status, <span class="string">"invariant"</span>) ;  </span><br><span class="line">OrderAccess::fence();</span><br></pre></td></tr></table></figure><ul><li><strong>unpark 过程</strong></li></ul><p>当unpark时，则简单多了，直接设置_counter为1，再unlock mutex返回。如果_counter之前的值是0，则还要调用pthread_cond_signal唤醒在park中等待的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Parker::unpark() &#123;  </span><br><span class="line">  <span class="keyword">int</span> s, status ;  </span><br><span class="line">  status = pthread_mutex_lock(_mutex);  </span><br><span class="line">  <span class="keyword">assert</span> (status == <span class="number">0</span>, <span class="string">"invariant"</span>) ;  </span><br><span class="line">  s = _counter;  </span><br><span class="line">  _counter = <span class="number">1</span>;  </span><br><span class="line">  <span class="keyword">if</span> (s &lt; <span class="number">1</span>) &#123;  </span><br><span class="line">     <span class="keyword">if</span> (WorkAroundNPTLTimedWaitHang) &#123;  </span><br><span class="line">        status = pthread_cond_signal (_cond) ;  </span><br><span class="line">        <span class="keyword">assert</span> (status == <span class="number">0</span>, <span class="string">"invariant"</span>) ;  </span><br><span class="line">        status = pthread_mutex_unlock(_mutex);  </span><br><span class="line">        <span class="keyword">assert</span> (status == <span class="number">0</span>, <span class="string">"invariant"</span>) ;  </span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        status = pthread_mutex_unlock(_mutex);  </span><br><span class="line">        <span class="keyword">assert</span> (status == <span class="number">0</span>, <span class="string">"invariant"</span>) ;  </span><br><span class="line">        status = pthread_cond_signal (_cond) ;  </span><br><span class="line">        <span class="keyword">assert</span> (status == <span class="number">0</span>, <span class="string">"invariant"</span>) ;  </span><br><span class="line">     &#125;  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    pthread_mutex_unlock(_mutex);  </span><br><span class="line">    <span class="keyword">assert</span> (status == <span class="number">0</span>, <span class="string">"invariant"</span>) ;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LockSupport的特性"><a href="#LockSupport的特性" class="headerlink" title="LockSupport的特性"></a>LockSupport的特性</h2><h3 id="先释放许可，再获取许可"><a href="#先释放许可，再获取许可" class="headerlink" title="先释放许可，再获取许可"></a>先释放许可，再获取许可</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     Thread thread = Thread.currentThread();</span><br><span class="line">     LockSupport.unpark(thread);<span class="comment">//释放许可</span></span><br><span class="line">     LockSupport.park();<span class="comment">// 获取许可</span></span><br><span class="line">     System.out.println(<span class="string">"b"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不可重入"><a href="#不可重入" class="headerlink" title="不可重入"></a>不可重入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Thread thread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">LockSupport.unpark(thread);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"a"</span>);</span><br><span class="line">LockSupport.park();</span><br><span class="line">System.out.println(<span class="string">"b"</span>);</span><br><span class="line">LockSupport.park();</span><br><span class="line">System.out.println(<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码打印出a和b，不会打印c，因为第二次调用park的时候，线程无法获取许可出现死锁。</p><h3 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h3><p>LockSupport.part()方法是响应中断地，当线程中断后，会从park方法返回执行后续逻辑，所以，LockSupport中的对中断地响应可以灵活控制。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> joyo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/4/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportInterruptTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    LockSupport.park();</span><br><span class="line">                    System.out.println(<span class="string">"come back here"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终输出结果：come back here，而不是打印异常栈。</p><p>而Object.wait()方法并没有这个特性，会直接抛出中断异常。</p><h2 id="LockSupport-和-Object的区别"><a href="#LockSupport-和-Object的区别" class="headerlink" title="LockSupport 和 Object的区别"></a>LockSupport 和 Object的区别</h2><p>两者区别总结如下：</p><ol><li>Object.wait和notify都是针对对象的，notify实际上是不知道唤醒具体哪个线程的，而Locksupport支持指定线程唤醒</li><li>实现原理不同，Locksupport是基于Unsafe.park来实现的。具体可以见参考资料3</li><li>Locksupport功能更加强大些： 基于“许可”的同步实现，提供parkBlocker来监视锁的持有等。而Object.wait方法来完成同步，需要依赖监视器锁。</li><li>JDK1.6之后针对synchrnized引入了分级的锁，根据后面的代码示例发现两类同步原语的开销是差不多的</li></ol><p>两者相同点：</p><ol><li>park和wait都会阻塞线程，释放锁</li><li>虽然响应中断行动不同，但是都会更改中断标志位</li><li>功能上其实相近，但是为了易用性和功能妥协，park和unpark基本可以替代Object.wait和notify等</li></ol><p>从区别上来看可知，使用Locksupport能更加精细、灵活地控制线程的同步，利于实现各种同步工具和锁。精细体现在针对线程的同步控制，灵活体现在通过“许可”获取的方式来保证活性。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000008420938" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008420938</a><br><a href="https://www.jianshu.com/p/e3afe8ab8364" target="_blank" rel="noopener">https://www.jianshu.com/p/e3afe8ab8364</a><br><a href="https://blog.csdn.net/u013851082/article/details/70242395" target="_blank" rel="noopener">https://blog.csdn.net/u013851082/article/details/70242395</a><br><a href="https://kaimingwan.com/post/java/javabing-fa-yu-suo/liao-liao-locksupport" target="_blank" rel="noopener">https://kaimingwan.com/post/java/javabing-fa-yu-suo/liao-liao-locksupport</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;LockSupport-用法简介&quot;&gt;&lt;a href=&quot;#LockSupport-用法简介&quot; class=&quot;headerlink&quot; title=&quot;LockSupport 用法简介&quot;&gt;&lt;/a&gt;LockSupport 用法简介&lt;/h2&gt;&lt;p&gt;LockSupport是用来
      
    
    </summary>
    
      <category term="java" scheme="http://www.iforfee.com/categories/java/"/>
    
    
      <category term="LockSupport" scheme="http://www.iforfee.com/tags/LockSupport/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="http://www.iforfee.com/java/datastructure/ThreadLocal/"/>
    <id>http://www.iforfee.com/java/datastructure/ThreadLocal/</id>
    <published>2018-04-15T06:24:23.000Z</published>
    <updated>2018-04-26T08:06:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal 作为 Thread 中的 ThreadLocalMap 的 key 。</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            threadLocal.set((<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>D));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         MyRunnable sharedRunnableInstance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">         Thread thread1 = <span class="keyword">new</span> Thread(sharedRunnableInstance);</span><br><span class="line">         Thread thread2 = <span class="keyword">new</span> Thread(sharedRunnableInstance);</span><br><span class="line">         thread1.start();</span><br><span class="line">         thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-and-Set"><a href="#get-and-Set" class="headerlink" title="get and Set"></a>get and Set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment">    * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment">    * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment">    * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment"> *        this thread-local.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment">    * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment">    * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment">    * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hash冲突"><a href="#hash冲突" class="headerlink" title="hash冲突"></a>hash冲突</h2><p>当set发生hash冲突时，获取数组中下一个可插入的位置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 走到这里，说明key不相等，即发生了key的冲突，通过nextIndex 获取下一个可用的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。<br>其实，ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/" target="_blank" rel="noopener">深入分析 ThreadLocal 内存泄漏问题</a><br><a href="http://blog.xiaohansong.com/2016/08/09/ThreadLocal-leak-analyze/" target="_blank" rel="noopener">ThreadLocal 内存泄露的实例分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ThreadLocal 作为 Thread 中的 ThreadLocalMap 的 key 。&lt;/p&gt;
&lt;h2 id=&quot;Example&quot;&gt;&lt;a href=&quot;#Example&quot; class=&quot;headerlink&quot; title=&quot;Example&quot;&gt;&lt;/a&gt;Example&lt;/h
      
    
    </summary>
    
      <category term="java" scheme="http://www.iforfee.com/categories/java/"/>
    
    
      <category term="data structure" scheme="http://www.iforfee.com/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>redis缓存</title>
    <link href="http://www.iforfee.com/redis/redis%E7%BC%93%E5%AD%98/"/>
    <id>http://www.iforfee.com/redis/redis缓存/</id>
    <published>2018-04-13T09:24:55.000Z</published>
    <updated>2018-04-14T07:01:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>什么是缓存穿透？<br>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。如果key对应的value是一定不存在的，并且对该key并发请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p><p>如何避免？<br>1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。<br>2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。【感觉应该用的不多吧】</p><p>开发提示：<br>有关布隆过滤器的相关知识，可以参考：<a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bloom_filter</a><br>可以利用 Redis 的 Bitmaps 实现布隆过滤器，GitHub 上已经开源了类似的方案，读者可以进行参考：<br><a href="https://github.com/erikdubbelboer/Redis-Lua-scaling-bloom-filter" target="_blank" rel="noopener">https://github.com/erikdubbelboer/Redis-Lua-scaling-bloom-filter</a></p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>什么是缓存雪崩？<br>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。</p><p>如何避免？</p><p>预防</p><ul><li>保证缓存层服务高可用性（多个节点）</li><li>不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</li><li>从缓存层面来看，不设置过期时间，每个 value 设置一个逻辑过期时间</li><li>可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存</li><li>做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期</li><li>提前演练</li></ul><p>事后处理</p><ul><li>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</li><li>依赖隔离组件为后端限流并降级</li></ul><h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样避免，用户请求的时候，再去加载相关的数据。</p><p>解决思路：</p><ol><li>直接写个缓存刷新页面，上线时手工操作下。</li><li>数据量不大，可以在WEB系统启动的时候加载。</li><li>定时刷新缓存</li></ol><h2 id="缓存数据的淘汰"><a href="#缓存数据的淘汰" class="headerlink" title="缓存数据的淘汰"></a>缓存数据的淘汰</h2><p>缓存淘汰的策略有两种： (1) 定时去清理过期的缓存。 （2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。<br>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂，具体用哪种方案，大家可以根据自己的应用场景来权衡。</p><p>淘汰机制</p><ul><li>LRU</li><li>TTL</li></ul><p><a href="https://github.com/bingbo/blog/wiki/Redis%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">Redis数据淘汰机制</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/fidelQuan/p/4543387.html" target="_blank" rel="noopener">缓存穿透与缓存雪崩</a><br><a href="https://www.jianshu.com/p/5c6f3ec161f1" target="_blank" rel="noopener">Redis架构之防雪崩设计：网站不宕机背后的兵法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;缓存穿透&quot;&gt;&lt;a href=&quot;#缓存穿透&quot; class=&quot;headerlink&quot; title=&quot;缓存穿透&quot;&gt;&lt;/a&gt;缓存穿透&lt;/h2&gt;&lt;p&gt;什么是缓存穿透？&lt;br&gt;一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB
      
    
    </summary>
    
      <category term="redis" scheme="http://www.iforfee.com/categories/redis/"/>
    
    
      <category term="cache" scheme="http://www.iforfee.com/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>redis事务</title>
    <link href="http://www.iforfee.com/redis/redis%E4%BA%8B%E5%8A%A1/"/>
    <id>http://www.iforfee.com/redis/redis事务/</id>
    <published>2018-04-13T03:00:31.000Z</published>
    <updated>2018-04-13T03:06:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 通过 <a href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" target="_blank" rel="noopener">MULTI</a> 、 <a href="http://redis.readthedocs.org/en/latest/transaction/discard.html#discard" target="_blank" rel="noopener">DISCARD</a> 、 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 和 <a href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" target="_blank" rel="noopener">WATCH</a> 四个命令来实现事务功能， 本章首先讨论使用 <a href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" target="_blank" rel="noopener">MULTI</a> 、 <a href="http://redis.readthedocs.org/en/latest/transaction/discard.html#discard" target="_blank" rel="noopener">DISCARD</a> 和 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 三个命令实现的一般事务， 然后再来讨论带有 <a href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" target="_blank" rel="noopener">WATCH</a> 的事务的实现。</p><p>因为事务的安全性也非常重要， 所以本章最后通过常见的 ACID 性质对 Redis 事务的安全性进行了说明。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务提供了一种“将多个命令打包， 然后一次性、按顺序地执行”的机制， 并且事务在执行的期间不会主动中断 —— 服务器在执行完事务中的所有命令之后， 才会继续处理其他客户端的其他命令。</p><p>以下是一个事务的例子， 它先以 <a href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" target="_blank" rel="noopener">MULTI</a> 开始一个事务， 然后将多个命令入队到事务中， 最后由 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 命令触发事务， 一并执行事务中的所有命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET book-name &quot;Mastering C++ in 21 days&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; GET book-name</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; SADD tag &quot;C++&quot; &quot;Programming&quot; &quot;Mastering Series&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS tag</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) &quot;Mastering C++ in 21 days&quot;</span><br><span class="line">3) (integer) 3</span><br><span class="line">4) 1) &quot;Mastering Series&quot;</span><br><span class="line">   2) &quot;C++&quot;</span><br><span class="line">   3) &quot;Programming&quot;</span><br></pre></td></tr></table></figure><p>一个事务从开始到执行会经历以下三个阶段：</p><ol><li>开始事务。</li><li>命令入队。</li><li>执行事务。</li></ol><p>下文将分别介绍事务的这三个阶段。</p><h2 id="开始事务"><a href="#开始事务" class="headerlink" title="开始事务"></a>开始事务</h2><p><a href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" target="_blank" rel="noopener">MULTI</a> 命令的执行标记着事务的开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>这个命令唯一做的就是， 将客户端的 <code>REDIS_MULTI</code> 选项打开， 让客户端从非事务状态切换到事务状态。</p><p><img src="/images/redis/graphviz-0ff9f2e58803dbb8c1c400e1f8191f77d4c2917e.svg" alt="digraph normal_to_transaction {    rankdir = LR;    node [shape = circle, style = filled];    edge [style = bold];    label = &quot;客户端状态的切换&quot;;    normal [label = &quot;非事务状态&quot;, fillcolor = &quot;#FADCAD&quot;];    transaction [label = &quot;事务状态&quot;, fillcolor = &quot;#A8E270&quot;];    normal -&gt; transaction [label = &quot;打开选项\nREDIS_MULTI&quot;];}"></p><h2 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a>命令入队</h2><p>当客户端处于非事务状态下时， 所有发送给服务器端的命令都会立即被服务器执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello moto&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET msg</span><br><span class="line">&quot;hello moto&quot;</span><br></pre></td></tr></table></figure><p>但是， 当客户端进入事务状态之后， 服务器在收到来自客户端的命令时， 不会立即执行命令， 而是将这些命令全部放进一个事务队列里， 然后返回 <code>QUEUED</code> ， 表示命令已入队：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET msg &quot;hello moto&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; GET msg</span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure><p>以下流程图展示了这一行为：</p><p><img src="/images/redis/graphviz-8a0f8eae0bb8180e877b799921dd690267c2d3b4.svg" alt="digraph enqueue {    node [shape = plaintext, style = filled];    edge [style = bold];    command_in [label = &quot;服务器接到来自客户端的命令&quot;];    in_transaction_or_not [label = &quot;客户端是否正处于事务状态？&quot;, shape = diamond, fillcolor = &quot;#95BBE3&quot;];    enqueu_command [label = &quot;将命令放进事务队列里&quot;, fillcolor = &quot;#A8E270&quot;];    return_enqueued [label = &quot;向客户端返回 QUEUED 字符串\n表示命令已入队&quot;, fillcolor = &quot;#A8E270&quot;];    exec_command [label = &quot;执行命令&quot;, fillcolor = &quot;#FADCAD&quot;];    return_command_result [label = &quot;向客户端返回命令的执行结果&quot;, fillcolor = &quot;#FADCAD&quot;];    //     command_in -&gt; in_transaction_or_not;    in_transaction_or_not -&gt; enqueu_command [label = &quot;是&quot;];    in_transaction_or_not -&gt; exec_command [label = &quot;否&quot;];    exec_command -&gt; return_command_result;    enqueu_command -&gt; return_enqueued;}"></p><p>事务队列是一个数组， 每个数组项是都包含三个属性：</p><ol><li>要执行的命令（cmd）。</li><li>命令的参数（argv）。</li><li>参数的个数（argc）。</li></ol><p>举个例子， 如果客户端执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET book-name &quot;Mastering C++ in 21 days&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; GET book-name</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; SADD tag &quot;C++&quot; &quot;Programming&quot; &quot;Mastering Series&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS tag</span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure><p>那么程序将为客户端创建以下事务队列：</p><table><thead><tr><th>数组索引</th><th>cmd</th><th>argv</th><th>argc</th></tr></thead><tbody><tr><td><code>0</code></td><td><code>SET</code></td><td><code>[&quot;book-name&quot;, &quot;Mastering C++ in 21 days&quot;]</code></td><td><code>2</code></td></tr><tr><td><code>1</code></td><td><code>GET</code></td><td><code>[&quot;book-name&quot;]</code></td><td><code>1</code></td></tr><tr><td><code>2</code></td><td><code>SADD</code></td><td><code>[&quot;tag&quot;, &quot;C++&quot;, &quot;Programming&quot;, &quot;Mastering Series&quot;]</code></td><td><code>4</code></td></tr><tr><td><code>3</code></td><td><code>SMEMBERS</code></td><td><code>[&quot;tag&quot;]</code></td><td><code>1</code></td></tr></tbody></table><h2 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h2><p>前面说到， 当客户端进入事务状态之后， 客户端发送的命令就会被放进事务队列里。</p><p>但其实并不是所有的命令都会被放进事务队列， 其中的例外就是 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 、 <a href="http://redis.readthedocs.org/en/latest/transaction/discard.html#discard" target="_blank" rel="noopener">DISCARD</a> 、 <a href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" target="_blank" rel="noopener">MULTI</a> 和 <a href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" target="_blank" rel="noopener">WATCH</a> 这四个命令 —— 当这四个命令从客户端发送到服务器时， 它们会像客户端处于非事务状态一样， 直接被服务器执行：</p><p><img src="/images/redis/graphviz-836c8a3dc33526a649d9ecf5b7b959d72b38cc7d.svg" alt="digraph not_enque_command {    node [shape = plaintext, style = filled];    edge [style = bold];    command_in [label = &quot;服务器接到来自客户端的命令&quot;];    in_transaction_or_not [label = &quot;客户端是否正处于事务状态？&quot;, shape = diamond, fillcolor = &quot;#95BBE3&quot;];    not_exec_and_discard [label = &quot;命令是否\nEXEC 、 DISCARD 、\nMULTI 或 WATCH ？&quot;, shape = diamond, fillcolor = &quot;#FFC1C1&quot;];    enqueu_command [label = &quot;将命令放进事务队列里&quot;, fillcolor = &quot;#A8E270&quot;];    return_enqueued [label = &quot;向客户端返回 QUEUED 字符串\n表示命令已入队&quot;, fillcolor = &quot;#A8E270&quot;];    exec_command [label = &quot;执行命令&quot;, fillcolor = &quot;#FADCAD&quot;];    return_command_result [label = &quot;向客户端返回命令的执行结果&quot;, fillcolor = &quot;#FADCAD&quot;];    //     command_in -&gt; in_transaction_or_not;    in_transaction_or_not -&gt; not_exec_and_discard [label = &quot;是&quot;];    not_exec_and_discard -&gt; enqueu_command [label = &quot;否&quot;];    not_exec_and_discard -&gt; exec_command [label = &quot;是&quot;];    in_transaction_or_not -&gt; exec_command [label = &quot;否&quot;];    exec_command -&gt; return_command_result;    enqueu_command -&gt; return_enqueued;}"></p><p>如果客户端正处于事务状态， 那么当 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 命令执行时， 服务器根据客户端所保存的事务队列， 以先进先出（FIFO）的方式执行事务队列中的命令： 最先入队的命令最先执行， 而最后入队的命令最后执行。</p><p>比如说，对于以下事务队列：</p><table><thead><tr><th>数组索引</th><th>cmd</th><th>argv</th><th>argc</th></tr></thead><tbody><tr><td><code>0</code></td><td><code>SET</code></td><td><code>[&quot;book-name&quot;, &quot;Mastering C++ in 21 days&quot;]</code></td><td><code>2</code></td></tr><tr><td><code>1</code></td><td><code>GET</code></td><td><code>[&quot;book-name&quot;]</code></td><td><code>1</code></td></tr><tr><td><code>2</code></td><td><code>SADD</code></td><td><code>[&quot;tag&quot;, &quot;C++&quot;, &quot;Programming&quot;, &quot;Mastering Series&quot;]</code></td><td><code>4</code></td></tr><tr><td><code>3</code></td><td><code>SMEMBERS</code></td><td><code>[&quot;tag&quot;]</code></td><td><code>1</code></td></tr></tbody></table><p>程序会首先执行 <a href="http://redis.readthedocs.org/en/latest/string/set.html#set" target="_blank" rel="noopener">SET</a> 命令， 然后执行 <a href="http://redis.readthedocs.org/en/latest/string/get.html#get" target="_blank" rel="noopener">GET</a> 命令， 再然后执行 <a href="http://redis.readthedocs.org/en/latest/set/sadd.html#sadd" target="_blank" rel="noopener">SADD</a> 命令， 最后执行 <a href="http://redis.readthedocs.org/en/latest/set/smembers.html#smembers" target="_blank" rel="noopener">SMEMBERS</a> 命令。</p><p>执行事务中的命令所得的结果会以 FIFO 的顺序保存到一个回复队列中。</p><p>比如说，对于上面给出的事务队列，程序将为队列中的命令创建如下回复队列：</p><table><thead><tr><th>数组索引</th><th>回复类型</th><th>回复内容</th></tr></thead><tbody><tr><td><code>0</code></td><td>status code reply</td><td><code>OK</code></td></tr><tr><td><code>1</code></td><td>bulk reply</td><td><code>&quot;Mastering C++ in 21 days&quot;</code></td></tr><tr><td><code>2</code></td><td>integer reply</td><td><code>3</code></td></tr><tr><td><code>3</code></td><td>multi-bulk reply</td><td><code>[&quot;Mastering Series&quot;, &quot;C++&quot;, &quot;Programming&quot;]</code></td></tr></tbody></table><p>当事务队列里的所有命令被执行完之后， <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 命令会将回复队列作为自己的执行结果返回给客户端， 客户端从事务状态返回到非事务状态， 至此， 事务执行完毕。</p><p>事务的整个执行过程可以用以下伪代码表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def execute_transaction():</span><br><span class="line"></span><br><span class="line">    # 创建空白的回复队列</span><br><span class="line">    reply_queue = []</span><br><span class="line"></span><br><span class="line">    # 取出事务队列里的所有命令、参数和参数数量</span><br><span class="line">    for cmd, argv, argc in client.transaction_queue:</span><br><span class="line"></span><br><span class="line">        # 执行命令，并取得命令的返回值</span><br><span class="line">        reply = execute_redis_command(cmd, argv, argc)</span><br><span class="line"></span><br><span class="line">        # 将返回值追加到回复队列末尾</span><br><span class="line">        reply_queue.append(reply)</span><br><span class="line"></span><br><span class="line">    # 清除客户端的事务状态</span><br><span class="line">    clear_transaction_state(client)</span><br><span class="line"></span><br><span class="line">    # 清空事务队列</span><br><span class="line">    clear_transaction_queue(client)</span><br><span class="line"></span><br><span class="line">    # 将事务的执行结果返回给客户端</span><br><span class="line">    send_reply_to_client(client, reply_queue)</span><br></pre></td></tr></table></figure><h2 id="在事务和非事务状态下执行命令"><a href="#在事务和非事务状态下执行命令" class="headerlink" title="在事务和非事务状态下执行命令"></a>在事务和非事务状态下执行命令</h2><p>无论在事务状态下， 还是在非事务状态下， Redis 命令都由同一个函数执行， 所以它们共享很多服务器的一般设置， 比如 AOF 的配置、RDB 的配置，以及内存限制，等等。</p><p>不过事务中的命令和普通命令在执行上还是有一点区别的，其中最重要的两点是：</p><ol><li><p>非事务状态下的命令以单个命令为单位执行，前一个命令和后一个命令的客户端不一定是同一个；</p><p>而事务状态则是以一个事务为单位，执行事务队列中的所有命令：除非当前事务执行完毕，否则服务器不会中断事务，也不会执行其他客户端的其他命令。</p></li><li><p>在非事务状态下，执行命令所得的结果会立即被返回给客户端；</p><p>而事务则是将所有命令的结果集合到回复队列，再作为 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 命令的结果返回给客户端。</p></li></ol><h2 id="事务状态下的-DISCARD-、-MULTI-和-WATCH-命令"><a href="#事务状态下的-DISCARD-、-MULTI-和-WATCH-命令" class="headerlink" title="事务状态下的 DISCARD 、 MULTI 和 WATCH 命令"></a>事务状态下的 DISCARD 、 MULTI 和 WATCH 命令</h2><p>除了 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 之外， 服务器在客户端处于事务状态时， 不加入到事务队列而直接执行的另外三个命令是 <a href="http://redis.readthedocs.org/en/latest/transaction/discard.html#discard" target="_blank" rel="noopener">DISCARD</a> 、 <a href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" target="_blank" rel="noopener">MULTI</a> 和 <a href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" target="_blank" rel="noopener">WATCH</a>。</p><p><a href="http://redis.readthedocs.org/en/latest/transaction/discard.html#discard" target="_blank" rel="noopener">DISCARD</a> 命令用于取消一个事务， 它清空客户端的整个事务队列， 然后将客户端从事务状态调整回非事务状态， 最后返回字符串 <code>OK</code> 给客户端， 说明事务已被取消。</p><p>Redis 的事务是不可嵌套的， 当客户端已经处于事务状态， 而客户端又再向服务器发送 <a href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" target="_blank" rel="noopener">MULTI</a> 时， 服务器只是简单地向客户端发送一个错误， 然后继续等待其他命令的入队。 <a href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" target="_blank" rel="noopener">MULTI</a> 命令的发送不会造成整个事务失败， 也不会修改事务队列中已有的数据。</p><p><a href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" target="_blank" rel="noopener">WATCH</a> 只能在客户端进入事务状态之前执行， 在事务状态下发送 <a href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" target="_blank" rel="noopener">WATCH</a> 命令会引发一个错误， 但它不会造成整个事务失败， 也不会修改事务队列中已有的数据（和前面处理 <a href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" target="_blank" rel="noopener">MULTI</a> 的情况一样）。</p><h2 id="带-WATCH-的事务"><a href="#带-WATCH-的事务" class="headerlink" title="带 WATCH 的事务"></a>带 WATCH 的事务</h2><p><a href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" target="_blank" rel="noopener">WATCH</a> 命令用于在事务开始之前监视任意数量的键： 当调用 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务不再执行， 直接返回失败。</p><p>以下示例展示了一个执行失败的事务例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; WATCH name</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET name peter</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>以下执行序列展示了上面的例子是如何失败的：</p><table><thead><tr><th>时间</th><th>客户端 A</th><th>客户端 B</th></tr></thead><tbody><tr><td>T1</td><td><code>WATCH name</code></td><td></td></tr><tr><td>T2</td><td><code>MULTI</code></td><td></td></tr><tr><td>T3</td><td><code>SET name peter</code></td><td></td></tr><tr><td>T4</td><td></td><td><code>SET name john</code></td></tr><tr><td>T5</td><td><code>EXEC</code></td></tr></tbody></table><p>在时间 T4 ，客户端 B 修改了 <code>name</code> 键的值， 当客户端 A 在 T5 执行 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 时，Redis 会发现 <code>name</code> 这个被监视的键已经被修改， 因此客户端 A 的事务不会被执行，而是直接返回失败。</p><p>下文就来介绍 <a href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" target="_blank" rel="noopener">WATCH</a> 的实现机制，并且看看事务系统是如何检查某个被监视的键是否被修改，从而保证事务的安全性的。</p><h2 id="WATCH-命令的实现"><a href="#WATCH-命令的实现" class="headerlink" title="WATCH 命令的实现"></a>WATCH 命令的实现</h2><p>在每个代表数据库的 <code>redis.h/redisDb</code> 结构类型中， 都保存了一个 <code>watched_keys</code> 字典， 字典的键是这个数据库被监视的键， 而字典的值则是一个链表， 链表中保存了所有监视这个键的客户端。</p><p>比如说，以下字典就展示了一个 <code>watched_keys</code> 字典的例子：</p><p><img src="/images/redis/graphviz-9aea81f33da1373550c590eb0b7ca0c2b3d38366.svg" alt="digraph watched_keys {    rankdir = LR;    node [shape = record, style = filled];    edge [style = bold];    // keys    watched_keys [label = &quot;watched_keys |&lt;key1&gt; key1 |&lt;key2&gt; key2 |&lt;key3&gt; key3 | ... |&lt;keyN&gt; keyN&quot;, fillcolor = &quot;#A8E270&quot;];    // clients blocking for key1    client1 [label = &quot;client1&quot;, fillcolor = &quot;#95BBE3&quot;];    client5 [label = &quot;client5&quot;, fillcolor = &quot;#95BBE3&quot;];    client2 [label = &quot;client2&quot;, fillcolor = &quot;#95BBE3&quot;];    null_1 [label = &quot;NULL&quot;, shape = plaintext];        watched_keys:key1 -&gt; client2;    client2 -&gt; client5;    client5 -&gt; client1;    client1 -&gt; null_1;    // clients blocking for key2    client7 [label = &quot;client7&quot;, fillcolor = &quot;#95BBE3&quot;];    null_2 [label = &quot;NULL&quot;, shape = plaintext];    watched_keys:key2 -&gt; client7;    client7 -&gt; null_2;    // key3    client3 [label = &quot;client3&quot;, fillcolor = &quot;#95BBE3&quot;];    client4 [label = &quot;client4&quot;, fillcolor = &quot;#95BBE3&quot;];    client6 [label = &quot;client6&quot;, fillcolor = &quot;#95BBE3&quot;];    null_3 [label = &quot;NULL&quot;, shape = plaintext];    watched_keys:key3 -&gt; client3;    client3 -&gt; client4;    client4 -&gt; client6;    client6 -&gt; null_3;}"></p><p>其中， 键 <code>key1</code> 正在被 <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 三个客户端监视， 其他一些键也分别被其他别的客户端监视着。</p><p><a href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" target="_blank" rel="noopener">WATCH</a> 命令的作用， 就是将当前客户端和要监视的键在 <code>watched_keys</code> 中进行关联。</p><p>举个例子， 如果当前客户端为 <code>client10086</code> ， 那么当客户端执行 <code>WATCH key1 key2</code> 时， 前面展示的 <code>watched_keys</code> 将被修改成这个样子：</p><p><img src="/images/redis/graphviz-fe5e31054c282a3cdd86656994fe1678a3d4f201.svg" alt="digraph new_watched_keys {    rankdir = LR;    node [shape = record, style = filled];    edge [style = bold];    // keys    watched_keys [label = &quot;watched_keys |&lt;key1&gt; key1 |&lt;key2&gt; key2 |&lt;key3&gt; key3 | ... |&lt;keyN&gt; keyN&quot;, fillcolor = &quot;#A8E270&quot;];    // clients blocking for key1    client1 [label = &quot;client1&quot;, fillcolor = &quot;#95BBE3&quot;];    client5 [label = &quot;client5&quot;, fillcolor = &quot;#95BBE3&quot;];    client2 [label = &quot;client2&quot;, fillcolor = &quot;#95BBE3&quot;];    client10086 [label = &quot;client10086&quot;, fillcolor = &quot;#FFC1C1&quot;];    null_1 [label = &quot;NULL&quot;, shape = plaintext];        watched_keys:key1 -&gt; client2;    client2 -&gt; client5;    client5 -&gt; client1;    client1 -&gt; client10086;    client10086 -&gt; null_1;    // clients blocking for key2    client7 [label = &quot;client7&quot;, fillcolor = &quot;#95BBE3&quot;];    client10086_2 [label = &quot;client10086&quot;, fillcolor = &quot;#FFC1C1&quot;];    null_2 [label = &quot;NULL&quot;, shape = plaintext];    watched_keys:key2 -&gt; client7;    client7 -&gt; client10086_2;    client10086_2 -&gt; null_2;    // key3    client3 [label = &quot;client3&quot;, fillcolor = &quot;#95BBE3&quot;];    client4 [label = &quot;client4&quot;, fillcolor = &quot;#95BBE3&quot;];    client6 [label = &quot;client6&quot;, fillcolor = &quot;#95BBE3&quot;];    null_3 [label = &quot;NULL&quot;, shape = plaintext];    watched_keys:key3 -&gt; client3;    client3 -&gt; client4;    client4 -&gt; client6;    client6 -&gt; null_3;}"></p><p>通过 <code>watched_keys</code> 字典， 如果程序想检查某个键是否被监视， 那么它只要检查字典中是否存在这个键即可； 如果程序要获取监视某个键的所有客户端， 那么只要取出键的值（一个链表）， 然后对链表进行遍历即可。</p><h2 id="WATCH-的触发"><a href="#WATCH-的触发" class="headerlink" title="WATCH 的触发"></a>WATCH 的触发</h2><p>在任何对数据库键空间（key space）进行修改的命令成功执行之后 （比如 <a href="http://redis.readthedocs.org/en/latest/server/flushdb.html#flushdb" target="_blank" rel="noopener">FLUSHDB</a> 、 <a href="http://redis.readthedocs.org/en/latest/string/set.html#set" target="_blank" rel="noopener">SET</a> 、 <a href="http://redis.readthedocs.org/en/latest/key/del.html#del" target="_blank" rel="noopener">DEL</a> 、 <a href="http://redis.readthedocs.org/en/latest/list/lpush.html#lpush" target="_blank" rel="noopener">LPUSH</a> 、 <a href="http://redis.readthedocs.org/en/latest/set/sadd.html#sadd" target="_blank" rel="noopener">SADD</a> 、 <a href="http://redis.readthedocs.org/en/latest/sorted_set/zrem.html#zrem" target="_blank" rel="noopener">ZREM</a> ，诸如此类）， <code>multi.c/touchWatchedKey</code> 函数都会被调用 —— 它检查数据库的 <code>watched_keys</code> 字典， 看是否有客户端在监视已经被命令修改的键， 如果有的话， 程序将所有监视这个/这些被修改键的客户端的 <code>REDIS_DIRTY_CAS</code> 选项打开：</p><p><img src="/images/redis/graphviz-e5c66122242aa10939b696dfeeb905343c5202bd.svg" alt="digraph dirty_cas {    rankdir = LR;    node [shape = circle, style = filled];    edge [style = bold];    label = &quot;客户端状态的切换&quot;;    normal [label = &quot;非事务状态&quot;, fillcolor = &quot;#FADCAD&quot;];    transaction [label = &quot;事务状态&quot;, fillcolor = &quot;#A8E270&quot;];    dirty_cas [label = &quot;事务安全性\n已被破坏&quot;, fillcolor = &quot;#B22222&quot;];    normal -&gt; transaction [label = &quot;打开选项\nREDIS_MULTI&quot;];    transaction -&gt; dirty_cas [label = &quot;打开选项\nREDIS_DIRTY_CAS&quot;];}"></p><p>当客户端发送 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 命令、触发事务执行时， 服务器会对客户端的状态进行检查：</p><ul><li>如果客户端的 <code>REDIS_DIRTY_CAS</code> 选项已经被打开，那么说明被客户端监视的键至少有一个已经被修改了，事务的安全性已经被破坏。服务器会放弃执行这个事务，直接向客户端返回空回复，表示事务执行失败。</li><li>如果 <code>REDIS_DIRTY_CAS</code> 选项没有被打开，那么说明所有监视键都安全，服务器正式执行事务。</li></ul><p>可以用一段伪代码来表示这个检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def check_safety_before_execute_trasaction():</span><br><span class="line"></span><br><span class="line">    if client.state &amp; REDIS_DIRTY_CAS:</span><br><span class="line">        # 安全性已破坏，清除事务状态</span><br><span class="line">        clear_transaction_state(client)</span><br><span class="line">        # 清空事务队列</span><br><span class="line">        clear_transaction_queue(client)</span><br><span class="line">        # 返回空回复给客户端</span><br><span class="line">        send_empty_reply(client)</span><br><span class="line">    else:</span><br><span class="line">        # 安全性完好，执行事务</span><br><span class="line">        execute_transaction()</span><br></pre></td></tr></table></figure><p>举个例子，假设数据库的 <code>watched_keys</code> 字典如下图所示：</p><p><img src="/images/redis/graphviz-9aea81f33da1373550c590eb0b7ca0c2b3d38366.svg" alt="digraph watched_keys {    rankdir = LR;    node [shape = record, style = filled];    edge [style = bold];    // keys    watched_keys [label = &quot;watched_keys |&lt;key1&gt; key1 |&lt;key2&gt; key2 |&lt;key3&gt; key3 | ... |&lt;keyN&gt; keyN&quot;, fillcolor = &quot;#A8E270&quot;];    // clients blocking for key1    client1 [label = &quot;client1&quot;, fillcolor = &quot;#95BBE3&quot;];    client5 [label = &quot;client5&quot;, fillcolor = &quot;#95BBE3&quot;];    client2 [label = &quot;client2&quot;, fillcolor = &quot;#95BBE3&quot;];    null_1 [label = &quot;NULL&quot;, shape = plaintext];        watched_keys:key1 -&gt; client2;    client2 -&gt; client5;    client5 -&gt; client1;    client1 -&gt; null_1;    // clients blocking for key2    client7 [label = &quot;client7&quot;, fillcolor = &quot;#95BBE3&quot;];    null_2 [label = &quot;NULL&quot;, shape = plaintext];    watched_keys:key2 -&gt; client7;    client7 -&gt; null_2;    // key3    client3 [label = &quot;client3&quot;, fillcolor = &quot;#95BBE3&quot;];    client4 [label = &quot;client4&quot;, fillcolor = &quot;#95BBE3&quot;];    client6 [label = &quot;client6&quot;, fillcolor = &quot;#95BBE3&quot;];    null_3 [label = &quot;NULL&quot;, shape = plaintext];    watched_keys:key3 -&gt; client3;    client3 -&gt; client4;    client4 -&gt; client6;    client6 -&gt; null_3;}"></p><p>如果某个客户端对 <code>key1</code> 进行了修改（比如执行 <code>DEL key1</code> ）， 那么所有监视 <code>key1</code> 的客户端， 包括 <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 的 <code>REDIS_DIRTY_CAS</code> 选项都会被打开， 当客户端 <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 执行 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 的时候， 它们的事务都会以失败告终。</p><p>最后，当一个客户端结束它的事务时，无论事务是成功执行，还是失败， <code>watched_keys</code> 字典中和这个客户端相关的资料都会被清除。</p><h2 id="事务的-ACID-性质"><a href="#事务的-ACID-性质" class="headerlink" title="事务的 ACID 性质"></a>事务的 ACID 性质</h2><p>勘误：Redis 的事务是保证原子性的，本节的内容将原子性和回滚功能混淆了，等待修复中。 —— 2013.6.23</p><p>在传统的关系式数据库中，常常用 <a href="http://en.wikipedia.org/wiki/ACID" target="_blank" rel="noopener">ACID 性质</a>来检验事务功能的安全性。</p><p>Redis 事务保证了其中的一致性（C）和隔离性（I），但并不保证原子性（A）和持久性（D）。</p><p>以下四小节是关于这四个性质的详细讨论。</p><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p><p>如果一个事务队列中的所有命令都被成功地执行，那么称这个事务执行成功。</p><p>另一方面，如果 Redis 服务器进程在执行事务的过程中被停止 —— 比如接到 KILL 信号、宿主机器停机，等等，那么事务执行失败。</p><p>当事务失败时，Redis 也不会进行任何的重试或者回滚动作。</p><h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>Redis 的一致性问题可以分为三部分来讨论：入队错误、执行错误、Redis 进程被终结。</p><h4 id="入队错误"><a href="#入队错误" class="headerlink" title="入队错误"></a>入队错误</h4><p>在命令入队的过程中，如果客户端向服务器发送了错误的命令，比如命令的参数数量不对，等等， 那么服务器将向客户端返回一个出错信息， 并且将客户端的事务状态设为 <code>REDIS_DIRTY_EXEC</code> 。</p><p>当客户端执行 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 命令时， Redis 会拒绝执行状态为 <code>REDIS_DIRTY_EXEC</code> 的事务， 并返回失败信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; set key</span><br><span class="line">(error) ERR wrong number of arguments for &apos;set&apos; command</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; EXISTS key</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; EXEC</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure><p>因此，带有不正确入队命令的事务不会被执行，也不会影响数据库的一致性。</p><h4 id="执行错误"><a href="#执行错误" class="headerlink" title="执行错误"></a>执行错误</h4><p>如果命令在事务执行的过程中发生错误，比如说，对一个不同类型的 key 执行了错误的操作， 那么 Redis 只会将错误包含在事务的结果中， 这不会引起事务中断或整个失败，不会影响已执行事务命令的结果，也不会影响后面要执行的事务命令， 所以它对事务的一致性也没有影响。</p><h4 id="Redis-进程被终结"><a href="#Redis-进程被终结" class="headerlink" title="Redis 进程被终结"></a>Redis 进程被终结</h4><p>如果 Redis 服务器进程在执行事务的过程中被其他进程终结，或者被管理员强制杀死，那么根据 Redis 所使用的持久化模式，可能有以下情况出现：</p><ul><li><p>内存模式：如果 Redis 没有采取任何持久化机制，那么重启之后的数据库总是空白的，所以数据总是一致的。</p></li><li><p>RDB 模式：在执行事务时，Redis 不会中断事务去执行保存 RDB 的工作，只有在事务执行之后，保存 RDB 的工作才有可能开始。所以当 RDB 模式下的 Redis 服务器进程在事务中途被杀死时，事务内执行的命令，不管成功了多少，都不会被保存到 RDB 文件里。恢复数据库需要使用现有的 RDB 文件，而这个 RDB 文件的数据保存的是最近一次的数据库快照（snapshot），所以它的数据可能不是最新的，但只要 RDB 文件本身没有因为其他问题而出错，那么还原后的数据库就是一致的。</p></li><li><p>AOF 模式：因为保存 AOF 文件的工作在后台线程进行，所以即使是在事务执行的中途，保存 AOF 文件的工作也可以继续进行，因此，根据事务语句是否被写入并保存到 AOF 文件，有以下两种情况发生：</p><p>1）如果事务语句未写入到 AOF 文件，或 AOF 未被 SYNC 调用保存到磁盘，那么当进程被杀死之后，Redis 可以根据最近一次成功保存到磁盘的 AOF 文件来还原数据库，只要 AOF 文件本身没有因为其他问题而出错，那么还原后的数据库总是一致的，但其中的数据不一定是最新的。</p><p>2）如果事务的部分语句被写入到 AOF 文件，并且 AOF 文件被成功保存，那么不完整的事务执行信息就会遗留在 AOF 文件里，当重启 Redis 时，程序会检测到 AOF 文件并不完整，Redis 会退出，并报告错误。需要使用 redis-check-aof 工具将部分成功的事务命令移除之后，才能再次启动服务器。还原之后的数据总是一致的，而且数据也是最新的（直到事务执行之前为止）。</p></li></ul><h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。</p><h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>因为事务不过是用队列包裹起了一组 Redis 命令，并没有提供任何额外的持久性功能，所以事务的持久性由 Redis 所使用的持久化模式决定：</p><ul><li><p>在单纯的内存模式下，事务肯定是不持久的。</p></li><li><p>在 RDB 模式下，服务器可能在事务执行之后、RDB 文件更新之前的这段时间失败，所以 RDB 模式下的 Redis 事务也是不持久的。</p></li><li><p>在 AOF 的“总是 SYNC ”模式下，事务的每条命令在执行成功之后，都会立即调用 <code>fsync</code> 或 <code>fdatasync</code> 将事务数据写入到 AOF 文件。但是，这种保存是由后台线程进行的，主线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还是有一段非常小的间隔，所以这种模式下的事务也是不持久的。</p><p>其他 AOF 模式也和“总是 SYNC ”模式类似，所以它们都是不持久的。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>事务提供了一种将多个命令打包，然后一次性、有序地执行的机制。</li><li>事务在执行过程中不会被中断，所有事务命令执行完之后，事务才能结束。</li><li>多个命令会被入队到事务队列中，然后按先进先出（FIFO）的顺序执行。</li><li>带 <code>WATCH</code> 命令的事务会将客户端和被监视的键在数据库的 <code>watched_keys</code> 字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的 <code>REDIS_DIRTY_CAS</code> 选项打开。</li><li>只有在客户端的 <code>REDIS_DIRTY_CAS</code> 选项未被打开时，才能执行事务，否则事务直接返回失败。</li><li>Redis 的事务保证了 ACID 中的一致性（C）和隔离性（I），但并不保证原子性（A）和持久性（D）。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://redisbook.readthedocs.io/en/latest/feature/transaction.html" target="_blank" rel="noopener">事务</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis 通过 &lt;a href=&quot;http://redis.readthedocs.org/en/latest/transaction/multi.html#multi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MULTI&lt;/a&gt; 、 &lt;a href
      
    
    </summary>
    
      <category term="redis" scheme="http://www.iforfee.com/categories/redis/"/>
    
    
      <category term="transaction" scheme="http://www.iforfee.com/tags/transaction/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁的几种实现方式</title>
    <link href="http://www.iforfee.com/redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.iforfee.com/redis/分布式锁的几种实现方式/</id>
    <published>2018-04-12T14:48:46.000Z</published>
    <updated>2018-04-12T14:52:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</p><p>在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。在单机环境中，Java中其实提供了很多并发处理相关的API，但是这些API在分布式场景中就无能为力了。也就是说单纯的Java Api并不能提供分布式锁的能力。所以针对分布式锁的实现目前有多种方案。</p><p>针对分布式锁的实现，目前比较常用的有以下几种方案：</p><blockquote><p>基于数据库实现分布式锁 基于缓存（redis，memcached，tair）实现分布式锁 基于Zookeeper实现分布式锁</p></blockquote><p>在分析这几种实现方案之前我们先来想一下，我们需要的分布式锁应该是怎么样的？（这里以方法锁为例，资源锁同理）</p><blockquote><p>可以保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。</p><p>这把锁要是一把可重入锁（避免死锁）</p><p>这把锁最好是一把阻塞锁（根据业务需求考虑要不要这条）</p><p>有高可用的获取锁和释放锁功能</p><p>获取锁和释放锁的性能要好</p></blockquote><hr><h3 id="基于数据库实现分布式锁"><a href="#基于数据库实现分布式锁" class="headerlink" title="基于数据库实现分布式锁"></a>基于数据库实现分布式锁</h3><h4 id="基于数据库表"><a href="#基于数据库表" class="headerlink" title="基于数据库表"></a>基于数据库表</h4><p>要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。</p><p>当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。</p><p>创建这样一张数据库表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `methodLock` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;,</span><br><span class="line">  `method_name` varchar(64) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;锁定的方法名&apos;,</span><br><span class="line">  `desc` varchar(1024) NOT NULL DEFAULT &apos;备注信息&apos;,</span><br><span class="line">  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &apos;保存数据时间，自动生成&apos;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uidx_method_name` (`method_name `) USING BTREE</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;锁定中的方法&apos;;</span><br></pre></td></tr></table></figure><p>当我们想要锁住某个方法时，执行以下SQL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into methodLock(method_name,desc) values (‘method_name’,‘desc’)</span><br></pre></td></tr></table></figure><p>因为我们对<code>method_name</code>做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p><p>当方法执行完毕之后，想要释放锁的话，需要执行以下Sql:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from methodLock where method_name =&apos;method_name&apos;</span><br></pre></td></tr></table></figure><p>上面这种简单的实现有以下几个问题：</p><blockquote><p>1、这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</p><p>2、这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</p><p>3、这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</p><p>4、这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</p></blockquote><p>当然，我们也可以有其他方式解决上面的问题。</p><ul><li>数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。</li><li>没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。</li><li>非阻塞的？搞一个while循环，直到insert成功再返回成功。</li><li>非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li></ul><hr><h4 id="基于数据库排他锁"><a href="#基于数据库排他锁" class="headerlink" title="基于数据库排他锁"></a>基于数据库排他锁</h4><p>除了可以通过增删操作数据表中的记录以外，其实还可以借助数据中自带的锁来实现分布式的锁。</p><p>我们还用刚刚创建的那张数据库表。可以通过数据库的排他锁来实现分布式锁。 基于MySql的InnoDB引擎，可以使用以下方法来实现加锁操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    connection.setAutoCommit(<span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            result = select * from methodLock where method_name=xxx <span class="keyword">for</span> update;</span><br><span class="line">            <span class="keyword">if</span>(result==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在查询语句后面增加<code>for update</code>，数据库会在查询过程中给数据库表增加排他锁（这里再多提一句，InnoDB引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。这里我们希望使用行级锁，就要给method_name添加索引，值得注意的是，这个索引一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上。）。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。</p><p>我们可以认为获得排它锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，再通过以下方法解锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    connection.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>connection.commit()</code>操作来释放锁。</p><p>这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。</p><ul><li>阻塞锁？ <code>for update</code>语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。</li><li>锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。</li></ul><p>但是还是无法直接解决数据库单点和可重入问题。</p><p><strong>这里还可能存在另外一个问题，虽然我们对method_name 使用了唯一索引，并且显示使用for update来使用行级锁。但是，MySql会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。如果发生这种情况就悲剧了。。。</strong></p><hr><p><strong>还有一个问题，就是我们要使用排他锁来进行分布式锁的lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆</strong></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总结一下使用数据库来实现分布式锁的方式，这两种方式都是依赖数据库的一张表，一种是通过表中的记录的存在情况确定当前是否有锁存在，另外一种是通过数据库的排他锁来实现分布式锁。</p><p><strong>数据库实现分布式锁的优点</strong></p><p>直接借助数据库，容易理解。</p><p><strong>数据库实现分布式锁的缺点</strong></p><p>会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。</p><p>操作数据库需要一定的开销，性能问题需要考虑。</p><p>使用数据库的行级锁并不一定靠谱，尤其是当我们的锁表并不大的时候。</p><hr><h3 id="基于缓存实现分布式锁"><a href="#基于缓存实现分布式锁" class="headerlink" title="基于缓存实现分布式锁"></a>基于缓存实现分布式锁</h3><p>相比较于基于数据库实现分布式锁的方案来说，基于缓存来实现在性能方面会表现的更好一点。而且很多缓存是可以集群部署的，可以解决单点问题。</p><p>目前有很多成熟的缓存产品，包括Redis，memcached以及我们公司内部的Tair。</p><p>这里以Tair为例来分析下使用缓存实现分布式锁的方案。关于Redis和memcached在网络上有很多相关的文章，并且也有一些成熟的框架及算法可以直接使用。</p><p>基于Tair的实现分布式锁其实和Redis类似，其中主要的实现方式是使用<code>TairManager.put</code>方法来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">trylock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    ResultCode code = ldbTairManager.put(NAMESPACE, key, <span class="string">"This is a Lock."</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ResultCode.SUCCESS.equals(code))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unlock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    ldbTairManager.invalid(NAMESPACE, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实现方式同样存在几个问题：</p><blockquote><p>1、这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在tair中，其他线程无法再获得到锁。</p><p>2、这把锁只能是非阻塞的，无论成功还是失败都直接返回。</p><p>3、这把锁是非重入的，一个线程获得锁之后，在释放锁之前，无法再次获得该锁，因为使用到的key在tair中已经存在。无法再执行put操作。</p></blockquote><p>当然，同样有方式可以解决。</p><ul><li>没有失效时间？tair的put方法支持传入失效时间，到达时间之后数据会自动删除。</li><li>非阻塞？while重复执行。</li><li>非可重入？在一个线程获取到锁之后，把当前主机信息和线程信息保存起来，下次再获取之前先检查自己是不是当前锁的拥有者。</li></ul><p><strong>但是，失效时间我设置多长时间为好？如何设置的失效时间太短，方法没等执行完，锁就自动释放了，那么就会产生并发问题。如果设置的时间太长，其他获取锁的线程就可能要平白的多等一段时间。</strong>这个问题使用数据库实现分布式锁同样存在</p><hr><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>可以使用缓存来代替数据库来实现分布式锁，这个可以提供更好的性能，同时，很多缓存服务都是集群部署的，可以避免单点问题。并且很多缓存服务都提供了可以用来实现分布式锁的方法，比如Tair的put方法，redis的setnx方法等。并且，这些缓存服务也都提供了对数据的过期自动删除的支持，可以直接设置超时时间来控制锁的释放。</p><p><strong>使用缓存实现分布式锁的优点</strong></p><p>性能好，实现起来较为方便。</p><p><strong>使用缓存实现分布式锁的缺点</strong></p><p>通过超时时间来控制锁的失效时间并不是十分的靠谱。</p><hr><h3 id="基于Zookeeper实现分布式锁"><a href="#基于Zookeeper实现分布式锁" class="headerlink" title="基于Zookeeper实现分布式锁"></a>基于Zookeeper实现分布式锁</h3><p>基于zookeeper临时有序节点可以实现的分布式锁。</p><p>大致思想即为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</p><p>来看下Zookeeper能不能解决前面提到的问题。</p><ul><li>锁无法释放？使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。</li><li>非阻塞锁？使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。</li><li>不可重入？使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。</li><li>单点问题？使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。</li></ul><p>可以直接使用zookeeper第三方库<a href="https://curator.apache.org/" target="_blank" rel="noopener">Curator</a>客户端，这个客户端中封装了一个可重入的锁服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> interProcessMutex.acquire(timeout, unit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        interProcessMutex.release();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        executorService.schedule(<span class="keyword">new</span> Cleaner(client, path), delayTimeForClean, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Curator提供的InterProcessMutex是分布式锁的实现。acquire方法用户获取锁，release方法用于释放锁。</p><p>使用ZK实现的分布式锁好像完全符合了本文开头我们对一个分布式锁的所有期望。但是，其实并不是，Zookeeper实现的分布式锁其实存在一个缺点，那就是性能上可能并没有缓存服务那么高。因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同不到所有的Follower机器上。</p><p><strong>其实，使用Zookeeper也有可能带来并发问题，只是并不常见而已。考虑这样的情况，由于网络抖动，客户端可ZK集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。就可能产生并发问题。这个问题不常见是因为zk有重试机制，一旦zk集群检测不到客户端的心跳，就会重试，Curator客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点。（所以，选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡。）</strong></p><hr><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p><strong>使用Zookeeper实现分布式锁的优点</strong></p><p>有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题。实现起来较为简单。</p><p><strong>使用Zookeeper实现分布式锁的缺点</strong></p><p>性能上不如使用缓存实现分布式锁。 需要对ZK的原理有所了解。</p><hr><h3 id="三种方案的比较"><a href="#三种方案的比较" class="headerlink" title="三种方案的比较"></a>三种方案的比较</h3><p>上面几种方式，哪种方式都无法做到完美。就像CAP一样，在复杂性、可靠性、性能等方面无法同时满足，所以，根据不同的应用场景选择最适合自己的才是王道。</p><h4 id="从理解的难易程度角度（从低到高）"><a href="#从理解的难易程度角度（从低到高）" class="headerlink" title="从理解的难易程度角度（从低到高）"></a>从理解的难易程度角度（从低到高）</h4><p>数据库 &gt; 缓存 &gt; Zookeeper</p><h4 id="从实现的复杂性角度（从低到高）"><a href="#从实现的复杂性角度（从低到高）" class="headerlink" title="从实现的复杂性角度（从低到高）"></a>从实现的复杂性角度（从低到高）</h4><p>Zookeeper &gt;= 缓存 &gt; 数据库</p><h4 id="从性能角度（从高到低）"><a href="#从性能角度（从高到低）" class="headerlink" title="从性能角度（从高到低）"></a>从性能角度（从高到低）</h4><p>缓存 &gt; Zookeeper &gt;= 数据库</p><h4 id="从可靠性角度（从高到低）"><a href="#从可靠性角度（从高到低）" class="headerlink" title="从可靠性角度（从高到低）"></a>从可靠性角度（从高到低）</h4><p>Zookeeper &gt; 缓存 &gt; 数据库</p><p><a href="http://www.hollischuang.com/archives/1716" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition toleran
      
    
    </summary>
    
      <category term="redis" scheme="http://www.iforfee.com/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis合集</title>
    <link href="http://www.iforfee.com/redis/redis%E5%90%88%E9%9B%86/"/>
    <id>http://www.iforfee.com/redis/redis合集/</id>
    <published>2018-04-12T07:16:22.000Z</published>
    <updated>2018-04-14T10:20:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p><a href="https://www.xilidou.com/2017/10/29/Redis-RedLock-%E5%AE%8C%E7%BE%8E%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%B9%88%EF%BC%9F/" target="_blank" rel="noopener">Redis RedLock 完美的分布式锁么？</a></p><p><a href="http://www.weizijun.cn/2016/03/17/%E8%81%8A%E4%B8%80%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E8%AE%BE%E8%AE%A1/" target="_blank" rel="noopener">聊一聊分布式锁的设计</a></p><p><a href="https://piaosanlang.gitbooks.io/redis/content/redisfen-bu-shi-suo-shi-xian.html" target="_blank" rel="noopener">redis分布式锁实现</a></p><p><a href="http://www.hollischuang.com/archives/1716" target="_blank" rel="noopener">分布式锁的几种实现方式</a></p><p><a href="https://legacy.gitbook.com/book/piaosanlang/redis/details" target="_blank" rel="noopener">Redis 学习教程</a></p><p><a href="http://www.cnblogs.com/iforever/p/5796902.html" target="_blank" rel="noopener">redis并发问题</a></p><p><a href="http://blog.51cto.com/effective/1671743" target="_blank" rel="noopener">redis下并发问题解决方案</a></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><a href="http://redisbook.readthedocs.io/en/latest/feature/transaction.html" target="_blank" rel="noopener">事务</a></p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p><a href="http://redisdoc.com/topic/persistence.html" target="_blank" rel="noopener">持久化</a></p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p><a href="https://my.oschina.net/andylucc/blog/675986" target="_blank" rel="noopener">Redis分区实现原理</a></p><p><a href="https://mp.weixin.qq.com/s/Ime_GyDkAJMTird1nWRNUA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Ime_GyDkAJMTird1nWRNUA</a></p><p><a href="http://mp.weixin.qq.com/s__biz=MzIwNDU2MTI4NQ==&amp;mid=2247483728&amp;idx=1&amp;sn=c2076dbc98de6fbd" target="_blank" rel="noopener">http://mp.weixin.qq.com/s__biz=MzIwNDU2MTI4NQ==&amp;mid=2247483728&amp;idx=1&amp;sn=c2076dbc98de6fbd</a><br>40b87236f2033925&amp;chksm=973f0fbaa04886ac83c975b7046885f7171be8d26695d23fcab974124ce054a65d<br>10caea3db5&amp;scene=21#wechat_redirect</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分布式锁&quot;&gt;&lt;a href=&quot;#分布式锁&quot; class=&quot;headerlink&quot; title=&quot;分布式锁&quot;&gt;&lt;/a&gt;分布式锁&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.xilidou.com/2017/10/29/Redis-RedLock-%E5%
      
    
    </summary>
    
      <category term="redis" scheme="http://www.iforfee.com/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Java IO</title>
    <link href="http://www.iforfee.com/java/Java%20IO/"/>
    <id>http://www.iforfee.com/java/Java IO/</id>
    <published>2018-04-08T10:56:12.000Z</published>
    <updated>2018-04-08T10:57:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://my.oschina.net/bluesky0leon/blog/132361" target="_blank" rel="noopener">也谈BIO | NIO | AIO （Java版）</a></p><p><a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">Java NIO浅析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://my.oschina.net/bluesky0leon/blog/132361&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;也谈BIO | NIO | AIO （Java版）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;ht
      
    
    </summary>
    
      <category term="java" scheme="http://www.iforfee.com/categories/java/"/>
    
    
      <category term="io" scheme="http://www.iforfee.com/tags/io/"/>
    
  </entry>
  
  <entry>
    <title>netty相关概念</title>
    <link href="http://www.iforfee.com/netty/netty%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <id>http://www.iforfee.com/netty/netty相关概念/</id>
    <published>2018-04-08T08:26:06.000Z</published>
    <updated>2018-04-10T09:15:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/19732473" target="_blank" rel="noopener">怎样理解阻塞非阻塞与同步异步的区别？</a></p><p><a href="https://my.oschina.net/bluesky0leon/blog/132361" target="_blank" rel="noopener">也谈BIO | NIO | AIO （Java版）</a></p><p><a href="https://www.zhihu.com/question/24322387" target="_blank" rel="noopener">通俗地讲，Netty 能做什么？</a></p><p><a href="http://cmsblogs.com/?p=2467" target="_blank" rel="noopener">Netty的核心组件</a></p><p><a href="https://www.jianshu.com/p/b9f3f6a16911" target="_blank" rel="noopener">Netty入门教程——认识Netty</a><br><a href="https://www.jianshu.com/p/ed0177a9b2e3" target="_blank" rel="noopener">Netty入门教程2——动手搭建HttpServer</a><br><a href="https://www.jianshu.com/p/fd815bd437cd" target="_blank" rel="noopener">Netty入门教程3——Decoder和Encoder</a><br><a href="https://www.jianshu.com/p/9d89b2299ce4" target="_blank" rel="noopener">Netty笔记4-如何实现长连接</a><br><a href="https://legacy.gitbook.com/book/waylau/essential-netty-in-action/details" target="_blank" rel="noopener">Essential Netty in Action 《Netty 实战(精髓)》</a><br><a href="https://legacy.gitbook.com/@waylau" target="_blank" rel="noopener">Way Lau’s Open Souce Books</a></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://segmentfault.com/a/1190000007282628" target="_blank" rel="noopener">源码之下无秘密 ── 做最好的 Netty 源码分析教程</a></p><h2 id="zero-copy"><a href="#zero-copy" class="headerlink" title="zero copy"></a>zero copy</h2><p>Netty的零拷贝体现在三个方面： </p><ol><li>Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。 </li><li>Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。 </li><li>Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。</li></ol><p><a href="http://blog.onlycatch.com/post/Netty%E4%B8%AD%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D" target="_blank" rel="noopener">Netty中的零拷贝</a><br><a href="https://segmentfault.com/a/1190000007560884" target="_blank" rel="noopener">对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://www.jianshu.com/p/1a6d1a25e6cc" target="_blank" rel="noopener">Netty概述</a></p><p><a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">Java NIO浅析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/19732473&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;怎样理解阻塞非阻塞与同步异步的区别？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://my.oschin
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mysql索引及查询优化</title>
    <link href="http://www.iforfee.com/mysql/mysql%E7%B4%A2%E5%BC%95%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
    <id>http://www.iforfee.com/mysql/mysql索引及查询优化/</id>
    <published>2018-04-08T03:52:53.000Z</published>
    <updated>2018-04-08T05:54:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建索引的几大原则"><a href="#建索引的几大原则" class="headerlink" title="建索引的几大原则"></a>建索引的几大原则</h2><ol><li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li><li>尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录</li><li>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);</li><li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</li></ol><h2 id="慢查询优化基本步骤"><a href="#慢查询优化基本步骤" class="headerlink" title="慢查询优化基本步骤"></a>慢查询优化基本步骤</h2><ol><li>先运行看看是否真的很慢，注意设置SQL_NO_CACHE</li><li>where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高</li><li>explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）</li><li>order by limit 形式的sql语句让排序的表优先查</li><li>了解业务方使用场景</li><li>加索引时参照建索引的几大原则</li><li>观察结果，不符合预期继续从0分析</li></ol><h2 id="常用索引优化"><a href="#常用索引优化" class="headerlink" title="常用索引优化"></a>常用索引优化</h2><ol><li>有索引但未被用到的情况（不建议）</li></ol><ul><li>Like的参数以通配符开头时，将导致全表扫描</li><li>where条件不符合最左前缀原则时</li><li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。优化器将无法通过索引来确定将要命中的行数,因此需要搜索该表的所有行</li><li>索引列参与计算</li><li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。可以在num上设置默认值0，确保表中num列没有null值</li><li>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描</li></ul><ol start="2"><li>避免select *</li><li>order by 语句优化</li><li>GROUP BY语句优化</li><li>用 exists 代替 in</li><li>使用 varchar/nvarchar 代替 char/nchar</li><li>能用DISTINCT的就不用GROUP BY</li><li>能用UNION ALL就不要用UNION</li><li>在Join表的时候使用相当类型的例，并将其索引</li></ol><p><a href="https://coolshell.cn/articles/1846.html" target="_blank" rel="noopener">MYSQL性能优化的最佳20+条经验</a><br><a href="https://cloud.tencent.com/developer/article/1004912" target="_blank" rel="noopener">MySQL 索引及查询优化总结</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cloud.tencent.com/developer/article/1004912" target="_blank" rel="noopener">MySQL 索引及查询优化总结</a><br><a href="https://tech.meituan.com/mysql-index.html" target="_blank" rel="noopener">MySQL索引原理及慢查询优化</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;建索引的几大原则&quot;&gt;&lt;a href=&quot;#建索引的几大原则&quot; class=&quot;headerlink&quot; title=&quot;建索引的几大原则&quot;&gt;&lt;/a&gt;建索引的几大原则&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&amp;g
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.iforfee.com/categories/mysql/"/>
    
    
      <category term="索引" scheme="http://www.iforfee.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>感悟</title>
    <link href="http://www.iforfee.com/%E6%84%9F%E6%82%9F/"/>
    <id>http://www.iforfee.com/感悟/</id>
    <published>2018-04-04T14:32:08.000Z</published>
    <updated>2018-04-07T02:39:46.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>当想找到一种通用的解决策略时，可以先列出所有的情况，然后再找统一的策略。</li><li>每天至少做3件事，长时间关注于一件事，容易迷茫。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;当想找到一种通用的解决策略时，可以先列出所有的情况，然后再找统一的策略。&lt;/li&gt;
&lt;li&gt;每天至少做3件事，长时间关注于一件事，容易迷茫。&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>彻底看懂 so called 红黑树</title>
    <link href="http://www.iforfee.com/java/datastructure/treemap/"/>
    <id>http://www.iforfee.com/java/datastructure/treemap/</id>
    <published>2018-04-03T02:42:25.000Z</published>
    <updated>2018-04-15T10:11:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了理解 TreeMap 的底层实现，必须先介绍排序二叉树和红黑树这两种数据结构。其中红黑树又是一种特殊的排序二叉树。</p><h2 id="排序二叉树"><a href="#排序二叉树" class="headerlink" title="排序二叉树"></a>排序二叉树</h2><p>排序二叉树是一种特殊结构的二叉树，可以非常方便地对树中所有节点进行排序和检索。</p><p>排序二叉树要么是一棵空二叉树，要么是具有下列性质的二叉树：</p><ul><li>若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>它的左、右子树也分别为排序二叉树。</li></ul><p>图 1 显示了一棵排序二叉树：</p><p><img src="/images/java/treemap/image-201804031345274.png" alt="mage-20180403134527"></p><p>对排序二叉树，若按中序遍历就可以得到由小到大的有序序列。如图 1 所示二叉树，中序遍历得：</p><p>{2，3，4，8，9，9，10，13，15，18}</p><p>排序二叉树的中序遍历，最终结果是从小到大的升序排列。</p><h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p>创建排序二叉树的步骤，也就是不断地向排序二叉树添加节点的过程，向排序二叉树添加节点的步骤如下：</p><ol><li>以根节点当前节点开始搜索。</li><li>拿新节点的值和当前节点的值比较。</li><li>如果新节点的值更大，则以当前节点的右子节点作为新的当前节点；如果新节点的值更小，则以当前节点的左子节点作为新的当前节点。</li><li>重复 2、3 两个步骤，直到搜索到合适的叶子节点为止。</li><li>将新节点添加为第 4 步找到的叶子节点的子节点；如果新节点更大，则添加为右子节点；否则添加为左子节点。</li></ol><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>当程序从排序二叉树中删除一个节点之后，为了让它依然保持为排序二叉树，程序必须对该排序二叉树进行维护。维护可分为如下几种情况：</p><p>（1）被删除的节点是叶子节点，则只需将它从其父节点中删除即可。</p><p>（2）被删除节点 p 只有左子树，将 p 的左子树 pL 添加成 p 的父节点的左子树即可；被删除节点 p 只有右子树，将 p 的右子树 pR 添加成 p 的父节点的右子树即可。</p><p>（3）若被删除节点 p 的左、右子树均非空，有两种做法：</p><ul><li>将 pL 设为 p 的父节点 q 的左或右子节点（取决于 p 是其父节点 q 的左、右子节点），将 pR 设为 p 节点的中序前趋节点 s 的右子节点（s 是 pL 最右下的节点，也就是 pL 子树中最大的节点）。</li><li>以 p 节点的中序前趋或后继替代 p 所指节点，然后再从原排序二叉树中删去中序前趋或后继节点即可。（也就是用大于 p 的最小节点或小于 p 的最大节点代替 p 节点即可）。</li></ul><p>图 2. 被删除节点只有左子树</p><p><img src="/images/java/treemap/image-201804031348013.png" alt="mage-20180403134801"></p><p>图 3 显示了被删除节点只有右子树的示意图：</p><p><img src="/images/java/treemap/image-201804031348298.png" alt="mage-20180403134829"></p><p>图 4 显示了被删除节点既有左子节点，又有右子节点的情形，此时我们采用到是第一种方式进行维护：</p><p><img src="/images/java/treemap/image-201804031348383.png" alt="mage-20180403134838"></p><p>图 5 显示了被删除节点既有左子树，又有右子树的情形，此时我们采用到是第二种方式进行维护：</p><p><img src="/images/java/treemap/image-201804031348561.png" alt="mage-20180403134856"></p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap的添加和删除节点，是在二叉排序树的添加、删除的基础上，进行旋转和变色。</p><h3 id="添加节点-1"><a href="#添加节点-1" class="headerlink" title="添加节点"></a>添加节点</h3><p>掌握上面理论之后，下面我们来分析 TreeMap 添加节点（TreeMap 中使用 Entry 内部类代表节点）的实现，TreeMap 集合的 put(K key, V value) 方法实现了将 Entry 放入排序二叉树中，下面是该方法的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="comment">// 先以 t 保存链表的 root 节点</span></span><br><span class="line">   Entry&lt;K,V&gt; t = root; </span><br><span class="line">   <span class="comment">// 如果 t==null，表明是一个空链表，即该 TreeMap 里没有任何 Entry </span></span><br><span class="line">   <span class="keyword">if</span> (t == <span class="keyword">null</span>) </span><br><span class="line">   &#123; </span><br><span class="line">       <span class="comment">// 将新的 key-value 创建一个 Entry，并将该 Entry 作为 root </span></span><br><span class="line">       root = <span class="keyword">new</span> Entry&lt;K,V&gt;(key, value, <span class="keyword">null</span>); </span><br><span class="line">       <span class="comment">// 设置该 Map 集合的 size 为 1，代表包含一个 Entry </span></span><br><span class="line">       size = <span class="number">1</span>; </span><br><span class="line">       <span class="comment">// 记录修改次数为 1 </span></span><br><span class="line">       modCount++; </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">int</span> cmp; </span><br><span class="line">   Entry&lt;K,V&gt; parent; </span><br><span class="line">   Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator; </span><br><span class="line">   <span class="comment">// 如果比较器 cpr 不为 null，即表明采用定制排序</span></span><br><span class="line">   <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) </span><br><span class="line">   &#123; </span><br><span class="line">       <span class="keyword">do</span> &#123; </span><br><span class="line">           <span class="comment">// 使用 parent 上次循环后的 t 所引用的 Entry </span></span><br><span class="line">           parent = t; </span><br><span class="line">           <span class="comment">// 拿新插入 key 和 t 的 key 进行比较</span></span><br><span class="line">           cmp = cpr.compare(key, t.key); </span><br><span class="line">           <span class="comment">// 如果新插入的 key 小于 t 的 key，t 等于 t 的左边节点</span></span><br><span class="line">           <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) </span><br><span class="line">               t = t.left; </span><br><span class="line">           <span class="comment">// 如果新插入的 key 大于 t 的 key，t 等于 t 的右边节点</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) </span><br><span class="line">               t = t.right; </span><br><span class="line">           <span class="comment">// 如果两个 key 相等，新的 value 覆盖原有的 value，</span></span><br><span class="line">           <span class="comment">// 并返回原有的 value </span></span><br><span class="line">           <span class="keyword">else</span> </span><br><span class="line">               <span class="keyword">return</span> t.setValue(value); </span><br><span class="line">       &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>); </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">   &#123; </span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>) </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); </span><br><span class="line">       Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key; </span><br><span class="line">       <span class="keyword">do</span> &#123; </span><br><span class="line">           <span class="comment">// 使用 parent 上次循环后的 t 所引用的 Entry </span></span><br><span class="line">           parent = t; </span><br><span class="line">           <span class="comment">// 拿新插入 key 和 t 的 key 进行比较</span></span><br><span class="line">           cmp = k.compareTo(t.key); </span><br><span class="line">           <span class="comment">// 如果新插入的 key 小于 t 的 key，t 等于 t 的左边节点</span></span><br><span class="line">           <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) </span><br><span class="line">               t = t.left; </span><br><span class="line">           <span class="comment">// 如果新插入的 key 大于 t 的 key，t 等于 t 的右边节点</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) </span><br><span class="line">               t = t.right; </span><br><span class="line">           <span class="comment">// 如果两个 key 相等，新的 value 覆盖原有的 value，</span></span><br><span class="line">           <span class="comment">// 并返回原有的 value </span></span><br><span class="line">           <span class="keyword">else</span> </span><br><span class="line">               <span class="keyword">return</span> t.setValue(value); </span><br><span class="line">       &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>); </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="comment">// 将新插入的节点作为 parent 节点的子节点</span></span><br><span class="line">   Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;K,V&gt;(key, value, parent); </span><br><span class="line">   <span class="comment">// 如果新插入 key 小于 parent 的 key，则 e 作为 parent 的左子节点</span></span><br><span class="line">   <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) </span><br><span class="line">       parent.left = e; </span><br><span class="line">   <span class="comment">// 如果新插入 key 小于 parent 的 key，则 e 作为 parent 的右子节点</span></span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">       parent.right = e; </span><br><span class="line">   <span class="comment">// 修复红黑树</span></span><br><span class="line">   fixAfterInsertion(e);                               <span class="comment">// ①</span></span><br><span class="line">   size++; </span><br><span class="line">   modCount++; </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当程序希望添加新节点时：系统总是从树的根节点开始比较 —— 即将根节点当成当前节点，如果新增节点大于当前节点、并且当前节点的右子节点存在，则以右子节点作为当前节点；如果新增节点小于当前节点、并且当前节点的左子节点存在，则以左子节点作为当前节点；如果新增节点等于当前节点，则用新增节点覆盖当前节点，并结束循环 —— 直到找到某个节点的左、右子节点不存在，将新节点添加该节点的子节点 —— 如果新节点比该节点大，则添加为右子节点；如果新节点比该节点小，则添加为左子节点。</p><h3 id="删除节点-1"><a href="#删除节点-1" class="headerlink" title="删除节点"></a>删除节点</h3><p>TreeMap 删除节点采用图 5 所示右边的情形进行维护（中序遍历顺序的后继节点）——也就是用被删除节点的右子树中最小节点与被删节点交换的方式进行维护。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   modCount++; </span><br><span class="line">   size--; </span><br><span class="line">   <span class="comment">// 如果被删除节点的左子树、右子树都不为空</span></span><br><span class="line">   <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) </span><br><span class="line">   &#123; </span><br><span class="line">       <span class="comment">// 用 p 节点的中序后继节点代替 p 节点，且p必然为叶子节点（可参考中序遍历的顺序），所以p.left == null, p.right == null</span></span><br><span class="line">       Entry&lt;K,V&gt; s = successor (p); </span><br><span class="line">       p.key = s.key; </span><br><span class="line">       p.value = s.value; </span><br><span class="line">       p = s; </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="comment">// 如果 p 节点的左节点存在，replacement 代表左节点；否则代表右节点。</span></span><br><span class="line">   Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right); </span><br><span class="line">   <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) <span class="comment">// p 只有一个节点（如果 p 有两个节点，那么 replacement 为 null）</span></span><br><span class="line">   &#123;</span><br><span class="line">       replacement.parent = p.parent; </span><br><span class="line">       <span class="comment">// 如果 p 没有父节点，则 replacemment 变成父节点</span></span><br><span class="line">       <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) </span><br><span class="line">           root = replacement; </span><br><span class="line">       <span class="comment">// 如果 p 节点是其父节点的左子节点</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left) </span><br><span class="line">           p.parent.left  = replacement; </span><br><span class="line">       <span class="comment">// 如果 p 节点是其父节点的右子节点</span></span><br><span class="line">       <span class="keyword">else</span> </span><br><span class="line">           p.parent.right = replacement; </span><br><span class="line">       p.left = p.right = p.parent = <span class="keyword">null</span>; </span><br><span class="line">       <span class="comment">// 修复红黑树</span></span><br><span class="line">       <span class="keyword">if</span> (p.color == BLACK) <span class="comment">// 当 p 为黑色时，由于 p 被删除，那么少了一个黑色节点，需要重新平衡</span></span><br><span class="line">           fixAfterDeletion(replacement);       <span class="comment">// ①</span></span><br><span class="line">   &#125; </span><br><span class="line">   <span class="comment">// 如果 p 节点没有父节点</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) </span><br><span class="line">   &#123; </span><br><span class="line">       root = <span class="keyword">null</span>; </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">   &#123; <span class="comment">// 删除子节点</span></span><br><span class="line">       <span class="keyword">if</span> (p.color == BLACK) </span><br><span class="line">           <span class="comment">// 修复红黑树</span></span><br><span class="line">           fixAfterDeletion(p);                 <span class="comment">// ②</span></span><br><span class="line">       <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) </span><br><span class="line">       &#123; </span><br><span class="line">           <span class="comment">// 如果 p 是其父节点的左子节点</span></span><br><span class="line">           <span class="keyword">if</span> (p == p.parent.left) </span><br><span class="line">               p.parent.left = <span class="keyword">null</span>; </span><br><span class="line">           <span class="comment">// 如果 p 是其父节点的右子节点</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right) </span><br><span class="line">               p.parent.right = <span class="keyword">null</span>; </span><br><span class="line">           p.parent = <span class="keyword">null</span>; </span><br><span class="line">       &#125; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树在原有的排序二叉树增加了如下几个要求：</p><ul><li>性质 1：每个节点要么是红色，要么是黑色。</li><li>性质 2：根节点永远是黑色的。</li><li>性质 3：所有的叶节点都是空节点（即 null），并且是黑色的。</li><li>性质 4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点，但是黑色节点可以连续）</li><li>性质 5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</li></ul><blockquote><p>注意：上面的性质 3 中指定红黑树的每个叶子节点都是空节点，而且并叶子节点都是黑色。但 Java 实现的红黑树将使用 null 来代表空节点，因此遍历红黑树时将看不到黑色的叶子节点，反而看到每个叶子节点都是红色的。</p></blockquote><p>Java 中实现的红黑树可能有如图 6 所示结构：</p><p><img src="/images/java/treemap/image-201804031353340.png" alt="mage-20180403135334"></p><p>备注：本文中所有关于红黑树中的示意图采用白色代表红色。黑色节点还是采用了黑色表示。</p><p>根据性质 5：红黑树从根节点到每个叶子节点的路径都包含相同数量的黑色节点，因此从根节点到叶子节点的路径中包含的黑色节点数被称为树的“黑色高度（black-height）”。</p><p>性质 4 则保证了从根节点到叶子节点的最长路径的长度不会超过任何其他路径的两倍。假如有一棵黑色高度为 3 的红黑树：从根节点到叶节点的最短路径长度是 2，该路径上全是黑色节点（黑节点 - 黑节点 - 黑节点）。最长路径也只可能为 4，在每个黑色节点之间插入一个红色节点（黑节点 - 红节点 - 黑节点 - 红节点 - 黑节点），性质 4 保证绝不可能插入更多的红色节点。由此可见，红黑树中最长路径就是一条红黑交替的路径。</p><p>由此我们可以得出结论：对于给定的黑色高度为 N 的红黑树，从根到叶子节点的最短路径长度为 N-1，最长路径长度为 2 * (N-1)。</p><p>提示：排序二叉树的深度直接影响了检索的性能，正如前面指出，当插入节点本身就是由小到大排列时，排序二叉树将变成一个链表，这种排序二叉树的检索性能最低：N 个节点的二叉树深度就是 N-1。</p><p>红黑树通过上面这种限制来保证它大致是平衡的——因为红黑树的高度不会无限增高，这样保证红黑树在最坏情况下都是高效的，不会出现普通排序二叉树的情况。</p><p>由于红黑树只是一个特殊的排序二叉树，因此对红黑树上的只读操作与普通排序二叉树上的只读操作完全相同，只是红黑树保持了大致平衡，因此检索性能比排序二叉树要好很多。</p><p>但在红黑树上进行插入操作和删除操作会导致树不再符合红黑树的特征，因此插入操作和删除操作都需要进行一定的维护，以保证插入节点、删除节点后的树依然是红黑树。</p><blockquote><p>注意：红黑树并不是真正的平衡二叉树，但在实际应用中，红黑树的统计性能要高于平衡二叉树，但极端性能略差。</p></blockquote><h3 id="添加节点后的修复"><a href="#添加节点后的修复" class="headerlink" title="添加节点后的修复"></a>添加节点后的修复</h3><p>上面 <code>put(K key, V value) 方法中①`</code>号代码处使用<code></code>fixAfterInsertion(e) 方法来修复红黑树——因此每次插入节点后必须进行简单修复，使该排序二叉树满足红黑树的要求。`</p><p>插入操作按如下步骤进行：</p><p>（1）以排序二叉树的方法插入新节点，并将它设为红色。</p><p>（2）进行颜色调换和树旋转。</p><blockquote><p>在插入操作中，红黑树的性质 1 和性质 3 两个永远不会发生改变，因此无需考虑红黑树的这两个特性。</p></blockquote><p>这种颜色调用和树旋转就比较复杂了，下面将分情况进行介绍。在介绍中，我们把新插入的节点定义为 N 节点，N 节点的父节点定义为 P 节点，P 节点的兄弟节点定义为 U 节点，P 节点父节点定义为 G 节点。</p><p>下面分成不同情形来分析插入操作</p><p><strong>情形 1：新节点 N 是树的根节点，没有父节点</strong></p><p>在这种情形下，直接将它设置为黑色以满足性质 2。</p><p><strong>情形 2：新节点的父节点 P 是黑色</strong></p><p>在这种情况下，新插入的节点是红色的，因此依然满足性质 4。而且因为新节点 N 有两个黑色叶子节点；但是由于新节点 N 是红色，通过它的每个子节点的路径依然保持相同的黑色节点数，因此依然满足性质 5。</p><p><strong>情形 3：如果父节点 P 和父节点的兄弟节点 U 都是红色</strong></p><p>在这种情况下，程序应该将 P 节点、U 节点都设置为黑色，并将 P 节点的父节点设为红色（用来保持性质 5）。现在新节点 N 有了一个黑色的父节点 P。由于从 P 节点、U 节点到根节点的任何路径都必须通过 G 节点，在这些路径上的黑节点数目没有改变（原来有叶子和 G 节点两个黑色节点，现在有叶子和 P 两个黑色节点）。</p><p>经过上面处理后，红色的 G 节点的父节点也有可能是红色的，这就违反了性质 4，因此还需要对 G 节点递归地进行整个过程（把 G 当成是新插入的节点进行处理即可）。</p><p>图 7 显示了这种处理过程：</p><p><img src="/images/java/treemap/image-201804031358396.png" alt="mage-20180403135839"></p><blockquote><p>备注：虽然图 11.28 绘制的是新节点 N 作为父节点 P 左子节点的情形，其实新节点 N 作为父节点 P 右子节点的情况与图 11.28 完全相同。</p></blockquote><p><strong>情形 4：父节点 P 是红色、而其兄弟节点 U 是黑色或缺少；且新节点 N 是父节点 P 的右子节点，而父节点 P 又是其父节点 G 的左子节点。</strong></p><p>在这种情形下，我们进行一次左旋转对新节点和其父节点进行，接着按情形 5 处理以前的父节点 P（也就是把 P 当成新插入的节点即可）。这导致某些路径通过它们以前不通过的新节点 N 或父节点 P 的其中之一，但是这两个节点都是红色的，因此不会影响性质 5。</p><p>图 8 显示了对情形 4 的处理：</p><p><img src="/images/java/treemap/image-201804031359160.png" alt="mage-20180403135916"></p><blockquote><p>备注：图 11.29 中 P 节点是 G 节点的左子节点，如果 P 节点是其父节点 G 节点的右子节点，那么上 <strong>面的处理情况应该左、右对调一下。</strong></p></blockquote><p><strong>情形 5：父节点 P 是红色、而其兄弟节点 U 是黑色或缺少；且新节点 N 是其父节点的左子节点，而父节点 P 又是其父节点 G 的左子节点。</strong></p><p>在这种情形下，需要对节点 G 的一次右旋转，在旋转产生的树中，以前的父节点 P 现在是新节点 N 和节点 G 的父节点。由于以前的节点 G 是黑色，否则父节点 P 就不可能是红色，我们切换以前的父节点 P 和节点 G 的颜色，使之满足性质 4，性质 5 也仍然保持满足，因为通过这三个节点中任何一个的所有路径以前都通过节点 G，现在它们都通过以前的父节点 P。在各自的情形下，这都是三个节点中唯一的黑色节点。</p><p>图 9 显示了情形 5 的处理过程：</p><p><img src="/images/java/treemap/image-201804031359473.png" alt="mage-20180403135947"></p><blockquote><p>备注：图 11.30 中 P 节点是 G 节点的左子节点，如果 P 节点是其父节点 G 节点的右子节点，那么上面的处理情况应该左、右对调一下。</p></blockquote><p>情形 4 和情形 5 中的新插入的N节点，貌似会破坏红黑树的性质5（从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点），实际上，新节点N是由于变色而来的，其内部是包含一个黑色节点的。<br><img src="/images/java/treemap/15156478402723.jpeg" alt="image"></p><p>TreeMap 为插入节点后的修复操作由 fixAfterInsertion(Entry&lt;K,V&gt; x) 方法提供，该方法的源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入节点后修复红黑树</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   x.color = RED; </span><br><span class="line">   <span class="comment">// 直到 x 节点的父节点不是根，且 x 的父节点不是红色</span></span><br><span class="line">   <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root </span><br><span class="line">       &amp;&amp; x.parent.color == RED) </span><br><span class="line">   &#123; </span><br><span class="line">       <span class="comment">// 如果 x 的父节点是其父节点的左子节点</span></span><br><span class="line">       <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) </span><br><span class="line">       &#123; </span><br><span class="line">           <span class="comment">// 获取 x 的父节点的兄弟节点</span></span><br><span class="line">           Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); </span><br><span class="line">           <span class="comment">// 如果 x 的父节点的兄弟节点是红色</span></span><br><span class="line">           <span class="keyword">if</span> (colorOf(y) == RED) </span><br><span class="line">           &#123; </span><br><span class="line">               <span class="comment">// 将 x 的父节点设为黑色</span></span><br><span class="line">               setColor(parentOf(x), BLACK); </span><br><span class="line">               <span class="comment">// 将 x 的父节点的兄弟节点设为黑色</span></span><br><span class="line">               setColor(y, BLACK); </span><br><span class="line">               <span class="comment">// 将 x 的父节点的父节点设为红色</span></span><br><span class="line">               setColor(parentOf(parentOf(x)), RED); </span><br><span class="line">               x = parentOf(parentOf(x)); </span><br><span class="line">           &#125; </span><br><span class="line">           <span class="comment">// 如果 x 的父节点的兄弟节点是黑色</span></span><br><span class="line">           <span class="keyword">else</span> </span><br><span class="line">           &#123; </span><br><span class="line">               <span class="comment">// 如果 x 是其父节点的右子节点</span></span><br><span class="line">               <span class="keyword">if</span> (x == rightOf(parentOf(x))) </span><br><span class="line">               &#123; </span><br><span class="line">                   <span class="comment">// 将 x 的父节点设为 x </span></span><br><span class="line">                   x = parentOf(x); </span><br><span class="line">                   rotateLeft(x); </span><br><span class="line">               &#125; </span><br><span class="line">               <span class="comment">// 把 x 的父节点设为黑色</span></span><br><span class="line">               setColor(parentOf(x), BLACK); </span><br><span class="line">               <span class="comment">// 把 x 的父节点的父节点设为红色</span></span><br><span class="line">               setColor(parentOf(parentOf(x)), RED); </span><br><span class="line">               rotateRight(parentOf(parentOf(x))); </span><br><span class="line">           &#125; </span><br><span class="line">       &#125; </span><br><span class="line">       <span class="comment">// 如果 x 的父节点是其父节点的右子节点</span></span><br><span class="line">       <span class="keyword">else</span> </span><br><span class="line">       &#123; </span><br><span class="line">           <span class="comment">// 获取 x 的父节点的兄弟节点</span></span><br><span class="line">           Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); </span><br><span class="line">           <span class="comment">// 如果 x 的父节点的兄弟节点是红色</span></span><br><span class="line">           <span class="keyword">if</span> (colorOf(y) == RED) </span><br><span class="line">           &#123; </span><br><span class="line">               <span class="comment">// 将 x 的父节点设为黑色。</span></span><br><span class="line">               setColor(parentOf(x), BLACK); </span><br><span class="line">               <span class="comment">// 将 x 的父节点的兄弟节点设为黑色</span></span><br><span class="line">               setColor(y, BLACK); </span><br><span class="line">               <span class="comment">// 将 x 的父节点的父节点设为红色</span></span><br><span class="line">               setColor(parentOf(parentOf(x)), RED); </span><br><span class="line">               <span class="comment">// 将 x 设为 x 的父节点的节点</span></span><br><span class="line">               x = parentOf(parentOf(x)); </span><br><span class="line">           &#125; </span><br><span class="line">           <span class="comment">// 如果 x 的父节点的兄弟节点是黑色</span></span><br><span class="line">           <span class="keyword">else</span> </span><br><span class="line">           &#123; </span><br><span class="line">               <span class="comment">// 如果 x 是其父节点的左子节点</span></span><br><span class="line">               <span class="keyword">if</span> (x == leftOf(parentOf(x))) </span><br><span class="line">               &#123; </span><br><span class="line">                   <span class="comment">// 将 x 的父节点设为 x </span></span><br><span class="line">                   x = parentOf(x); </span><br><span class="line">                   rotateRight(x); </span><br><span class="line">               &#125; </span><br><span class="line">               <span class="comment">// 把 x 的父节点设为黑色</span></span><br><span class="line">               setColor(parentOf(x), BLACK); </span><br><span class="line">               <span class="comment">// 把 x 的父节点的父节点设为红色</span></span><br><span class="line">               setColor(parentOf(parentOf(x)), RED); </span><br><span class="line">               rotateLeft(parentOf(parentOf(x))); </span><br><span class="line">           &#125; </span><br><span class="line">       &#125; </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="comment">// 将根节点设为黑色</span></span><br><span class="line">   root.color = BLACK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除节点后的修复"><a href="#删除节点后的修复" class="headerlink" title="删除节点后的修复"></a>删除节点后的修复</h3><p>与添加节点之后的修复类似的是，TreeMap 删除节点之后也需要进行类似的修复操作，通过这种修复来保证该排序二叉树依然满足红黑树特征。大家可以参考插入节点之后的修复来分析删除之后的修复。TreeMap 在删除之后的修复操作由 fixAfterDeletion(Entry&lt;K,V&gt; x) 方法提供，该方法源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除节点后修复红黑树</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="comment">// 直到 x 不是根节点，且 x 的颜色是黑色</span></span><br><span class="line">   <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) </span><br><span class="line">   &#123; </span><br><span class="line">       <span class="comment">// 如果 x 是其父节点的左子节点</span></span><br><span class="line">       <span class="keyword">if</span> (x == leftOf(parentOf(x))) </span><br><span class="line">       &#123; </span><br><span class="line">           <span class="comment">// 获取 x 节点的兄弟节点</span></span><br><span class="line">           Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); </span><br><span class="line">           <span class="comment">// 如果 sib 节点是红色</span></span><br><span class="line">           <span class="keyword">if</span> (colorOf(sib) == RED) </span><br><span class="line">           &#123; </span><br><span class="line">               <span class="comment">// 将 sib 节点设为黑色</span></span><br><span class="line">               setColor(sib, BLACK); </span><br><span class="line">               <span class="comment">// 将 x 的父节点设为红色</span></span><br><span class="line">               setColor(parentOf(x), RED); </span><br><span class="line">               rotateLeft(parentOf(x)); </span><br><span class="line">               <span class="comment">// 再次将 sib 设为 x 的父节点的右子节点</span></span><br><span class="line">               sib = rightOf(parentOf(x)); </span><br><span class="line">           &#125; </span><br><span class="line">           <span class="comment">// 如果 sib 的两个子节点都是黑色</span></span><br><span class="line">           <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK </span><br><span class="line">               &amp;&amp; colorOf(rightOf(sib)) == BLACK) </span><br><span class="line">           &#123; </span><br><span class="line">               <span class="comment">// 将 sib 设为红色</span></span><br><span class="line">               setColor(sib, RED); </span><br><span class="line">               <span class="comment">// 让 x 等于 x 的父节点</span></span><br><span class="line">               x = parentOf(x); </span><br><span class="line">           &#125; </span><br><span class="line">           <span class="keyword">else</span> </span><br><span class="line">           &#123; </span><br><span class="line">               <span class="comment">// 如果 sib 的只有右子节点是黑色</span></span><br><span class="line">               <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) </span><br><span class="line">               &#123; </span><br><span class="line">                   <span class="comment">// 将 sib 的左子节点也设为黑色</span></span><br><span class="line">                   setColor(leftOf(sib), BLACK); </span><br><span class="line">                   <span class="comment">// 将 sib 设为红色</span></span><br><span class="line">                   setColor(sib, RED); </span><br><span class="line">                   rotateRight(sib); </span><br><span class="line">                   sib = rightOf(parentOf(x)); </span><br><span class="line">               &#125; </span><br><span class="line">               <span class="comment">// 设置 sib 的颜色与 x 的父节点的颜色相同</span></span><br><span class="line">               setColor(sib, colorOf(parentOf(x))); </span><br><span class="line">               <span class="comment">// 将 x 的父节点设为黑色</span></span><br><span class="line">               setColor(parentOf(x), BLACK); </span><br><span class="line">               <span class="comment">// 将 sib 的右子节点设为黑色</span></span><br><span class="line">               setColor(rightOf(sib), BLACK); </span><br><span class="line">               rotateLeft(parentOf(x)); </span><br><span class="line">               x = root; </span><br><span class="line">           &#125; </span><br><span class="line">       &#125; </span><br><span class="line">       <span class="comment">// 如果 x 是其父节点的右子节点</span></span><br><span class="line">       <span class="keyword">else</span> </span><br><span class="line">       &#123; </span><br><span class="line">           <span class="comment">// 获取 x 节点的兄弟节点</span></span><br><span class="line">           Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); </span><br><span class="line">           <span class="comment">// 如果 sib 的颜色是红色</span></span><br><span class="line">           <span class="keyword">if</span> (colorOf(sib) == RED) </span><br><span class="line">           &#123; </span><br><span class="line">               <span class="comment">// 将 sib 的颜色设为黑色</span></span><br><span class="line">               setColor(sib, BLACK); </span><br><span class="line">               <span class="comment">// 将 sib 的父节点设为红色</span></span><br><span class="line">               setColor(parentOf(x), RED); </span><br><span class="line">               rotateRight(parentOf(x)); </span><br><span class="line">               sib = leftOf(parentOf(x)); </span><br><span class="line">           &#125; </span><br><span class="line">           <span class="comment">// 如果 sib 的两个子节点都是黑色</span></span><br><span class="line">           <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK </span><br><span class="line">               &amp;&amp; colorOf(leftOf(sib)) == BLACK) </span><br><span class="line">           &#123; </span><br><span class="line">               <span class="comment">// 将 sib 设为红色</span></span><br><span class="line">               setColor(sib, RED); </span><br><span class="line">               <span class="comment">// 让 x 等于 x 的父节点</span></span><br><span class="line">               x = parentOf(x); </span><br><span class="line">           &#125; </span><br><span class="line">           <span class="keyword">else</span> </span><br><span class="line">           &#123; </span><br><span class="line">               <span class="comment">// 如果 sib 只有左子节点是黑色</span></span><br><span class="line">               <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) </span><br><span class="line">               &#123; </span><br><span class="line">                   <span class="comment">// 将 sib 的右子节点也设为黑色</span></span><br><span class="line">                   setColor(rightOf(sib), BLACK); </span><br><span class="line">                   <span class="comment">// 将 sib 设为红色</span></span><br><span class="line">                   setColor(sib, RED); </span><br><span class="line">                   rotateLeft(sib); </span><br><span class="line">                   sib = leftOf(parentOf(x)); </span><br><span class="line">               &#125; </span><br><span class="line">               <span class="comment">// 将 sib 的颜色设为与 x 的父节点颜色相同</span></span><br><span class="line">               setColor(sib, colorOf(parentOf(x))); </span><br><span class="line">               <span class="comment">// 将 x 的父节点设为黑色</span></span><br><span class="line">               setColor(parentOf(x), BLACK); </span><br><span class="line">               <span class="comment">// 将 sib 的左子节点设为黑色</span></span><br><span class="line">               setColor(leftOf(sib), BLACK); </span><br><span class="line">               rotateRight(parentOf(x)); </span><br><span class="line">               x = root; </span><br><span class="line">           &#125; </span><br><span class="line">       &#125; </span><br><span class="line">   &#125; </span><br><span class="line">   setColor(x, BLACK); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检索节点"><a href="#检索节点" class="headerlink" title="检索节点"></a>检索节点</h3><p>当 TreeMap 根据 key 来取出 value 时，TreeMap 对应的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="comment">// 根据指定 key 取出对应的 Entry </span></span><br><span class="line">   Entry&gt;K,V&lt; p = getEntry(key); </span><br><span class="line">   <span class="comment">// 返回该 Entry 所包含的 value </span></span><br><span class="line">   <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面程序的粗体字代码可以看出，get(Object key) 方法实质是由于 getEntry() 方法实现的，这个 getEntry() 方法的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="comment">// 如果 comparator 不为 null，表明程序采用定制排序</span></span><br><span class="line">   <span class="keyword">if</span> (comparator != <span class="keyword">null</span>) </span><br><span class="line">       <span class="comment">// 调用 getEntryUsingComparator 方法来取出对应的 key </span></span><br><span class="line">       <span class="keyword">return</span> getEntryUsingComparator(key); </span><br><span class="line">   <span class="comment">// 如果 key 形参的值为 null，抛出 NullPointerException 异常</span></span><br><span class="line">   <span class="keyword">if</span> (key == <span class="keyword">null</span>) </span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); </span><br><span class="line">   <span class="comment">// 将 key 强制类型转换为 Comparable 实例</span></span><br><span class="line">   Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key; </span><br><span class="line">   <span class="comment">// 从树的根节点开始</span></span><br><span class="line">   Entry&lt;K,V&gt; p = root; </span><br><span class="line">   <span class="keyword">while</span> (p != <span class="keyword">null</span>) </span><br><span class="line">   &#123; </span><br><span class="line">       <span class="comment">// 拿 key 与当前节点的 key 进行比较</span></span><br><span class="line">       <span class="keyword">int</span> cmp = k.compareTo(p.key); </span><br><span class="line">       <span class="comment">// 如果 key 小于当前节点的 key，向“左子树”搜索</span></span><br><span class="line">       <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) </span><br><span class="line">           p = p.left; </span><br><span class="line">       <span class="comment">// 如果 key 大于当前节点的 key，向“右子树”搜索</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) </span><br><span class="line">           p = p.right; </span><br><span class="line">       <span class="comment">// 不大于、不小于，就是找到了目标 Entry </span></span><br><span class="line">       <span class="keyword">else</span> </span><br><span class="line">           <span class="keyword">return</span> p; </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的 getEntry(Object obj) 方法也是充分利用排序二叉树的特征来搜索目标 Entry，程序依然从二叉树的根节点开始，如果被搜索节点大于当前节点，程序向“右子树”搜索；如果被搜索节点小于当前节点，程序向“左子树”搜索；如果相等，那就是找到了指定节点。</p><p>当 TreeMap 里的 comparator != null 即表明该 TreeMap 采用了定制排序，在采用定制排序的方式下，TreeMap 采用 getEntryUsingComparator(key) 方法来根据 key 获取 Entry。下面是该方法的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntryUsingComparator</span><span class="params">(Object key)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   K k = (K) key; </span><br><span class="line">   <span class="comment">// 获取该 TreeMap 的 comparator </span></span><br><span class="line">   Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator; </span><br><span class="line">   <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) </span><br><span class="line">   &#123; </span><br><span class="line">       <span class="comment">// 从根节点开始</span></span><br><span class="line">       Entry&lt;K,V&gt; p = root; </span><br><span class="line">       <span class="keyword">while</span> (p != <span class="keyword">null</span>) </span><br><span class="line">       &#123; </span><br><span class="line">           <span class="comment">// 拿 key 与当前节点的 key 进行比较</span></span><br><span class="line">           <span class="keyword">int</span> cmp = cpr.compare(k, p.key); </span><br><span class="line">           <span class="comment">// 如果 key 小于当前节点的 key，向“左子树”搜索</span></span><br><span class="line">           <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) </span><br><span class="line">               p = p.left; </span><br><span class="line">           <span class="comment">// 如果 key 大于当前节点的 key，向“右子树”搜索</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) </span><br><span class="line">               p = p.right; </span><br><span class="line">           <span class="comment">// 不大于、不小于，就是找到了目标 Entry </span></span><br><span class="line">           <span class="keyword">else</span> </span><br><span class="line">               <span class="keyword">return</span> p; </span><br><span class="line">       &#125; </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实 getEntry、getEntryUsingComparator 两个方法的实现思路完全类似，只是前者对自然排序的 TreeMap 获取有效，后者对定制排序的 TreeMap 有效。</p><p>通过上面源代码的分析不难看出，TreeMap 这个工具类的实现其实很简单。或者说：从内部结构来看，TreeMap 本质上就是一棵“红黑树”，而 TreeMap 的每个 Entry 就是该红黑树的一个节点。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html" target="_blank" rel="noopener">通过分析 JDK 源代码研究 TreeMap 红黑树算法实现</a></li><li><a href="https://segmentfault.com/a/1190000012728513" target="_blank" rel="noopener">红黑树详细分析，看了都说好</a></li><li><a href="https://lvshen9.github.io/2017/11/07/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%8F%98%E8%89%B2%E4%B8%8E%E6%97%8B%E8%BD%AC/" target="_blank" rel="noopener">红黑树的变色与旋转</a></li><li><a href="https://www.jianshu.com/p/ad5d65e7ce62" target="_blank" rel="noopener">红黑树插入删除过程</a></li><li><a href="http://709002341.iteye.com/blog/2259560" target="_blank" rel="noopener">复习红黑树（二）–红黑树的删除</a></li><li><a href="https://blog.csdn.net/u011240877/article/details/53329023" target="_blank" rel="noopener">重温数据结构：深入理解红黑树</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了理解 TreeMap 的底层实现，必须先介绍排序二叉树和红黑树这两种数据结构。其中红黑树又是一种特殊的排序二叉树。&lt;/p&gt;
&lt;h2 id=&quot;排序二叉树&quot;&gt;&lt;a href=&quot;#排序二叉树&quot; class=&quot;headerlink&quot; title=&quot;排序二叉树&quot;&gt;&lt;/a&gt;排序二叉
      
    
    </summary>
    
      <category term="java" scheme="http://www.iforfee.com/categories/java/"/>
    
    
      <category term="data structure" scheme="http://www.iforfee.com/tags/data-structure/"/>
    
  </entry>
  
</feed>
