<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>joyo&#39;s world</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.iforfee.com/"/>
  <updated>2018-05-10T07:01:17.000Z</updated>
  <id>http://www.iforfee.com/</id>
  
  <author>
    <name>joyo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java nio 浅析</title>
    <link href="http://www.iforfee.com/java/javanio/"/>
    <id>http://www.iforfee.com/java/javanio/</id>
    <published>2018-05-10T06:51:15.000Z</published>
    <updated>2018-05-10T07:01:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>NIO（Non-blocking I/O，在Java领域，也称为New I/O），是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。</p><p>那么NIO的本质是什么样的呢？它是怎样与事件模型结合来解放线程、提高系统吞吐的呢？</p><p>本文会从传统的阻塞I/O和线程池模型面临的问题讲起，然后对比几种常见I/O模型，一步步分析NIO怎么利用事件模型处理I/O，解决线程池瓶颈处理海量连接，包括利用面向事件的方式编写服务端/客户端程序。最后延展到一些高级主题，如Reactor与Proactor模型的对比、Selector的唤醒、Buffer的选择等。</p><p>注：本文的代码都是伪代码，主要是为了示意，不可用于生产环境。 </p><h1 id="传统BIO模型分析"><a href="#传统BIO模型分析" class="headerlink" title="传统BIO模型分析"></a>传统BIO模型分析</h1><p>让我们先回忆一下传统的服务器端同步阻塞I/O处理（也就是BIO，Blocking I/O）的经典编程模型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> ExecutorService executor = Excutors.newFixedThreadPollExecutor(<span class="number">100</span>);<span class="comment">//线程池</span></span><br><span class="line"></span><br><span class="line"> ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line"> serverSocket.bind(<span class="number">8088</span>);</span><br><span class="line"> <span class="keyword">while</span>(!Thread.currentThread.isInturrupted())&#123;<span class="comment">//主线程死循环等待新连接到来</span></span><br><span class="line"> Socket socket = serverSocket.accept();</span><br><span class="line"> executor.submit(<span class="keyword">new</span> ConnectIOnHandler(socket));<span class="comment">//为新的连接创建新的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectIOnHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectIOnHandler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.currentThread.isInturrupted()&amp;&amp;!socket.isClosed())&#123;死循环处理读写事件</span><br><span class="line">          String someThing = socket.read()....<span class="comment">//读取数据</span></span><br><span class="line">          <span class="keyword">if</span>(someThing!=<span class="keyword">null</span>)&#123;</span><br><span class="line">             ......<span class="comment">//处理数据</span></span><br><span class="line">             socket.write()....<span class="comment">//写数据</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个经典的每连接每线程的模型，之所以使用多线程，主要原因在于socket.accept()、socket.read()、socket.write()三个主要函数都是同步阻塞的，当一个连接在处理I/O的时候，系统是阻塞的，如果是单线程的话必然就挂死在那里；但CPU是被释放出来的，开启多线程，就可以让CPU去处理更多的事情。其实这也是所有使用多线程的本质：</p><ol><li>利用多核。</li><li>当I/O阻塞系统，但CPU空闲的时候，可以利用多线程使用CPU资源。</li></ol><p>现在的多线程一般都使用线程池，可以让线程的创建和回收成本相对较低。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的I/O并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。</p><p>不过，这个模型最本质的问题在于，严重依赖于线程。但线程是很”贵”的资源，主要表现在：</p><ol><li>线程的创建和销毁成本很高，在Linux这样的操作系统中，线程本质上就是一个进程。创建和销毁都是重量级的系统函数。</li><li>线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千，恐怕整个JVM的内存都会被吃掉一半。</li><li>线程的切换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。如果线程数过高，可能执行线程切换的时间甚至会大于线程执行的时间，这时候带来的表现往往是系统load偏高、CPU sy使用率特别高（超过20%以上)，导致系统几乎陷入不可用的状态。</li><li>容易造成锯齿状的系统负载。因为系统负载是用活动线程数或CPU核心数，一旦线程数量高但外部网络环境不是很稳定，就很容易造成大量请求的结果同时返回，激活大量阻塞线程从而使系统负载压力过大。</li></ol><p>所以，当面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的。随着移动端应用的兴起和各种网络游戏的盛行，百万级长连接日趋普遍，此时，必然需要一种更高效的I/O处理模型。</p><h1 id="NIO是怎么工作的"><a href="#NIO是怎么工作的" class="headerlink" title="NIO是怎么工作的"></a>NIO是怎么工作的</h1><p>很多刚接触NIO的人，第一眼看到的就是Java相对晦涩的API，比如：Channel，Selector，Socket什么的；然后就是一坨上百行的代码来演示NIO的服务端Demo……瞬间头大有没有？</p><p>我们不管这些，抛开现象看本质，先分析下NIO是怎么工作的。</p><h2 id="常见I-O模型对比"><a href="#常见I-O模型对比" class="headerlink" title="常见I/O模型对比"></a>常见I/O模型对比</h2><p>所有的系统I/O都分为两个阶段：等待就绪和操作。举例来说，读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。</p><p>需要说明的是等待就绪的阻塞是不使用CPU的，是在“空等”；而真正的读写操作的阻塞是使用CPU的，真正在”干活”，而且这个过程非常快，属于memory copy，带宽通常在1GB/s级别以上，可以理解为基本不耗时。</p><p>下图是几种常见I/O模型的对比：</p><p><img src="/images/java/nio2.jpg" alt="emma_1"></p><p>以socket.read()为例子：</p><p>传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。</p><p>对于NIO，如果TCP RecvBuffer有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，永远不会阻塞。</p><p>最新的AIO(Async I/O)里面会更进一步：不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。</p><p>换句话说，BIO里用户最关心“我要读”，NIO里用户最关心”我可以读了”，在AIO模型里用户更需要关注的是“读完了”。</p><p>NIO一个重要的特点是：socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的（消耗CPU但性能非常高）。</p><h2 id="如何结合事件模型使用NIO同步非阻塞特性"><a href="#如何结合事件模型使用NIO同步非阻塞特性" class="headerlink" title="如何结合事件模型使用NIO同步非阻塞特性"></a>如何结合事件模型使用NIO同步非阻塞特性</h2><p>回忆BIO模型，之所以需要多线程，是因为在进行I/O操作的时候，一是没有办法知道到底能不能写、能不能读，只能”傻等”，即使通过各种估算，算出来操作系统没有能力进行读写，也没法在socket.read()和socket.write()函数中返回，这两个函数无法进行有效的中断。所以除了多开线程另起炉灶，没有好的办法利用CPU。</p><p>NIO的读写函数可以立刻返回，这就给了我们不开线程利用CPU的最好机会：如果一个连接不能读写（socket.read()返回0或者socket.write()返回0），我们可以把这件事记下来，记录的方式通常是在Selector上注册标记位，然后切换到其它就绪的连接（channel）继续进行读写。</p><p>下面具体看下如何利用事件模型单线程处理所有I/O请求：</p><p>NIO的主要事件有几个：读就绪、写就绪、有新连接到来。</p><p>我们首先需要注册当这几个事件到来的时候所对应的处理器。然后在合适的时机告诉事件选择器：我对这个事件感兴趣。对于写操作，就是写不出去的时候对写事件感兴趣；对于读操作，就是完成连接和系统没有办法承载新读入的数据的时；对于accept，一般是服务器刚启动的时候；而对于connect，一般是connect失败需要重连或者直接异步调用connect的时候。</p><p>其次，用一个死循环选择就绪的事件，会执行系统调用（Linux 2.6之前是select、poll，2.6之后是epoll，Windows是IOCP），还会阻塞的等待新事件的到来。新事件到来的时候，会在selector上注册标记位，标示可读、可写或者有连接到来。</p><p>注意，select是阻塞的，无论是通过操作系统的通知（epoll）还是不停的轮询(select，poll)，这个函数是阻塞的。所以你可以放心大胆地在一个while(true)里面调用这个函数而不用担心CPU空转。</p><p>所以我们的程序大概的模样是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelHandler</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelReadable</span><span class="params">(Channel channel)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelWritable</span><span class="params">(Channel channel)</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Channel</span></span>&#123;</span><br><span class="line">   Socket socket;</span><br><span class="line">   Event event;<span class="comment">//读，写或者连接</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//IO线程主循环:</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">IoThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"> Channel channel;</span><br><span class="line"> <span class="keyword">while</span>(channel=Selector.select())&#123;<span class="comment">//选择就绪的事件和对应的连接</span></span><br><span class="line">    <span class="keyword">if</span>(channel.event==accept)&#123;</span><br><span class="line">       registerNewChannelHandler(channel);<span class="comment">//如果是新连接，则注册一个新的读写处理器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(channel.event==write)&#123;</span><br><span class="line">       getChannelHandler(channel).channelWritable(channel);<span class="comment">//如果可以写，则执行写事件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(channel.event==read)&#123;</span><br><span class="line">        getChannelHandler(channel).channelReadable(channel);<span class="comment">//如果可以读，则执行读事件</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> Map&lt;Channel，ChannelHandler&gt; handlerMap;<span class="comment">//所有channel的对应事件处理器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序很简短，也是最简单的Reactor模式：注册所有感兴趣的事件处理器，单线程轮询选择就绪事件，执行事件处理器。</p><h2 id="优化线程模型"><a href="#优化线程模型" class="headerlink" title="优化线程模型"></a>优化线程模型</h2><p>由上面的示例我们大概可以总结出NIO是怎么解决掉线程的瓶颈并处理海量连接的：</p><p>NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。</p><p>并且由于线程的节约，连接数大的时候因为线程切换带来的问题也随之解决，进而为处理海量连接提供了可能。</p><p>单线程处理I/O的效率确实非常高，没有线程切换，只是拼命的读、写、选择事件。但现在的服务器，一般都是多核处理器，如果能够利用多核心进行I/O，无疑对效率会有更大的提高。</p><p>仔细分析一下我们需要的线程，其实主要包括以下几种：</p><ol><li>事件分发器，单线程选择就绪的事件。</li><li>I/O处理器，包括connect、read、write等，这种纯CPU操作，一般开启CPU核心个线程就可以。</li><li>业务线程，在处理完I/O后，业务一般还会有自己的业务逻辑，有的还会有其他的阻塞I/O，如DB操作，RPC等。只要有阻塞，就需要单独的线程。</li></ol><p>Java的Selector对于Linux系统来说，有一个致命限制：同一个channel的select不能被并发的调用。因此，如果有多个I/O线程，必须保证：一个socket只能属于一个IoThread，而一个IoThread可以管理多个socket。</p><p>另外连接的处理和读写的处理通常可以选择分开，这样对于海量连接的注册和读写就可以分发。虽然read()和write()是比较高效无阻塞的函数，但毕竟会占用CPU，如果面对更高的并发则无能为力。</p><p><img src="/images/java/reactor.png" alt="emma_1"></p><h1 id="NIO在客户端的魔力"><a href="#NIO在客户端的魔力" class="headerlink" title="NIO在客户端的魔力"></a>NIO在客户端的魔力</h1><p>通过上面的分析，可以看出NIO在服务端对于解放线程，优化I/O和处理海量连接方面，确实有自己的用武之地。那么在客户端上，NIO又有什么使用场景呢?</p><p>常见的客户端BIO+连接池模型，可以建立n个连接，然后当某一个连接被I/O占用的时候，可以使用其他连接来提高性能。</p><p>但多线程的模型面临和服务端相同的问题：如果指望增加连接数来提高性能，则连接数又受制于线程数、线程很贵、无法建立很多线程，则性能遇到瓶颈。</p><h2 id="每连接顺序请求的Redis"><a href="#每连接顺序请求的Redis" class="headerlink" title="每连接顺序请求的Redis"></a>每连接顺序请求的Redis</h2><p>对于Redis来说，由于服务端是全局串行的，能够保证同一连接的所有请求与返回顺序一致。这样可以使用单线程＋队列，把请求数据缓冲。然后pipeline发送，返回future，然后channel可读时，直接在队列中把future取回来，done()就可以了。</p><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisClient</span> <span class="title">Implements</span> <span class="title">ChannelHandler</span></span>&#123;</span><br><span class="line"> <span class="keyword">private</span> BlockingQueue CmdQueue;</span><br><span class="line"> <span class="keyword">private</span> EventLoop eventLoop;</span><br><span class="line"> <span class="keyword">private</span> Channel channel;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Cmd</span></span>&#123;</span><br><span class="line">  String cmd;</span><br><span class="line">  Future result;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Future <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">   Cmd cmd= <span class="keyword">new</span> Cmd(key);</span><br><span class="line">   queue.offer(cmd);</span><br><span class="line">   eventLoop.submit(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        queue.drainTo(list);</span><br><span class="line">        <span class="keyword">if</span>(channel.isWritable())&#123;</span><br><span class="line">         channel.writeAndFlush(list);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChannelReadFinish</span><span class="params">(Channel channel，Buffer Buffer)</span></span>&#123;</span><br><span class="line">    List result = handleBuffer();<span class="comment">//处理数据</span></span><br><span class="line">    <span class="comment">//从cmdQueue取出future，并设值，future.done();</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChannelWritable</span><span class="params">(Channel channel)</span></span>&#123;</span><br><span class="line">   channel.flush();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做，能够充分的利用pipeline来提高I/O能力，同时获取异步处理能力。</p><h2 id="多连接短连接的HttpClient"><a href="#多连接短连接的HttpClient" class="headerlink" title="多连接短连接的HttpClient"></a>多连接短连接的HttpClient</h2><p>类似于竞对抓取的项目，往往需要建立无数的HTTP短连接，然后抓取，然后销毁，当需要单机抓取上千网站线程数又受制的时候，怎么保证性能呢?</p><p>何不尝试NIO，单线程进行连接、写、读操作？如果连接、读、写操作系统没有能力处理，简单的注册一个事件，等待下次循环就好了。</p><p>如何存储不同的请求/响应呢？由于http是无状态没有版本的协议，又没有办法使用队列，好像办法不多。比较笨的办法是对于不同的socket，直接存储socket的引用作为map的key。</p><h2 id="常见的RPC框架，如Thrift，Dubbo"><a href="#常见的RPC框架，如Thrift，Dubbo" class="headerlink" title="常见的RPC框架，如Thrift，Dubbo"></a>常见的RPC框架，如Thrift，Dubbo</h2><p>这种框架内部一般维护了请求的协议和请求号，可以维护一个以请求号为key，结果的result为future的map，结合NIO+长连接，获取非常不错的性能。</p><h1 id="NIO高级主题"><a href="#NIO高级主题" class="headerlink" title="NIO高级主题"></a>NIO高级主题</h1><h2 id="Proactor与Reactor"><a href="#Proactor与Reactor" class="headerlink" title="Proactor与Reactor"></a>Proactor与Reactor</h2><p>一般情况下，I/O 复用机制需要事件分发器（event dispatcher）。 事件分发器的作用，即将那些读写事件源分发给各读写事件的处理者，就像送快递的在楼下喊: 谁谁谁的快递到了， 快来拿吧！开发人员在开始的时候需要在分发器那里注册感兴趣的事件，并提供相应的处理者（event handler)，或者是回调函数；事件分发器在适当的时候，会将请求的事件分发给这些handler或者回调函数。</p><p>涉及到事件分发器的两种模式称为：Reactor和Proactor。 Reactor模式是基于同步I/O的，而Proactor模式是和异步I/O相关的。在Reactor模式中，事件分发器等待某个事件或者可应用或个操作的状态发生（比如文件描述符可读写，或者是socket可读写），事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。</p><p>而在Proactor模式中，事件处理者（或者代由事件分发器发起）直接发起一个异步读写操作（相当于请求），而实际的工作是由操作系统来完成的。发起时，需要提供的参数包括用于存放读到数据的缓存区、读的数据大小或用于存放外发数据的缓存区，以及这个请求完后的回调函数等信息。事件分发器得知了这个请求，它默默等待这个请求的完成，然后转发完成事件给相应的事件处理者或者回调。举例来说，在Windows上事件处理者投递了一个异步IO操作（称为overlapped技术），事件分发器等IO Complete事件完成。这种异步模式的典型实现是基于操作系统底层异步API的，所以我们可称之为“系统级别”的或者“真正意义上”的异步，因为具体的读写是由操作系统代劳的。</p><p>举个例子，将有助于理解Reactor与Proactor二者的差异，以读操作为例（写操作类似）。</p><h3 id="在Reactor中实现读"><a href="#在Reactor中实现读" class="headerlink" title="在Reactor中实现读"></a>在Reactor中实现读</h3><ul><li>注册读就绪事件和相应的事件处理器。</li><li>事件分发器等待事件。</li><li>事件到来，激活分发器，分发器调用事件对应的处理器。</li><li>事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li></ul><h3 id="在Proactor中实现读："><a href="#在Proactor中实现读：" class="headerlink" title="在Proactor中实现读："></a>在Proactor中实现读：</h3><ul><li>处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。</li><li>事件分发器等待操作完成事件。</li><li>在分发器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分发器读操作完成。</li><li>事件分发器呼唤处理器。</li><li>事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分发器。</li></ul><p>可以看出，两个模式的相同点，都是对某个I/O事件的事件通知（即告诉某个模块，这个I/O操作可以进行或已经完成)。在结构上，两者也有相同点：事件分发器负责提交IO操作（异步)、查询设备是否可操作（同步)，然后当条件满足时，就回调handler；不同点在于，异步情况下（Proactor)，当回调handler时，表示I/O操作已经完成；同步情况下（Reactor)，回调handler时，表示I/O设备可以进行某个操作（can read 或 can write)。</p><p>下面，我们将尝试应对为Proactor和Reactor模式建立可移植框架的挑战。在改进方案中，我们将Reactor原来位于事件处理器内的Read/Write操作移至分发器（不妨将这个思路称为“模拟异步”），以此寻求将Reactor多路同步I/O转化为模拟异步I/O。以读操作为例子，改进过程如下：</p><ul><li>注册读就绪事件和相应的事件处理器。并为分发器提供数据缓冲区地址，需要读取数据量等信息。</li><li>分发器等待事件（如在select()上等待）。</li><li>事件到来，激活分发器。分发器执行一个非阻塞读操作（它有完成这个操作所需的全部信息），最后调用对应处理器。</li><li>事件处理器处理用户自定义缓冲区的数据，注册新的事件（当然同样要给出数据缓冲区地址，需要读取的数据量等信息），最后将控制权返还分发器。<br>如我们所见，通过对多路I/O模式功能结构的改造，可将Reactor转化为Proactor模式。改造前后，模型实际完成的工作量没有增加，只不过参与者间对工作职责稍加调换。没有工作量的改变，自然不会造成性能的削弱。对如下各步骤的比较，可以证明工作量的恒定：</li></ul><h3 id="标准-典型的Reactor："><a href="#标准-典型的Reactor：" class="headerlink" title="标准/典型的Reactor："></a>标准/典型的Reactor：</h3><ul><li>步骤1：等待事件到来（Reactor负责）。</li><li>步骤2：将读就绪事件分发给用户定义的处理器（Reactor负责）。</li><li>步骤3：读数据（用户处理器负责）。</li><li>步骤4：处理数据（用户处理器负责）。</li></ul><h3 id="改进实现的模拟Proactor："><a href="#改进实现的模拟Proactor：" class="headerlink" title="改进实现的模拟Proactor："></a>改进实现的模拟Proactor：</h3><ul><li><p>步骤1：等待事件到来（Proactor负责）。</p></li><li><p>步骤2：得到读就绪事件，执行读数据（现在由Proactor负责）。</p></li><li><p>步骤3：将读完成事件分发给用户处理器（Proactor负责）。</p></li><li><p>步骤4：处理数据（用户处理器负责）。</p><p>对于不提供异步I/O API的操作系统来说，这种办法可以隐藏Socket API的交互细节，从而对外暴露一个完整的异步接口。借此，我们就可以进一步构建完全可移植的，平台无关的，有通用对外接口的解决方案。</p></li></ul><p>代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ChannelHandler</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">channelReadComplate</span><span class="params">(Channel channel，<span class="keyword">byte</span>[] data)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">channelWritable</span><span class="params">(Channel channel)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Channel</span></span>&#123;</span><br><span class="line">     Socket socket;</span><br><span class="line">     Event event;<span class="comment">//读，写或者连接</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//IO线程主循环：</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">IoThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Channel channel;</span><br><span class="line">   <span class="keyword">while</span>(channel=Selector.select())&#123;<span class="comment">//选择就绪的事件和对应的连接</span></span><br><span class="line">      <span class="keyword">if</span>(channel.event==accept)&#123;</span><br><span class="line">         registerNewChannelHandler(channel);<span class="comment">//如果是新连接，则注册一个新的读写处理器</span></span><br><span class="line">         Selector.interested(read);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(channel.event==write)&#123;</span><br><span class="line">         getChannelHandler(channel).channelWritable(channel);<span class="comment">//如果可以写，则执行写事件</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(channel.event==read)&#123;</span><br><span class="line">          <span class="keyword">byte</span>[] data = channel.read();</span><br><span class="line">          <span class="keyword">if</span>(channel.read()==<span class="number">0</span>)<span class="comment">//没有读到数据，表示本次数据读完了</span></span><br><span class="line">          &#123;</span><br><span class="line">          getChannelHandler(channel).channelReadComplate(channel，data;<span class="comment">//处理读完成事件</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(过载保护)&#123;</span><br><span class="line">          Selector.interested(read);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   Map&lt;Channel，ChannelHandler&gt; handlerMap;<span class="comment">//所有channel的对应事件处理器</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="Selector-wakeup"><a href="#Selector-wakeup" class="headerlink" title="Selector.wakeup()"></a>Selector.wakeup()</h2><h3 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h3><p>解除阻塞在Selector.select()/select(long)上的线程，立即返回。</p><p>两次成功的select之间多次调用wakeup等价于一次调用。</p><p>如果当前没有阻塞在select上，则本次wakeup调用将作用于下一次select——“记忆”作用。</p><p>为什么要唤醒？</p><p>注册了新的channel或者事件。</p><p>channel关闭，取消注册。</p><p>优先级更高的事件触发（如定时器事件），希望及时处理。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Linux上利用pipe调用创建一个管道，Windows上则是一个loopback的tcp连接。这是因为win32的管道无法加入select的fd set，将管道或者TCP连接加入select fd set。</p><p>wakeup往管道或者连接写入一个字节，阻塞的select因为有I/O事件就绪，立即返回。可见，wakeup的调用开销不可忽视。</p><h2 id="Buffer的选择"><a href="#Buffer的选择" class="headerlink" title="Buffer的选择"></a>Buffer的选择</h2><p>通常情况下，操作系统的一次写操作分为两步：</p><ol><li>将数据从用户空间拷贝到系统空间。</li><li>从系统空间往网卡写。同理，读操作也分为两步：<br>① 将数据从网卡拷贝到系统空间；<br>② 将数据从系统空间拷贝到用户空间。</li></ol><p>对于NIO来说，缓存的使用可以使用DirectByteBuffer和HeapByteBuffer。如果使用了DirectByteBuffer，一般来说可以减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高，更不宜维护，通常会用内存池来提高性能。</p><p>如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer；反之可以用directBuffer。</p><h1 id="NIO存在的问题"><a href="#NIO存在的问题" class="headerlink" title="NIO存在的问题"></a>NIO存在的问题</h1><p>使用NIO != 高性能，当连接数&lt;1000，并发程度不高或者局域网环境下NIO并没有显著的性能优势。</p><p>NIO并没有完全屏蔽平台差异，它仍然是基于各个操作系统的I/O系统实现的，差异仍然存在。使用NIO做网络编程构建事件驱动模型并不容易，陷阱重重。</p><p>推荐大家使用成熟的NIO框架，如Netty，MINA等。解决了很多NIO的陷阱，并屏蔽了操作系统的差异，有较好的性能和编程模型。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后总结一下到底NIO给我们带来了些什么：</p><blockquote><ul><li>事件驱动模型</li><li>避免多线程</li><li>单线程处理多任务</li><li>非阻塞I/O，I/O读写不再阻塞，而是返回0</li><li>基于block的传输，通常比基于流的传输更高效</li><li>更高级的IO函数，zero-copy</li><li>IO多路复用大大提高了Java网络应用的可伸缩性和实用性</li></ul></blockquote><p>本文抛砖引玉，诠释了一些NIO的思想和设计理念以及应用场景，这只是从冰山一角。关于NIO可以谈的技术点其实还有很多，期待未来有机会和大家继续探讨。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">https://tech.meituan.com/nio.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;NIO（Non-blocking I/O，在Java领域，也称为New I/O），是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。&lt;/p&gt;
&lt;p&gt;那么NIO的本质是什么样的呢？
      
    
    </summary>
    
      <category term="java" scheme="http://www.iforfee.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL事务隔离级别</title>
    <link href="http://www.iforfee.com/mysql/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://www.iforfee.com/mysql/MySQL事务隔离级别/</id>
    <published>2018-05-08T10:17:51.000Z</published>
    <updated>2018-05-08T10:24:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务隔离级别介绍"><a href="#事务隔离级别介绍" class="headerlink" title="事务隔离级别介绍"></a>事务隔离级别介绍</h3><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读（Read uncommitted）</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>已提交读（Read committed）</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>可重复读（Repeatable read）</td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td>可串行化（Serializable ）</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><ol><li>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</li><li>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)</li><li>可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读，但是innoDB解决了幻读</li><li>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li></ol><p>接下来一次来验证每个隔离级别的特性,首先我们先建一张表,我们建立账户表account用来测试我们的事务隔离级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE account (</span><br><span class="line">    `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    `customer_name` varchar(255) NOT NULL,</span><br><span class="line">    `money` int(11) NOT NULL,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    UNIQUE `uniq_name` USING BTREE (customer_name)</span><br><span class="line">) ENGINE=`InnoDB` AUTO_INCREMENT=10 DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci ROW_FORMAT=COMPACT</span><br></pre></td></tr></table></figure><h3 id="RU-（read-uncommitted）读未提交隔离级别"><a href="#RU-（read-uncommitted）读未提交隔离级别" class="headerlink" title="RU （read uncommitted）读未提交隔离级别"></a>RU （read uncommitted）读未提交隔离级别</h3><p>首先我们开启Console A,然后设置session事务隔离级别为read uncommitted; 然后同样开启Console B，设置成read uncommitted;</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session transaction isolation level read uncommitted;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; select @@session.tx_isolation;</span><br><span class="line">+------------------------+</span><br><span class="line">| @@session.tx_isolation |</span><br><span class="line">+------------------------+</span><br><span class="line">| READ-UNCOMMITTED       |</span><br><span class="line">+------------------------+</span><br><span class="line">1 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure><p>我们两个console的事务隔离级别都是read uncommitted，下面测试RU级别会发生的情况</p><p><img src="/images/mysql/Center.png" alt="img"></p><p>小结：</p><p>可以发现RU模式下，一个事务可以读取到另一个未提交(commit)的数据，导致了脏读。如果B事务回滚了，就会造成数据的不一致。RU是事务隔离级别最低的。</p><h3 id="RC-（read-committed）读提交隔离级别"><a href="#RC-（read-committed）读提交隔离级别" class="headerlink" title="RC （read committed）读提交隔离级别"></a>RC （read committed）读提交隔离级别</h3><p>现在我们将事务隔离级别设置成RC (read committed)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure><p><img src="/images/mysql/Center-20180508175250914.png" alt="img"></p><p><img src="/images/mysql/Center-20180508175300689.png" alt="img"></p><p><strong>小结</strong></p><p>我们在RC模式下，可以发现。在console B没有提交数据修改的commit的时候，console A是读不到修改后的数据的，这就避免了在RU模式中的脏读，但是有一个问题我们会发现，在console A同一个事务中。两次select的数据不一样，这就存在了不可重复读的问题.PS：RC事务隔离级别是Oracle数据库的默认隔离级别.</p><h3 id="RR-（Repeatable-read）可重复读隔离级别"><a href="#RR-（Repeatable-read）可重复读隔离级别" class="headerlink" title="RR （Repeatable read）可重复读隔离级别"></a>RR （Repeatable read）可重复读隔离级别</h3><p><img src="/images/mysql/Center-20180508175513077.png" alt="img"></p><p><img src="/images/mysql/Center-20180508175519872.png" alt="img"></p><p><strong>小结</strong></p><p>在RR级别中，我们解决了不可重复读的问题，即在这种隔离级别下，在一个事务中我们能够保证能够获取到一样的数据（即使已经有其他事务修改了我们的数据）。但是无法避免幻读，幻读简单的解释就是在数据有新增的时候，也无法保证两次得到的数据不一致，但是不同数据库对不同的RR级别有不同的实现，有时候或加上间隙锁来避免幻读。</p><h4 id="innoDB-解决了幻读"><a href="#innoDB-解决了幻读" class="headerlink" title="innoDB 解决了幻读"></a>innoDB 解决了幻读</h4><p>前面的定义中RR级别是可能产生幻读，这是在传统的RR级别定义中会出现的。但是在innoDB引擎中利用MVCC多版本并发控制解决了这个问题</p><p><img src="/images/mysql/Center-20180508175657821.png" alt="img"></p><p><img src="/images/mysql/Center-20180508175702867.png" alt="img"></p><p>这算是幻读吗？在标准的RR隔离级别定义中是无法解决幻读问题的，比如我要保证可重复读，那么我们可以在我们的结果集的范围加一个锁（between 1 and 11），防止数据更改.但是我们毕竟不是锁住真个表，所以insert数据我们并不能保证他不插入。所以是有幻读的问题存在的。但是innodb引擎解决了幻读的问题，基于MVCC（多版本并发控制）:在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。所以当我们执行update的时候，当前事务的版本号已经更新了？所以也算是幻读？？(存疑)主要是gap间隙锁+MVCC解决幻读问题？</p><h3 id="Serializable-串行化隔离级别"><a href="#Serializable-串行化隔离级别" class="headerlink" title="Serializable 串行化隔离级别"></a>Serializable 串行化隔离级别</h3><p>所有事物串行,最高隔离级别，性能最差</p><h3 id="存在的问题？"><a href="#存在的问题？" class="headerlink" title="存在的问题？"></a>存在的问题？</h3><p>在RR模型,我们虽然避免了幻读，但是存在一个问题，我们得到的数据不是数据中实时的数据，如果是对实时数据比较敏感的业务，这是不现实的。<br>对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库当前版本数据的方式，叫当前读 (current read)。很显然，在MVCC中：</p><p>快照读：就是select</p><ul><li>select * from table ….;</li></ul><p>当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。</p><ul><li>select * from table where ? lock in share mode;</li><li>select * from table where ? for update;</li><li>insert;</li><li>update ;</li><li>delete;</li></ul><p>事务的隔离级别实际上都是定义了当前读的级别，MySQL为了减少锁处理（包括等待其它锁）的时间，提升并发能力，引入了快照读的概念，使得select不用加锁。而update、insert这些“当前读”，就需要另外的模块来解决了。</p><p>比如，我们有以下的订单业务场景，我们队一个商品下单的操作，我们得首先检查这个订单的数量还剩多少，然后下单。</p><p> 事务1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select num from t_goods where id=1;</span><br><span class="line">update t_goods set num=num-$mynum where id=1;</span><br></pre></td></tr></table></figure><p>事务2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select num from t_goods where id=1;</span><br><span class="line">update t_goods set num=num-$mynum where id=1;</span><br></pre></td></tr></table></figure><p>假设这个时候数量只有1，我们下单也是只有1.如果在并发的情况下，事务1查询到还有一单准备下单，但是这个时候事务2已经提交了。订单变成0.这个事务1在执行update，就会造成事故。</p><ol><li>解决问题方法1(悲观锁)：就是利用for update对着个商品加锁，事务完成之后释放锁。切记where条件的有索引，否则会锁全表。</li><li>解决方法2(乐观锁)：给数据库表加上个version字段。然后SQL改写:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select num,version from t_goods where id=1;</span><br><span class="line">update t_goods set num=num-1,version=verison+1 where id=1 and version=$&#123;version&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/a837199685/article/details/54563740" target="_blank" rel="noopener">MySQL事务隔离级别和Spring事务关系介绍</a></p><p><a href="https://github.com/Yhzhtk/note/issues/42" target="_blank" rel="noopener">Innodb 中 RR 隔离级别能否防止幻读？</a></p><p><a href="http://hedengcheng.com/?p=771" target="_blank" rel="noopener">MySQL 加锁处理分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;事务隔离级别介绍&quot;&gt;&lt;a href=&quot;#事务隔离级别介绍&quot; class=&quot;headerlink&quot; title=&quot;事务隔离级别介绍&quot;&gt;&lt;/a&gt;事务隔离级别介绍&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;隔离级别&lt;/th&gt;
&lt;th&gt;脏读&lt;/th&gt;
&lt;t
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.iforfee.com/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>eventloop</title>
    <link href="http://www.iforfee.com/eventloop/"/>
    <id>http://www.iforfee.com/eventloop/</id>
    <published>2018-05-08T07:04:47.000Z</published>
    <updated>2018-05-08T07:05:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty-源码分析之-三-我就是大名鼎鼎的-EventLoop"><a href="#Netty-源码分析之-三-我就是大名鼎鼎的-EventLoop" class="headerlink" title="Netty 源码分析之 三 我就是大名鼎鼎的 EventLoop"></a>Netty 源码分析之 三 我就是大名鼎鼎的 EventLoop</h1><p>@(Netty)[Netty, 源码分析]</p><p>[TOC]</p><hr><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>这一章是 Netty 源码分析 的第三章, 我将在这一章中大家一起探究一下 Netty 的 EventLoop 的底层原理, 让大家对 Netty 的线程模型有更加深入的了解.</p><h2 id="NioEventLoopGroup"><a href="#NioEventLoopGroup" class="headerlink" title="NioEventLoopGroup"></a>NioEventLoopGroup</h2><p>在 <a href="https://segmentfault.com/a/1190000007282789" target="_blank" rel="noopener">Netty 源码分析之 一 揭开 Bootstrap 神秘的红盖头 (客户端)</a> 章节中我们已经知道了, 一个 Netty 程序启动时, 至少要指定一个 EventLoopGroup(如果使用到的是  NIO, 那么通常是 NioEventLoopGroup), 那么这个 NioEventLoopGroup 在 Netty 中到底扮演着什么角色呢? 我们知道, Netty 是 Reactor 模型的一个实现, 那么首先从 Reactor 的线程模型开始吧.</p><h3 id="关于-Reactor-的线程模型"><a href="#关于-Reactor-的线程模型" class="headerlink" title="关于 Reactor 的线程模型"></a>关于 Reactor 的线程模型</h3><p>首先我们来看一下 Reactor 的线程模型.<br>Reactor 的线程模型有三种:</p><ul><li>单线程模型</li><li>多线程模型</li><li>主从多线程模型</li></ul><p>首先来看一下 <strong>单线程模型</strong>:<br><img src="./Reactor 单线程模型.png" alt="Alt text"></p><p>所谓单线程, 即 acceptor 处理和 handler 处理都在一个线程中处理. 这个模型的坏处显而易见: 当其中某个 handler 阻塞时, 会导致其他所有的 client 的 handler 都得不到执行, 并且更严重的是, handler 的阻塞也会导致整个服务不能接收新的 client 请求(因为 acceptor 也被阻塞了). 因为有这么多的缺陷, 因此单线程Reactor 模型用的比较少.</p><p>那么什么是 <strong>多线程模型</strong> 呢? Reactor 的多线程模型与单线程模型的区别就是 acceptor 是一个单独的线程处理, 并且有一组特定的 NIO 线程来负责各个客户端连接的 IO 操作. Reactor 多线程模型如下:<br><img src="./Reactor 多线程模型.png" alt="Alt text"></p><p>Reactor 多线程模型 有如下特点:</p><ul><li>有专门一个线程, 即 Acceptor 线程用于监听客户端的TCP连接请求.</li><li>客户端连接的 IO 操作都是由一个特定的 NIO 线程池负责. 每个客户端连接都与一个特定的 NIO 线程绑定, 因此在这个客户端连接中的所有 IO 操作都是在同一个线程中完成的.</li><li>客户端连接有很多, 但是 NIO 线程数是比较少的, 因此一个 NIO 线程可以同时绑定到多个客户端连接中.</li></ul><p>接下来我们再来看一下 Reactor 的主从多线程模型.<br>一般情况下, Reactor 的多线程模式已经可以很好的工作了, 但是我们考虑一下如下情况: 如果我们的服务器需要同时处理大量的客户端连接请求或我们需要在客户端连接时, 进行一些权限的检查, 那么单线程的 Acceptor 很有可能就处理不过来, 造成了大量的客户端不能连接到服务器.<br>Reactor 的主从多线程模型就是在这样的情况下提出来的, 它的特点是: 服务器端接收客户端的连接请求不再是一个线程, 而是由一个独立的线程池组成. 它的线程模型如下:<br><img src="./Reactor 主从多线程模型.png" alt="Alt text"></p><p>可以看到, Reactor 的主从多线程模型和 Reactor 多线程模型很类似, 只不过 Reactor 的主从多线程模型的 acceptor 使用了线程池来处理大量的客户端请求.</p><h3 id="NioEventLoopGroup-与-Reactor-线程模型的对应"><a href="#NioEventLoopGroup-与-Reactor-线程模型的对应" class="headerlink" title="NioEventLoopGroup 与 Reactor 线程模型的对应"></a>NioEventLoopGroup 与 Reactor 线程模型的对应</h3><p>我们介绍了三种 Reactor 的线程模型, 那么它们和 NioEventLoopGroup 又有什么关系呢? 其实, 不同的设置 NioEventLoopGroup 的方式就对应了不同的 Reactor 的线程模型.</p><h4 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h4><p>来看一下下面的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = new NioEventLoopGroup(1);</span><br><span class="line">ServerBootstrap b = new ServerBootstrap();</span><br><span class="line">b.group(bossGroup)</span><br><span class="line"> .channel(NioServerSocketChannel.class)</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></p><p>注意, 我们实例化了一个 NioEventLoopGroup, 构造器参数是1, 表示 NioEventLoopGroup 的线程池大小是1. 然后接着我们调用 <strong>b.group(bossGroup)</strong> 设置了服务器端的 EventLoopGroup. 有些朋友可能会有疑惑: 我记得在启动服务器端的 Netty 程序时, 是需要设置 bossGroup 和 workerGroup 的, 为什么这里就只有一个 bossGroup?<br>其实很简单, ServerBootstrap 重写了 group 方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ServerBootstrap group(EventLoopGroup group) &#123;</span><br><span class="line">    return group(group, group);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此当传入一个 group 时, 那么 bossGroup 和 workerGroup 就是同一个 NioEventLoopGroup 了.<br>这时候呢, 因为 bossGroup 和 workerGroup 就是同一个 NioEventLoopGroup, 并且这个 NioEventLoopGroup 只有一个线程, 这样就会导致 Netty 中的 acceptor 和后续的所有客户端连接的 IO 操作都是在一个线程中处理的. 那么对应到 Reactor 的线程模型中, 我们这样设置 NioEventLoopGroup 时, 就相当于 <strong>Reactor 单线程模型</strong>.</p><h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><p>同理, 再来看一下下面的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = new NioEventLoopGroup(1);</span><br><span class="line">EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line">ServerBootstrap b = new ServerBootstrap();</span><br><span class="line">b.group(bossGroup, workerGroup)</span><br><span class="line"> .channel(NioServerSocketChannel.class)</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></p><p>bossGroup 中只有一个线程, 而 workerGroup 中的线程是 CPU 核心数乘以2, 因此对应的到 Reactor 线程模型中, 我们知道, 这样设置的 NioEventLoopGroup 其实就是 <strong>Reactor 多线程模型</strong>.</p><h4 id="主从多线程模型"><a href="#主从多线程模型" class="headerlink" title="主从多线程模型"></a>主从多线程模型</h4><p><del>相信读者朋友都想到了, 实现主从线程模型的例子如下:</del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = new NioEventLoopGroup(4);</span><br><span class="line">EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line">ServerBootstrap b = new ServerBootstrap();</span><br><span class="line">b.group(bossGroup, workerGroup)</span><br><span class="line"> .channel(NioServerSocketChannel.class)</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure></p><p><del>bossGroup 线程池中的线程数我们设置为4, 而 workerGroup 中的线程是 CPU 核心数乘以2, 因此对应的到 Reactor 线程模型中, 我们知道, 这样设置的 NioEventLoopGroup 其实就是 <strong>Reactor 主从多线程模型</strong>.</del></p><hr><p>根据 @labmem 的提示, Netty 的服务器端的 acceptor 阶段, 没有使用到多线程, 因此上面的 <code>主从多线程模型</code> 在 Netty 的服务器端是不存在的.</p><p>服务器端的 ServerSocketChannel 只绑定到了 bossGroup 中的一个线程, 因此在调用 Java NIO 的 Selector.select 处理客户端的连接请求时, 实际上是在一个线程中的, 所以对只有一个服务的应用来说, bossGroup 设置多个线程是没有什么作用的, 反而还会造成资源浪费.</p><p>经 Google, Netty 中的 bossGroup 为什么使用线程池的原因大家众所纷纭, 不过我在 <a href="http://stackoverflow.com/questions/34275138/why-do-we-really-need-multiple-netty-boss-threads" target="_blank" rel="noopener">stackoverflow</a> 上找到一个比较靠谱的答案:</p><blockquote><p>the creator of Netty says multiple boss threads are useful if we share NioEventLoopGroup between different server bootstraps, but I don’t see the reason for it.<br>因此上面的 <code>主从多线程模型</code> 分析是有问题, 抱歉.</p></blockquote><h3 id="NioEventLoopGroup-类层次结构"><a href="#NioEventLoopGroup-类层次结构" class="headerlink" title="NioEventLoopGroup 类层次结构"></a>NioEventLoopGroup 类层次结构</h3><p><img src="./NioEventLoopGroup.png" alt="Alt text"></p><h3 id="NioEventLoopGroup-实例化过程"><a href="#NioEventLoopGroup-实例化过程" class="headerlink" title="NioEventLoopGroup 实例化过程"></a>NioEventLoopGroup 实例化过程</h3><p>在前面 <a href="https://segmentfault.com/a/1190000007282789#articleHeader7" target="_blank" rel="noopener">Netty 源码分析之 一 揭开 Bootstrap 神秘的红盖头 (客户端)</a> 章节中, 我们已经简单地介绍了一下 NioEventLoopGroup 的初始化过程, 这里再回顾一下:<br><img src="./NioEventLoopGroup 初始化顺序图.png" alt="Alt text"><br><a href="https://github.com/yongshun/learn_netty_source_code/blob/master/Netty%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%20%E4%B8%89%20%E6%88%91%E5%B0%B1%E6%98%AF%E5%A4%A7%E5%90%8D%E9%BC%8E%E9%BC%8E%E7%9A%84%20EventLoop/NioEventLoopGroup%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E5%9B%BE.png" target="_blank" rel="noopener">点此下载原图</a></p><p>即:</p><ul><li>EventLoopGroup(其实是MultithreadEventExecutorGroup) 内部维护一个类型为 EventExecutor children 数组, 其大小是 nThreads, 这样就构成了一个线程池</li><li>如果我们在实例化 NioEventLoopGroup 时, 如果指定线程池大小, 则 nThreads 就是指定的值, 反之是处理器核心数 * 2</li><li>MultithreadEventExecutorGroup 中会调用 newChild 抽象方法来初始化 children 数组</li><li>抽象方法 newChild 是在 NioEventLoopGroup 中实现的, 它返回一个 NioEventLoop 实例.</li><li>NioEventLoop 属性:<ul><li>SelectorProvider provider 属性: NioEventLoopGroup 构造器中通过 SelectorProvider.provider() 获取一个 SelectorProvider</li><li>Selector selector 属性: NioEventLoop 构造器中通过调用通过 selector = provider.openSelector() 获取一个 selector 对象.</li></ul></li></ul><h2 id="NioEventLoop"><a href="#NioEventLoop" class="headerlink" title="NioEventLoop"></a>NioEventLoop</h2><p>NioEventLoop 继承于 SingleThreadEventLoop, 而 SingleThreadEventLoop 又继承于 SingleThreadEventExecutor. SingleThreadEventExecutor 是 Netty 中对本地线程的抽象, 它内部有一个 Thread thread 属性, 存储了一个本地 Java 线程. 因此我们可以认为, 一个 NioEventLoop 其实和一个特定的线程绑定, 并且在其生命周期内, 绑定的线程都不会再改变.</p><h3 id="NioEventLoop-类层次结构"><a href="#NioEventLoop-类层次结构" class="headerlink" title="NioEventLoop 类层次结构"></a>NioEventLoop 类层次结构</h3><p><img src="./NioEventLoop.png" alt="Alt text"><br>NioEventLoop 的类层次结构图还是比较复杂的, 不过我们只需要关注几个重要的点即可. 首先 NioEventLoop 的继承链如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoop -&gt; SingleThreadEventLoop -&gt; SingleThreadEventExecutor -&gt; AbstractScheduledEventExecutor</span><br></pre></td></tr></table></figure></p><p>在 AbstractScheduledEventExecutor 中, Netty 实现了 NioEventLoop 的 schedule 功能, 即我们可以通过调用一个 NioEventLoop 实例的 schedule 方法来运行一些定时任务. 而在 SingleThreadEventLoop 中, 又实现了任务队列的功能, 通过它, 我们可以调用一个 NioEventLoop 实例的 execute 方法来向任务队列中添加一个 task, 并由 NioEventLoop 进行调度执行.</p><p>通常来说, NioEventLoop 肩负着两种任务, 第一个是作为 IO 线程, 执行与 Channel 相关的 IO 操作, 包括 调用 select 等待就绪的 IO 事件、读写数据与数据的处理等; 而第二个任务是作为任务队列, 执行 taskQueue 中的任务, 例如用户调用 eventLoop.schedule 提交的定时任务也是这个线程执行的.</p><h3 id="NioEventLoop-的实例化过程"><a href="#NioEventLoop-的实例化过程" class="headerlink" title="NioEventLoop 的实例化过程"></a>NioEventLoop 的实例化过程</h3><p><img src="./NioEventLoop 实例化顺序图.png" alt="Alt text"><br><a href="https://github.com/yongshun/learn_netty_source_code/blob/master/Netty%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%20%E4%B8%89%20%E6%88%91%E5%B0%B1%E6%98%AF%E5%A4%A7%E5%90%8D%E9%BC%8E%E9%BC%8E%E7%9A%84%20EventLoop/NioEventLoop%20%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E5%9B%BE.png" target="_blank" rel="noopener">点此下载原图</a></p><p>从上图可以看到, SingleThreadEventExecutor 有一个名为 <strong>thread</strong> 的 Thread 类型字段, 这个字段就代表了与 SingleThreadEventExecutor 关联的本地线程.<br>下面是这个构造器的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">protected SingleThreadEventExecutor(</span><br><span class="line">        EventExecutorGroup parent, ThreadFactory threadFactory, boolean addTaskWakesUp) &#123;</span><br><span class="line">    this.parent = parent;</span><br><span class="line">    this.addTaskWakesUp = addTaskWakesUp;</span><br><span class="line"></span><br><span class="line">    thread = threadFactory.newThread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            boolean success = false;</span><br><span class="line">            updateLastExecutionTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                SingleThreadEventExecutor.this.run();</span><br><span class="line">                success = true;</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                logger.warn(&quot;Unexpected exception from an event executor: &quot;, t);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 省略清理代码</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    threadProperties = new DefaultThreadProperties(thread);</span><br><span class="line">    taskQueue = newTaskQueue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 SingleThreadEventExecutor 构造器中, 通过 <strong>threadFactory.newThread</strong> 创建了一个新的 Java 线程. 在这个线程中所做的事情主要就是调用 <strong>SingleThreadEventExecutor.this.run()</strong> 方法, 而因为 NioEventLoop 实现了这个方法, 因此根据多态性, 其实调用的是 <strong>NioEventLoop.run()</strong> 方法.</p><h3 id="EventLoop-与-Channel-的关联"><a href="#EventLoop-与-Channel-的关联" class="headerlink" title="EventLoop 与 Channel 的关联"></a>EventLoop 与 Channel 的关联</h3><p>Netty 中, 每个 Channel 都有且仅有一个 EventLoop 与之关联, 它们的关联过程如下:<br><img src="./NioEventLoop 与 Channel 的关联过程.png" alt="Alt text"><br><a href="https://github.com/yongshun/learn_netty_source_code/blob/master/Netty%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%20%E4%B8%89%20%E6%88%91%E5%B0%B1%E6%98%AF%E5%A4%A7%E5%90%8D%E9%BC%8E%E9%BC%8E%E7%9A%84%20EventLoop/NioEventLoop%20%E4%B8%8E%20Channel%20%E7%9A%84%E5%85%B3%E8%81%94%E8%BF%87%E7%A8%8B.png" target="_blank" rel="noopener">点此下载原图</a></p><p>从上图中我们可以看到, 当调用了 <strong>AbstractChannel#AbstractUnsafe.register</strong> 后, 就完成了 Channel 和 EventLoop 的关联. register 实现如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;</span><br><span class="line">    // 删除条件检查.</span><br><span class="line">    ...</span><br><span class="line">    AbstractChannel.this.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    if (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            eventLoop.execute(new OneTimeTask() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 <strong>AbstractChannel#AbstractUnsafe.register</strong> 中, 会将一个 EventLoop 赋值给 AbstractChannel 内部的 eventLoop 字段, 到这里就完成了 EventLoop 与 Channel 的关联过程.</p><h3 id="EventLoop-的启动"><a href="#EventLoop-的启动" class="headerlink" title="EventLoop 的启动"></a>EventLoop 的启动</h3><p>在前面我们已经知道了, NioEventLoop 本身就是一个 SingleThreadEventExecutor, 因此 NioEventLoop  的启动, 其实就是 NioEventLoop 所绑定的本地 Java 线程的启动.<br>依照这个思想, 我们只要找到在哪里调用了 SingleThreadEventExecutor 的 thread 字段的 <strong>start()</strong> 方法就可以知道是在哪里启动的这个线程了.<br>从代码中搜索, thread.start() 被封装到 <strong>SingleThreadEventExecutor.startThread()</strong> 方法中了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void startThread() &#123;</span><br><span class="line">    if (STATE_UPDATER.get(this) == ST_NOT_STARTED) &#123;</span><br><span class="line">        if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>STATE_UPDATER</strong> 是 SingleThreadEventExecutor 内部维护的一个属性, 它的作用是标识当前的 thread 的状态. 在初始的时候, <code>STATE_UPDATER == ST_NOT_STARTED</code>, 因此第一次调用 startThread() 方法时, 就会进入到 if 语句内, 进而调用到 thread.start().<br>而这个关键的 <strong>startThread()</strong> 方法又是在哪里调用的呢? 经过方法调用关系搜索, 我们发现, startThread 是在 SingleThreadEventExecutor.execute 方法中调用的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void execute(Runnable task) &#123;</span><br><span class="line">    if (task == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;task&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean inEventLoop = inEventLoop();</span><br><span class="line">    if (inEventLoop) &#123;</span><br><span class="line">        addTask(task);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        startThread(); // 调用 startThread 方法, 启动EventLoop 线程.</span><br><span class="line">        addTask(task);</span><br><span class="line">        if (isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>既然如此, 那现在我们的工作就变为了寻找 <code>在哪里第一次调用了 SingleThreadEventExecutor.execute() 方法.</code><br>如果留心的读者可能已经注意到了, 我们在 <strong>EventLoop 与 Channel 的关联</strong> 这一小节时, 有提到到在注册 channel 的过程中, 会在 <strong>AbstractChannel#AbstractUnsafe.register</strong> 中调用 eventLoop.execute 方法, 在 EventLoop 中进行 Channel 注册代码的执行, AbstractChannel#AbstractUnsafe.register 部分代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (eventLoop.inEventLoop()) &#123;</span><br><span class="line">    register0(promise);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        eventLoop.execute(new OneTimeTask() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                register0(promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很显然, 一路从 Bootstrap.bind 方法跟踪到 AbstractChannel#AbstractUnsafe.register 方法, 整个代码都是在主线程中运行的, 因此上面的 <strong>eventLoop.inEventLoop()</strong> 就为 false, 于是进入到 else 分支, 在这个分支中调用了 <strong>eventLoop.execute</strong>. eventLoop 是一个 NioEventLoop 的实例, 而 NioEventLoop 没有实现 execute 方法, 因此调用的是 <strong>SingleThreadEventExecutor.execute:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void execute(Runnable task) &#123;</span><br><span class="line">    ...</span><br><span class="line">    boolean inEventLoop = inEventLoop();</span><br><span class="line">    if (inEventLoop) &#123;</span><br><span class="line">        addTask(task);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        startThread();</span><br><span class="line">        addTask(task);</span><br><span class="line">        if (isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们已经分析过了, <strong>inEventLoop == false</strong>, 因此执行到 else 分支, 在这里就调用了 <strong>startThread()</strong> 方法来启动 SingleThreadEventExecutor 内部关联的 Java 本地线程了.<br>总结一句话, 当 EventLoop.execute <strong>第一次被调用</strong>时, 就会触发 <strong>startThread()</strong> 的调用, 进而导致了 EventLoop 所对应的 Java 线程的启动.<br>我们将 <strong>EventLoop 与 Channel 的关联</strong> 小节中的时序图补全后, 就得到了 EventLoop 启动过程的时序图:<br><img src="./NioEventLoop 的启动过程.png" alt="Alt text"></p><p><a href="https://github.com/yongshun/learn_netty_source_code/blob/master/Netty%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%20%E4%B8%89%20%E6%88%91%E5%B0%B1%E6%98%AF%E5%A4%A7%E5%90%8D%E9%BC%8E%E9%BC%8E%E7%9A%84%20EventLoop/NioEventLoop%20%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.png" target="_blank" rel="noopener">点此下载原图</a></p><h2 id="Netty-的-IO-处理循环"><a href="#Netty-的-IO-处理循环" class="headerlink" title="Netty 的 IO 处理循环"></a>Netty 的 IO 处理循环</h2><p><code>在 Netty 中, 一个 EventLoop 需要负责两个工作, 第一个是作为 IO 线程, 负责相应的 IO 操作; 第二个是作为任务线程, 执行 taskQueue 中的任务.</code> 接下来我们先从 IO 操纵方面入手, 看一下 TCP 数据是如何从 Java NIO Socket 传递到我们的 handler 中的.</p><p>Netty 是 Reactor 模型的一个实现, 并且是基于 Java NIO 的, 那么从 <strong>Java NIO 的前生今世 之四 NIO Selector 详解</strong> 中我们知道, Netty 中必然有一个 Selector 线程, 用于不断调用 Java NIO 的 Selector.select 方法, 查询当前是否有就绪的 IO 事件. 回顾一下在 Java NIO 中所讲述的 Selector 的使用流程:</p><ol><li>通过 Selector.open() 打开一个 Selector.</li><li>将 Channel 注册到 Selector 中, 并设置需要监听的事件(interest set)</li><li>不断重复:<ul><li>调用 select() 方法</li><li>调用 selector.selectedKeys() 获取 selected keys</li><li>迭代每个 selected key:</li><li>1) 从 selected key 中获取 对应的 Channel 和附加信息(如果有的话)</li><li>2) 判断是哪些 IO 事件已经就绪了, 然后处理它们. <strong>如果是 OP_ACCEPT 事件, 则调用 “SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept()” 获取 SocketChannel, 并将它设置为 非阻塞的, 然后将这个 Channel 注册到 Selector 中.</strong></li><li>3) 根据需要更改 selected key 的监听事件.</li><li>4) 将已经处理过的 key 从 selected keys 集合中删除.</li></ul></li></ol><p>上面的使用流程用代码来体现就是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author xiongyongshun</span><br><span class="line"> * @Email yongshun1228@gmail.com</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * @created 16/8/1 13:13</span><br><span class="line"> */</span><br><span class="line">public class NioEchoServer &#123;</span><br><span class="line">    private static final int BUF_SIZE = 256;</span><br><span class="line">    private static final int TIMEOUT = 3000;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) throws Exception &#123;</span><br><span class="line">        // 打开服务端 Socket</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        // 打开 Selector</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        // 服务端 Socket 监听8080端口, 并配置为非阻塞模式</span><br><span class="line">        serverSocketChannel.socket().bind(new InetSocketAddress(8080));</span><br><span class="line">        serverSocketChannel.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">        // 将 channel 注册到 selector 中.</span><br><span class="line">        // 通常我们都是先注册一个 OP_ACCEPT 事件, 然后在 OP_ACCEPT 到来时, 再将这个 Channel 的 OP_READ</span><br><span class="line">        // 注册到 Selector 中.</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // 通过调用 select 方法, 阻塞地等待 channel I/O 可操作</span><br><span class="line">            if (selector.select(TIMEOUT) == 0) &#123;</span><br><span class="line">                System.out.print(&quot;.&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 获取 I/O 操作就绪的 SelectionKey, 通过 SelectionKey 可以知道哪些 Channel 的哪类 I/O 操作已经就绪.</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            while (keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                // 当获取一个 SelectionKey 后, 就要将它删除, 表示我们已经对这个 IO 事件进行了处理.</span><br><span class="line">                keyIterator.remove();</span><br><span class="line"></span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">                if (key.isAcceptable()) &#123;</span><br><span class="line">                    // 当 OP_ACCEPT 事件到来时, 我们就有从 ServerSocketChannel 中获取一个 SocketChannel,</span><br><span class="line">                    // 代表客户端的连接</span><br><span class="line">                    // 注意, 在 OP_ACCEPT 事件中, 从 key.channel() 返回的 Channel 是 ServerSocketChannel.</span><br><span class="line">                    // 而在 OP_WRITE 和 OP_READ 中, 从 key.channel() 返回的是 SocketChannel.</span><br><span class="line">                    SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();</span><br><span class="line">                    clientChannel.configureBlocking(false);</span><br><span class="line">                    //在 OP_ACCEPT 到来时, 再将这个 Channel 的 OP_READ 注册到 Selector 中.</span><br><span class="line">                    // 注意, 这里我们如果没有设置 OP_READ 的话, 即 interest set 仍然是 OP_CONNECT 的话, 那么 select 方法会一直直接返回.</span><br><span class="line">                    clientChannel.register(key.selector(), OP_READ, ByteBuffer.allocate(BUF_SIZE));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (key.isReadable()) &#123;</span><br><span class="line">                    SocketChannel clientChannel = (SocketChannel) key.channel();</span><br><span class="line">                    ByteBuffer buf = (ByteBuffer) key.attachment();</span><br><span class="line">                    long bytesRead = clientChannel.read(buf);</span><br><span class="line">                    if (bytesRead == -1) &#123;</span><br><span class="line">                        clientChannel.close();</span><br><span class="line">                    &#125; else if (bytesRead &gt; 0) &#123;</span><br><span class="line">                        key.interestOps(OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">                        System.out.println(&quot;Get data length: &quot; + bytesRead);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (key.isValid() &amp;&amp; key.isWritable()) &#123;</span><br><span class="line">                    ByteBuffer buf = (ByteBuffer) key.attachment();</span><br><span class="line">                    buf.flip();</span><br><span class="line">                    SocketChannel clientChannel = (SocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">                    clientChannel.write(buf);</span><br><span class="line"></span><br><span class="line">                    if (!buf.hasRemaining()) &#123;</span><br><span class="line">                        key.interestOps(OP_READ);</span><br><span class="line">                    &#125;</span><br><span class="line">                    buf.compact();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还记得不, 上面操作的第一步 <strong>通过 Selector.open() 打开一个 Selector</strong> 我们已经在第一章的 <strong>Channel 实例化</strong> 这一小节中已经提到了, Netty 中是通过调用 SelectorProvider.openSocketChannel() 来打开一个新的 Java NIO SocketChannel:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static SocketChannel newSocket(SelectorProvider provider) &#123;</span><br><span class="line">    ...</span><br><span class="line">    return provider.openSocketChannel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二步 <strong>将 Channel 注册到 Selector 中, 并设置需要监听的事件(interest set)</strong> 的操作我们在第一章 <strong>channel 的注册过程</strong> 中也分析过了, 我们在来回顾一下, 在客户端的 Channel 注册过程中, 会有如下调用链:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Bootstrap.initAndRegister -&gt; </span><br><span class="line">AbstractBootstrap.initAndRegister -&gt; </span><br><span class="line">MultithreadEventLoopGroup.register -&gt; </span><br><span class="line">SingleThreadEventLoop.register -&gt; </span><br><span class="line">AbstractUnsafe.register -&gt;</span><br><span class="line">AbstractUnsafe.register0 -&gt;</span><br><span class="line">AbstractNioChannel.doRegister</span><br></pre></td></tr></table></figure></p><p>在 AbstractUnsafe.register 方法中调用了 register0 方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;</span><br><span class="line">// 省略条件判断和错误处理</span><br><span class="line">    AbstractChannel.this.eventLoop = eventLoop;</span><br><span class="line">    register0(promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>register0 方法代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void register0(ChannelPromise promise) &#123;</span><br><span class="line">    boolean firstRegistration = neverRegistered;</span><br><span class="line">    doRegister();</span><br><span class="line">    neverRegistered = false;</span><br><span class="line">    registered = true;</span><br><span class="line">    safeSetSuccess(promise);</span><br><span class="line">    pipeline.fireChannelRegistered();</span><br><span class="line">    // Only fire a channelActive if the channel has never been registered. This prevents firing</span><br><span class="line">    // multiple channel actives if the channel is deregistered and re-registered.</span><br><span class="line">    if (firstRegistration &amp;&amp; isActive()) &#123;</span><br><span class="line">        pipeline.fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>register0 又调用了 AbstractNioChannel.doRegister:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void doRegister() throws Exception &#123;</span><br><span class="line">// 省略错误处理</span><br><span class="line">    selectionKey = javaChannel().register(eventLoop().selector, 0, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里 javaChannel() 返回的是一个  Java NIO SocketChannel 对象, 我们将此 SocketChannel 注册到前面第一步获取的 Selector 中.</p><p>那么接下来的第三步的循环是在哪里实现的呢? 第三步的操作就是我们今天分析的关键, 下面我会一步一步向读者展示出来.</p><h3 id="thread-的-run-循环"><a href="#thread-的-run-循环" class="headerlink" title="thread 的 run 循环"></a>thread 的 run 循环</h3><p>在 <strong>EventLoop 的启动</strong> 一小节中, 我们已经了解到了, 当 EventLoop.execute <strong>第一次被调用</strong>时, 就会触发 <strong>startThread()</strong> 的调用, 进而导致了 EventLoop 所对应的 Java 线程的启动. 接着我们来更深入一些, 来看一下此线程启动后都会做什么东东吧.<br>下面是此线程的 run() 方法, 我已经把一些异常处理和收尾工作的代码都去掉了. 这个 run 方法可以说是十分简单, 主要就是调用了 <strong>SingleThreadEventExecutor.this.run()</strong> 方法. 而 SingleThreadEventExecutor.run() 是一个抽象方法, 它的实现在 NioEventLoop 中.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">thread = threadFactory.newThread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            boolean success = false;</span><br><span class="line">            updateLastExecutionTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                SingleThreadEventExecutor.this.run();</span><br><span class="line">                success = true;</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                logger.warn(&quot;Unexpected exception from an event executor: &quot;, t);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><p>继续跟踪到 NioEventLoop.run() 方法, 其源码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void run() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        boolean oldWakenUp = wakenUp.getAndSet(false);</span><br><span class="line">        try &#123;</span><br><span class="line">            if (hasTasks()) &#123;</span><br><span class="line">                selectNow();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                select(oldWakenUp);</span><br><span class="line">                if (wakenUp.get()) &#123;</span><br><span class="line">                    selector.wakeup();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cancelledKeys = 0;</span><br><span class="line">            needsToSelectAgain = false;</span><br><span class="line">            final int ioRatio = this.ioRatio;</span><br><span class="line">            if (ioRatio == 100) &#123;</span><br><span class="line">                processSelectedKeys();</span><br><span class="line">                runAllTasks();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                final long ioStartTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">                processSelectedKeys();</span><br><span class="line"></span><br><span class="line">                final long ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                runAllTasks(ioTime * (100 - ioRatio) / ioRatio);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (isShuttingDown()) &#123;</span><br><span class="line">                closeAll();</span><br><span class="line">                if (confirmShutdown()) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>啊哈, 看到了上面代码的 <strong>for(;;)</strong> 所构成的死循环了没? 原来 NioEventLoop 事件循环的核心就是这里!<br>现在我们把上面所提到的 Selector 使用步骤的第三步的部分也找到了.<br>这个 run 方法可以说是 Netty NIO 的核心, 属于重中之重, 把它分析明白了, 那么对 Netty 的事件循环机制也就了解了大部分了. 让我们一鼓作气, 继续分析下去吧!</p><h3 id="IO-事件的轮询"><a href="#IO-事件的轮询" class="headerlink" title="IO 事件的轮询"></a>IO 事件的轮询</h3><p>首先, 在 run 方法中, 第一步是调用 <strong>hasTasks()</strong> 方法来判断当前任务队列中是否有任务:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected boolean hasTasks() &#123;</span><br><span class="line">    assert inEventLoop();</span><br><span class="line">    return !taskQueue.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法很简单, 仅仅是检查了一下 <strong>taskQueue</strong> 是否为空. 至于 taskQueue 是什么呢, 其实它就是存放一系列的需要由此 EventLoop 所执行的任务列表. 关于 taskQueue, 我们这里暂时不表, 等到后面再来详细分析它.<br>当 taskQueue 不为空时, 就执行到了 if 分支中的 selectNow() 方法. 然而当 taskQueue 为空时, 执行的是 select(oldWakenUp) 方法. 那么 <strong>selectNow()</strong> 和 <strong>select(oldWakenUp)</strong> 之间有什么区别呢? 来看一下, selectNow() 的源码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void selectNow() throws IOException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        selector.selectNow();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // restore wakup state if needed</span><br><span class="line">        if (wakenUp.get()) &#123;</span><br><span class="line">            selector.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先调用了 <strong>selector.selectNow()</strong> 方法, 这里 selector 是什么大家还有印象不? 我们在第一章 <strong>Netty 源码分析之 一 揭开 Bootstrap 神秘的红盖头 (客户端)</strong> 时对它有过介绍, 这个 <strong>selector</strong> 字段正是 Java NIO 中的多路复用器 <strong>Selector</strong>. 那么这里 <strong>selector.selectNow()</strong> 就很好理解了, selectNow() 方法会检查当前是否有就绪的 IO 事件, 如果有, 则返回就绪 IO 事件的个数; 如果没有, 则返回0. <code>注意, selectNow() 是立即返回的, 不会阻塞当前线程.</code> 当 selectNow() 调用后, finally 语句块中会检查 wakenUp 变量是否为 true, 当为 true 时, 调用 selector.wakeup() 唤醒 select() 的阻塞调用.</p><p>看了 if 分支的 selectNow 方法后, 我们再来看一下 else 分支的 <strong>select(oldWakenUp)</strong> 方法.<br>其实 else 分支的 <strong>select(oldWakenUp)</strong> 方法的处理逻辑比较复杂, 而我们这里的目的暂时不是分析这个方法调用的具体工作, 因此我这里长话短说, 只列出我们我们关注的内如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void select(boolean oldWakenUp) throws IOException &#123;</span><br><span class="line">    Selector selector = this.selector;</span><br><span class="line">    try &#123;</span><br><span class="line">        ...</span><br><span class="line">        int selectedKeys = selector.select(timeoutMillis);</span><br><span class="line">        ...</span><br><span class="line">    &#125; catch (CancelledKeyException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个 select 方法中, 调用了 <strong>selector.select(timeoutMillis)</strong>, 而这个调用是会阻塞住当前线程的, timeoutMillis 是阻塞的超时时间.<br>到来这里, 我们可以看到, 当 <strong>hasTasks()</strong> 为真时, 调用的的 <strong>selectNow()</strong> 方法是不会阻塞当前线程的, 而当  <strong>hasTasks()</strong> 为假时, 调用的 <strong>select(oldWakenUp)</strong> 是会阻塞当前线程的.<br>这其实也很好理解: 当 taskQueue 中没有任务时, 那么 Netty 可以阻塞地等待 IO 就绪事件; 而当 taskQueue 中有任务时, 我们自然地希望所提交的任务可以尽快地执行, 因此 Netty 会调用非阻塞的 selectNow() 方法, 以保证 taskQueue 中的任务尽快可以执行.</p><h3 id="IO-事件的处理"><a href="#IO-事件的处理" class="headerlink" title="IO 事件的处理"></a>IO 事件的处理</h3><p>在 NioEventLoop.run() 方法中, 第一步是通过 select/selectNow 调用查询当前是否有就绪的 IO 事件. 那么当有 IO 事件就绪时, 第二步自然就是处理这些 IO 事件啦.<br>首先让我们来看一下 NioEventLoop.run 中循环的剩余部分:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">final int ioRatio = this.ioRatio;</span><br><span class="line">if (ioRatio == 100) &#123;</span><br><span class="line">    processSelectedKeys();</span><br><span class="line">    runAllTasks();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    final long ioStartTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    processSelectedKeys();</span><br><span class="line"></span><br><span class="line">    final long ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">    runAllTasks(ioTime * (100 - ioRatio) / ioRatio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面列出的代码中, 有两个关键的调用, 第一个是 <strong>processSelectedKeys()</strong> 调用, 根据字面意思, 我们可以猜出这个方法肯定是查询就绪的 IO 事件, 然后处理它; 第二个调用是 <strong>runAllTasks()</strong>, 这个方法我们也可以一眼就看出来它的功能就是运行 taskQueue 中的任务.<br>这里的代码还有一个十分有意思的地方, 即 <strong>ioRatio</strong>. 那什么是 <strong>ioRatio</strong>呢? 它表示的是此线程分配给 IO 操作所占的时间比(即运行 processSelectedKeys 耗时在整个循环中所占用的时间). 例如 ioRatio 默认是 50, 则表示 IO 操作和执行 task 的所占用的线程执行时间比是 1 : 1. 当知道了 IO 操作耗时和它所占用的时间比, 那么执行 task 的时间就可以很方便的计算出来了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设 IO 操作耗时为 ioTime, ioTime 占的时间比例为 ioRatio, 则:</span><br><span class="line">ioTime / ioRatio = taskTime / taskRatio</span><br><span class="line">taskRatio = 100 - ioRatio</span><br><span class="line">=&gt; taskTime = ioTime * (100 - ioRatio) / ioRatio</span><br></pre></td></tr></table></figure></p><p>根据上面的公式, 当我们设置 ioRate = 70 时, 则表示 IO 运行耗时占比为70%, 即假设某次循环一共耗时为 100ms, 那么根据公式, 我们知道 <strong>processSelectedKeys()</strong> 方法调用所耗时大概为70ms(即 IO 耗时), 而 <strong>runAllTasks()</strong> 耗时大概为 30ms(即执行 task 耗时).<br>当 ioRatio 为 100 时, Netty 就不考虑 IO 耗时的占比, 而是分别调用 <strong>processSelectedKeys()</strong>、<strong>runAllTasks()</strong>; 而当 ioRatio 不为 100时, 则执行到 else 分支, 在这个分支中, 首先记录下 <strong>processSelectedKeys()</strong> 所执行的时间(即 IO 操作的耗时), 然后根据公式, 计算出执行 task 所占用的时间, 然后以此为参数, 调用 <strong>runAllTasks()</strong>.</p><p>我们这里先分析一下 <strong>processSelectedKeys()</strong> 方法调用, <strong>runAllTasks()</strong> 我们留到下一节再分析.<br><strong>processSelectedKeys()</strong> 方法的源码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void processSelectedKeys() &#123;</span><br><span class="line">    if (selectedKeys != null) &#123;</span><br><span class="line">        processSelectedKeysOptimized(selectedKeys.flip());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法中, 会根据 <strong>selectedKeys</strong> 字段是否为空, 而分别调用 <strong>processSelectedKeysOptimized</strong> 或 <strong>processSelectedKeysPlain</strong>. <strong>selectedKeys</strong> 字段是在调用 openSelector() 方法时, 根据 JVM 平台的不同, 而有设置不同的值, 在我所调试这个值是不为 null 的. 其实 <strong>processSelectedKeysOptimized</strong> 方法 <strong>processSelectedKeysPlain</strong> 没有太大的区别, 为了简单起见, 我们以 <strong>processSelectedKeysOptimized</strong> 为例分析一下源码的工作流程吧.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void processSelectedKeysOptimized(SelectionKey[] selectedKeys) &#123;</span><br><span class="line">    for (int i = 0;; i ++) &#123;</span><br><span class="line">        final SelectionKey k = selectedKeys[i];</span><br><span class="line">        if (k == null) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        selectedKeys[i] = null;</span><br><span class="line"></span><br><span class="line">        final Object a = k.attachment();</span><br><span class="line"></span><br><span class="line">        if (a instanceof AbstractNioChannel) &#123;</span><br><span class="line">            processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">            processSelectedKey(k, task);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实你别看它代码挺多的, 但是关键的点就两个: 迭代 <strong>selectedKeys</strong> 获取就绪的 IO 事件, 然后为每个事件都调用 <strong>processSelectedKey</strong> 来处理它.<br>这里正好完美对应上了我们提到的 Selector 的使用流程中的第三步里操作.<br>还有一点需要注意的是, 我们可以调用 <strong>selectionKey.attach(object)</strong> 给一个 selectionKey 设置一个附加的字段, 然后可以通过 <strong>Object attachedObj = selectionKey.attachment()</strong> 获取它. 上面代代码正是通过了 <strong>k.attachment()</strong> 来获取一个附加在 selectionKey 中的对象, 那么这个对象是什么呢? 它又是在哪里设置的呢? 我们再来回忆一下 SocketChannel 是如何注册到 Selector 中的:<br>在客户端的 Channel 注册过程中, 会有如下调用链:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Bootstrap.initAndRegister -&gt; </span><br><span class="line">AbstractBootstrap.initAndRegister -&gt; </span><br><span class="line">MultithreadEventLoopGroup.register -&gt; </span><br><span class="line">SingleThreadEventLoop.register -&gt; </span><br><span class="line">AbstractUnsafe.register -&gt;</span><br><span class="line">AbstractUnsafe.register0 -&gt;</span><br><span class="line">AbstractNioChannel.doRegister</span><br></pre></td></tr></table></figure></p><p>最后的 AbstractNioChannel.doRegister 方法会调用 <strong>SocketChannel.register</strong> 方法注册一个 SocketChannel 到指定的 Selector:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void doRegister() throws Exception &#123;</span><br><span class="line">// 省略错误处理</span><br><span class="line">    selectionKey = javaChannel().register(eventLoop().selector, 0, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>特别注意一下 <strong>register</strong> 的第三个参数, 这个参数是设置 selectionKey 的附加对象的, 和调用 <strong>selectionKey.attach(object)</strong> 的效果一样. 而调用 <strong>register</strong> 所传递的第三个参数是 <strong>this</strong>, 它其实就是一个 <code>NioSocketChannel</code> 的实例. 那么这里就很清楚了, 我们在将 SocketChannel 注册到 Selector 中时, 将 SocketChannel 所对应的 NioSocketChannel 以附加字段的方式添加到了selectionKey 中.<br>再回到 <strong>processSelectedKeysOptimized</strong> 方法中, 当我们获取到附加的对象后, 我们就调用 <strong>processSelectedKey</strong> 来处理这个 IO 事件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final Object a = k.attachment();</span><br><span class="line"></span><br><span class="line">if (a instanceof AbstractNioChannel) &#123;</span><br><span class="line">    processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">    processSelectedKey(k, task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>processSelectedKey</strong> 方法源码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private static void processSelectedKey(SelectionKey k, AbstractNioChannel ch) &#123;</span><br><span class="line">    final NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">        int readyOps = k.readyOps();</span><br><span class="line">        </span><br><span class="line">        // 可读事件</span><br><span class="line">        if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) &#123;</span><br><span class="line">            unsafe.read();</span><br><span class="line">            if (!ch.isOpen()) &#123;</span><br><span class="line">                // Connection already closed - no need to handle write.</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">// 可写事件</span><br><span class="line">        if ((readyOps &amp; SelectionKey.OP_WRITE) != 0) &#123;</span><br><span class="line">            // Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span><br><span class="line">            ch.unsafe().forceFlush();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 连接建立事件</span><br><span class="line">        if ((readyOps &amp; SelectionKey.OP_CONNECT) != 0) &#123;</span><br><span class="line">            // remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking</span><br><span class="line">            // See https://github.com/netty/netty/issues/924</span><br><span class="line">            int ops = k.interestOps();</span><br><span class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line"></span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (CancelledKeyException ignored) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个代码是不是很熟悉啊? 完全是 Java NIO 的 Selector 的那一套处理流程嘛!<br><strong>processSelectedKey</strong> 中处理了三个事件, 分别是:</p><ul><li>OP_READ, 可读事件, 即 Channel 中收到了新数据可供上层读取.</li><li>OP_WRITE, 可写事件, 即上层可以向 Channel 写入数据.</li><li>OP_CONNECT, 连接建立事件, 即 TCP 连接已经建立, Channel 处于 active 状态.</li></ul><p>下面我们分别根据这三个事件来看一下 Netty 是怎么处理的吧.</p><h4 id="OP-READ-处理"><a href="#OP-READ-处理" class="headerlink" title="OP_READ 处理"></a>OP_READ 处理</h4><p>当就绪的 IO 事件是 <strong>OP_READ</strong>, 代码会调用 <strong>unsafe.read()</strong> 方法, 即:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 可读事件</span><br><span class="line">if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) &#123;</span><br><span class="line">    unsafe.read();</span><br><span class="line">    if (!ch.isOpen()) &#123;</span><br><span class="line">        // Connection already closed - no need to handle write.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>unsafe 这个字段, 我们已经和它打了太多的交道了, 在第一章 <strong>Netty 源码分析之 一 揭开 Bootstrap 神秘的红盖头 (客户端)</strong> 中我们已经对它进行过浓墨重彩地分析了, 最后我们确定了它是一个 <strong>NioSocketChannelUnsafe</strong> 实例, 负责的是 Channel 的底层 IO 操作.<br>我们可以利用 Intellij IDEA 提供的 <strong>Go To Implementations</strong> 功能, 寻找到这个方法的实现. 最后我们发现这个方法没有在 <strong>NioSocketChannelUnsafe</strong> 中实现, 而是在它的父类 <strong>AbstractNioByteChannel</strong> 实现的, 它的实现源码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void read() &#123;</span><br><span class="line">    ...</span><br><span class="line">    ByteBuf byteBuf = null;</span><br><span class="line">    int messages = 0;</span><br><span class="line">    boolean close = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        int totalReadAmount = 0;</span><br><span class="line">        boolean readPendingReset = false;</span><br><span class="line">        do &#123;</span><br><span class="line">            byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">            int writable = byteBuf.writableBytes();</span><br><span class="line">            int localReadAmount = doReadBytes(byteBuf);</span><br><span class="line"></span><br><span class="line">            // 检查读取结果.</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            pipeline.fireChannelRead(byteBuf);</span><br><span class="line">            byteBuf = null;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            totalReadAmount += localReadAmount;</span><br><span class="line">        </span><br><span class="line">            // 检查是否是配置了自动读取, 如果不是, 则立即退出循环.</span><br><span class="line">            ...</span><br><span class="line">        &#125; while (++ messages &lt; maxMessagesPerRead);</span><br><span class="line"></span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line">        allocHandle.record(totalReadAmount);</span><br><span class="line"></span><br><span class="line">        if (close) &#123;</span><br><span class="line">            closeOnRead(pipeline);</span><br><span class="line">            close = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        handleReadException(pipeline, byteBuf, t, close);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>read()</strong> 源码比较长, 我为了篇幅起见, 删除了部分代码, 只留下了主干. 不过我建议读者朋友们自己一定要看一下 <strong>read()</strong> 源码, 这对理解  Netty 的 EventLoop 十分有帮助.<br>上面 <strong>read</strong> 方法其实归纳起来, 可以认为做了如下工作:</p><ol><li>分配 ByteBuf</li><li>从 SocketChannel 中读取数据</li><li>调用 <strong>pipeline.fireChannelRead</strong> 发送一个 inbound 事件.</li></ol><p>前面两点没什么好说的, 第三点 <strong>pipeline.fireChannelRead</strong> 读者朋友们看到了有没有会心一笑地感觉呢? 反正我看到这里时是有的. <strong>pipeline.fireChannelRead</strong> 正好就是我们在第二章 <strong>Netty 源码分析之 二 贯穿Netty 的大动脉 ── ChannelPipeline (二)</strong> 中分析的 <strong>inbound</strong> 事件起点. 当调用了 <strong>pipeline.fireIN_EVT()</strong> 后, 那么就产生了一个 <strong>inbound</strong> 事件, 此事件会以 <strong>head -&gt; customContext -&gt; tail</strong> 的方向依次流经 ChannelPipeline 中的各个 handler.<br>调用了 <strong>pipeline.fireChannelRead</strong> 后, 就是 ChannelPipeline 中所需要做的工作了, 这些我们已经在第二章中有过详细讨论, 这里就展开了.</p><h4 id="OP-WRITE-处理"><a href="#OP-WRITE-处理" class="headerlink" title="OP_WRITE 处理"></a>OP_WRITE 处理</h4><p><strong>OP_WRITE</strong> 可写事件代码如下. 这里代码比较简单, 没有详细分析的必要了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if ((readyOps &amp; SelectionKey.OP_WRITE) != 0) &#123;</span><br><span class="line">    // Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span><br><span class="line">    ch.unsafe().forceFlush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="OP-CONNECT-处理"><a href="#OP-CONNECT-处理" class="headerlink" title="OP_CONNECT 处理"></a>OP_CONNECT 处理</h4><p>最后一个事件是 <strong>OP_CONNECT</strong>, 即 TCP 连接已建立事件.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if ((readyOps &amp; SelectionKey.OP_CONNECT) != 0) &#123;</span><br><span class="line">    // remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking</span><br><span class="line">    // See https://github.com/netty/netty/issues/924</span><br><span class="line">    int ops = k.interestOps();</span><br><span class="line">    ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">    k.interestOps(ops);</span><br><span class="line"></span><br><span class="line">    unsafe.finishConnect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>OP_CONNECT</strong> 事件的处理中, 只做了两件事情:</p><ol><li>正如代码中的注释所言, 我们需要将 <strong>OP_CONNECT</strong> 从就绪事件集中清除, 不然会一直有 <strong>OP_CONNECT</strong> 事件.</li><li>调用 unsafe.finishConnect() 通知上层连接已建立</li></ol><p>unsafe.finishConnect() 调用最后会调用到 <strong>pipeline().fireChannelActive()</strong>, 产生一个 <strong>inbound</strong> 事件, 通知 pipeline 中的各个 handler TCP 通道已建立(即 <strong>ChannelInboundHandler.channelActive</strong> 方法会被调用)</p><p>到了这里, 我们整个 NioEventLoop 的 IO 操作部分已经了解完了, 接下来的一节我们要重点分析一下 <strong>Netty 的任务队列机制</strong>.</p><h2 id="Netty-的任务队列机制"><a href="#Netty-的任务队列机制" class="headerlink" title="Netty 的任务队列机制"></a>Netty 的任务队列机制</h2><p>我们已经提到过, 在Netty 中, 一个 NioEventLoop 通常需要肩负起两种任务, 第一个是作为 IO 线程, 处理 IO 操作; 第二个就是作为任务线程, 处理 taskQueue 中的任务. 这一节的重点就是分析一下 NioEventLoop 的任务队列机制的.</p><h3 id="Task-的添加"><a href="#Task-的添加" class="headerlink" title="Task 的添加"></a>Task 的添加</h3><h4 id="普通-Runnable-任务"><a href="#普通-Runnable-任务" class="headerlink" title="普通 Runnable 任务"></a>普通 Runnable 任务</h4><p>NioEventLoop 继承于 SingleThreadEventExecutor, 而 <code>SingleThreadEventExecutor</code> 中有一个 <strong>Queue<runnable> taskQueue</runnable></strong> 字段, 用于存放添加的 Task. 在 Netty 中, 每个 Task 都使用一个实现了 Runnable 接口的实例来表示.<br>例如当我们需要将一个 Runnable 添加到 taskQueue 中时, 我们可以进行如下操作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EventLoop eventLoop = channel.eventLoop();</span><br><span class="line">eventLoop.execute(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Hello, Netty!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>当调用 execute 后, 实际上是调用到了 SingleThreadEventExecutor.execute() 方法, 它的实现如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void execute(Runnable task) &#123;</span><br><span class="line">    if (task == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;task&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean inEventLoop = inEventLoop();</span><br><span class="line">    if (inEventLoop) &#123;</span><br><span class="line">        addTask(task);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        startThread();</span><br><span class="line">        addTask(task);</span><br><span class="line">        if (isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而添加任务的 <strong>addTask</strong> 方法的源码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected void addTask(Runnable task) &#123;</span><br><span class="line">    if (task == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;task&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (isShutdown()) &#123;</span><br><span class="line">        reject();</span><br><span class="line">    &#125;</span><br><span class="line">    taskQueue.add(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此实际上, <code>taskQueue</code> 是存放着待执行的任务的队列.</p><h4 id="schedule-任务"><a href="#schedule-任务" class="headerlink" title="schedule 任务"></a>schedule 任务</h4><p>除了通过 execute 添加普通的 Runnable 任务外, 我们还可以通过调用 eventLoop.scheduleXXX 之类的方法来添加一个定时任务.<br> EventLoop 中实现任务队列的功能在超类 <code>SingleThreadEventExecutor</code> 实现的, 而 schedule 功能的实现是在 <code>SingleThreadEventExecutor</code> 的父类, 即 <code>AbstractScheduledEventExecutor</code> 中实现的.<br>在 <code>AbstractScheduledEventExecutor</code> 中, 有以 scheduledTaskQueue 字段:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue;</span><br></pre></td></tr></table></figure></p><p>scheduledTaskQueue 是一个队列(Queue), 其中存放的元素是 <strong>ScheduledFutureTask</strong>. 而 <strong>ScheduledFutureTask</strong> 我们很容易猜到, 它是对 Schedule 任务的一个抽象.<br>我们来看一下 <code>AbstractScheduledEventExecutor</code>  所实现的 <strong>schedule</strong> 方法吧:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public  ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit) &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(command, &quot;command&quot;);</span><br><span class="line">    ObjectUtil.checkNotNull(unit, &quot;unit&quot;);</span><br><span class="line">    if (delay &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(</span><br><span class="line">                String.format(&quot;delay: %d (expected: &gt;= 0)&quot;, delay));</span><br><span class="line">    &#125;</span><br><span class="line">    return schedule(new ScheduledFutureTask&lt;Void&gt;(</span><br><span class="line">            this, command, null, ScheduledFutureTask.deadlineNanos(unit.toNanos(delay))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是其中一个重载的 schedule, 当一个 Runnable 传递进来后, 会被封装为一个 <strong>ScheduledFutureTask</strong> 对象, 这个对象会记录下这个 Runnable 在何时运行、已何种频率运行等信息.<br>当构建了 <strong>ScheduledFutureTask</strong> 后, 会继续调用 另一个重载的 schedule 方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(final ScheduledFutureTask&lt;V&gt; task) &#123;</span><br><span class="line">    if (inEventLoop()) &#123;</span><br><span class="line">        scheduledTaskQueue().add(task);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        execute(new OneTimeTask() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                scheduledTaskQueue().add(task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个方法中, ScheduledFutureTask 对象就会被添加到 <strong>scheduledTaskQueue</strong> 中了.</p><h3 id="任务的执行"><a href="#任务的执行" class="headerlink" title="任务的执行"></a>任务的执行</h3><p>当一个任务被添加到 taskQueue 后, 它是怎么被 EventLoop 执行的呢?<br>让我们回到 NioEventLoop.run() 方法中, 在这个方法里, 会分别调用 <strong>processSelectedKeys()</strong> 和 <strong>runAllTasks()</strong> 方法, 来进行 IO 事件的处理和 task 的处理. <strong>processSelectedKeys()</strong> 方法我们已经分析过了, 下面我们来看一下 <strong>runAllTasks()</strong> 中到底有什么名堂吧.<br>runAllTasks 方法有两个重载的方法, 一个是无参数的, 另一个有一个参数的. 首先来看一下无参数的 runAllTasks:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected boolean runAllTasks() &#123;</span><br><span class="line">    fetchFromScheduledTaskQueue();</span><br><span class="line">    Runnable task = pollTask();</span><br><span class="line">    if (task == null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            task.run();</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            logger.warn(&quot;A task raised an exception.&quot;, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        task = pollTask();</span><br><span class="line">        if (task == null) &#123;</span><br><span class="line">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们前面已经提到过, EventLoop 可以通过调用 <strong>EventLoop.execute</strong> 来将一个 Runnable 提交到 taskQueue 中, 也可以通过调用 <strong>EventLoop.schedule</strong> 来提交一个 schedule 任务到 <strong>scheduledTaskQueue</strong> 中. 在此方法的一开始调用的 <strong>fetchFromScheduledTaskQueue()</strong> 其实就是将 <strong>scheduledTaskQueue</strong> 中已经可以执行的(即定时时间已到的 schedule 任务) 拿出来并添加到 taskQueue 中, 作为可执行的 task 等待被调度执行.<br>它的源码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void fetchFromScheduledTaskQueue() &#123;</span><br><span class="line">    if (hasScheduledTasks()) &#123;</span><br><span class="line">        long nanoTime = AbstractScheduledEventExecutor.nanoTime();</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Runnable scheduledTask = pollScheduledTask(nanoTime);</span><br><span class="line">            if (scheduledTask == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            taskQueue.add(scheduledTask);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来 <strong>runAllTasks()</strong> 方法就会不断调用 <strong>task = pollTask()</strong> 从 <strong>taskQueue</strong> 中获取一个可执行的 task, 然后调用它的 <strong>run()</strong> 方法来运行此 task.</p><blockquote><p><code>注意</code>, 因为 EventLoop 既需要执行 IO 操作, 又需要执行 task, 因此我们在调用 EventLoop.execute 方法提交任务时, 不要提交耗时任务, 更不能提交一些会造成阻塞的任务, 不然会导致我们的 IO 线程得不到调度, 影响整个程序的并发量.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Netty-源码分析之-三-我就是大名鼎鼎的-EventLoop&quot;&gt;&lt;a href=&quot;#Netty-源码分析之-三-我就是大名鼎鼎的-EventLoop&quot; class=&quot;headerlink&quot; title=&quot;Netty 源码分析之 三 我就是大名鼎鼎的 Event
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redis的缓存过期策略</title>
    <link href="http://www.iforfee.com/redis/Redis%E7%9A%84%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/"/>
    <id>http://www.iforfee.com/redis/Redis的缓存过期策略/</id>
    <published>2018-05-07T07:30:23.000Z</published>
    <updated>2018-05-07T07:38:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h1><h2 id="定时清除"><a href="#定时清除" class="headerlink" title="定时清除"></a>定时清除</h2><p>含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>保证内存被尽快释放</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key</li><li>定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重</li></ul><h2 id="懒汉式删除"><a href="#懒汉式删除" class="headerlink" title="懒汉式删除"></a>懒汉式删除</h2><p>含义：key过期的时候不删除，每次通过key获取值的时候去检查是否过期，若过期，则删除，返回null。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>删除操作只发生在通过key取值的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）</li></ul><h2 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h2><p>含义：每隔一段时间执行一次删除过期key操作</p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用–处理”定时删除”的缺点</li><li>定期删除过期key–处理”懒汉式删除”的缺点</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>在内存友好方面，不如”定时删除”（会造成一定的内存占用，但是没有懒汉式那么占用内存）</li><li>在CPU时间友好方面，不如”懒汉式删除”（会定期的去进行比较和删除操作，cpu方面不如懒汉式，但是比定时好）</li></ul><h1 id="Redis采用的过期策略"><a href="#Redis采用的过期策略" class="headerlink" title="Redis采用的过期策略"></a>Redis采用的过期策略</h1><p>懒汉式删除+定期删除</p><p>懒汉式删除流程：</p><ul><li>在进行get或setnx等操作时，先检查key是否过期；</li><li>若过期，删除key，然后执行相应操作；</li><li>若没过期，直接执行相应操作；</li></ul><p>定期删除流程（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）：</p><ul><li>遍历每个数据库（就是redis.conf中配置的”database”数量，默认为16）</li><li>检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体是下边的描述）<ul><li>如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历</li><li>随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key</li><li>判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。</li></ul></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/xiangnan129/article/details/54928672" target="_blank" rel="noopener">https://blog.csdn.net/xiangnan129/article/details/54928672</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;过期策略&quot;&gt;&lt;a href=&quot;#过期策略&quot; class=&quot;headerlink&quot; title=&quot;过期策略&quot;&gt;&lt;/a&gt;过期策略&lt;/h1&gt;&lt;h2 id=&quot;定时清除&quot;&gt;&lt;a href=&quot;#定时清除&quot; class=&quot;headerlink&quot; title=&quot;定时清除&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="redis" scheme="http://www.iforfee.com/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>redis持久化</title>
    <link href="http://www.iforfee.com/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://www.iforfee.com/redis/redis持久化/</id>
    <published>2018-05-07T04:15:32.000Z</published>
    <updated>2018-05-07T04:31:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 提供了多种不同级别的持久化方式：</p><ul><li>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。</li><li>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。</li><li>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</li><li>你甚至可以关闭持久化功能，让数据只在服务器运行时存在。</li></ul><p>了解 RDB 持久化和 AOF 持久化之间的异同是非常重要的， 以下几个小节将详细地介绍这这两种持久化功能， 并对它们的相同和不同之处进行说明。</p><h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。</li><li>RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。</li><li>RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。</li><li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。</li><li>每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork()可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。</li></ul><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><ul><li>使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。</li><li>AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。</li><li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</li><li>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。</li></ul><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ul><li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li><li>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。</li><li>AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令 BRPOPLPUSH 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。</li></ul><p><a href="http://redisdoc.com/topic/persistence.html" target="_blank" rel="noopener">http://redisdoc.com/topic/persistence.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis 提供了多种不同级别的持久化方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。&lt;/li&gt;
&lt;li&gt;AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执
      
    
    </summary>
    
      <category term="redis" scheme="http://www.iforfee.com/categories/redis/"/>
    
    
      <category term="持久化" scheme="http://www.iforfee.com/tags/%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>redis分布式锁</title>
    <link href="http://www.iforfee.com/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://www.iforfee.com/redis/redis分布式锁/</id>
    <published>2018-05-07T02:55:42.000Z</published>
    <updated>2018-05-07T07:41:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>分布式锁可以基于很多种方式实现，比如zookeeper、redis…。不管哪种方式，他的<strong>基本原理</strong>是不变的：<strong>用一个状态值表示锁，对锁的占用和释放通过状态值来标识。</strong></p><p>三、使用redis的setNX命令实现分布式锁</p><ol><li>、实现的原理</li></ol><p><strong>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问</strong>，且多客户端对Redis的连接并不存在竞争关系。redis的SETNX命令可以方便的实现分布式锁。</p><p>2、基本命令解析</p><p>1）setNX（SET if Not eXists）</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX key value</span><br></pre></td></tr></table></figure><p>将 key 的值设为 value ，当且仅当 key 不存在。</p><p>若给定的 key 已经存在，则 SETNX 不做任何动作。</p><p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写</p><p><strong>返回值：</strong></p><p>设置成功，返回 1 。</p><p>设置失败，返回 0 。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS job                # job 不存在</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETNX job &quot;programmer&quot;    # job 设置成功</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SETNX job &quot;code-farmer&quot;   # 尝试覆盖 job ，失败</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GET job                   # 没有被覆盖</span><br><span class="line">&quot;programmer&quot;</span><br></pre></td></tr></table></figure><p>所以我们使用执行下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX lock.foo &lt;current Unix time + lock timeout + 1&gt;</span><br></pre></td></tr></table></figure><ul><li>如返回1，则该客户端获得锁，把lock.foo的键值设置为时间值表示该键已被锁定，该客户端最后可以通过DEL lock.foo来释放该锁。</li><li>如返回0，表明该锁已被其他客户端取得，这时我们可以先返回或进行重试等对方完成或等待锁超时。</li></ul><p>2）getSET</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETSET key value</span><br></pre></td></tr></table></figure><p>将给定 key 的值设为 value，并返回 key 的旧值(old value)。</p><p>当 key 存在但不是字符串类型时，返回一个错误。</p><p><strong>返回值：</strong></p><p>返回给定 key 的旧值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当 key 没有旧值时，也即是， key 不存在时，返回 nil 。</span><br></pre></td></tr></table></figure><p>3）get</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET key</span><br></pre></td></tr></table></figure><p><strong>返回值：</strong></p><p>当 key 不存在时，返回 nil ，否则，返回 key 的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果 key 不是字符串类型，那么返回一个错误</span><br></pre></td></tr></table></figure><p>四、解决死锁</p><p>上面的锁定逻辑有一个问题：<strong>如果一个持有锁的客户端失败或崩溃了不能释放锁，该怎么解决</strong>？</p><blockquote><p>我们可以通过锁的键对应的时间戳来判断这种情况是否发生了，如果当前的时间已经大于lock.foo的值，说明该锁已失效，可以被重新使用。</p></blockquote><p>发生这种情况时，可不能简单的通过DEL来删除锁，然后再SETNX一次（讲道理，<strong>删除锁的操作应该是锁拥有这执行的，这里只需要等它超时即可</strong>），当多个客户端检测到锁超时后都会尝试去释放它，这里就可能出现一个竞态条件,让我们模拟一下这个场景：</p><blockquote><p>C0操作超时了，但它还持有着锁，C1和C2读取lock.foo检查时间戳，先后发现超时了。<br>C1 发送DEL lock.foo<br>C1 发送SETNX lock.foo 并且成功了。<br>C2 发送DEL lock.foo<br>C2 发送SETNX lock.foo 并且成功了。<br>这样一来，C1，C2都拿到了锁！问题大了！</p></blockquote><p>幸好这种问题是可以避免的，让我们来看看C3这个客户端是怎样做的：</p><blockquote><p>C3发送SETNX lock.foo 想要获得锁，由于C0还持有锁，所以Redis返回给C3一个0<br>C3发送GET lock.foo 以检查锁是否超时了，如果没超时，则等待或重试。<br>反之，如果已超时，C3通过下面的操作来尝试获得锁：<br>GETSET lock.foo <current 1="" unix="" time="" +="" lock="" timeout=""><br>通过GETSET，C3拿到的时间戳如果仍然是超时的，那就说明，C3如愿以偿拿到锁了。</current></p></blockquote><p>如果在C3之前，有个叫C4的客户端比C3快一步执行了上面的操作，那么C3拿到的时间戳是个未超时的值，这时，C3没有如期获得锁，需要再次等待或重试。留意一下，尽管C3没拿到锁，但它改写了C4设置的锁的超时值，不过这一点非常微小的误差带来的影响可以忽略不计。</p><p><strong>注意</strong>：为了让分布式锁的算法更稳键些，持有锁的客户端在解锁之前应该再检查一次自己的锁是否已经超时，再去做DEL操作，因为可能客户端因为某个耗时的操作而挂起，操作完的时候锁因为超时已经被别人获得，这时就不必解锁了</p><p>六、一些问题</p><p>1、为什么不直接使用expire设置超时时间，而将时间的毫秒数其作为value放在redis中？</p><p>如下面的方式，把超时的交给redis处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lock(key, expireSec)&#123;</span><br><span class="line">isSuccess =</span><br><span class="line"> setnx key</span><br><span class="line">if</span><br><span class="line"> (isSuccess)</span><br><span class="line">expire key expireSec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式貌似没什么问题，但是假如在setnx后，redis崩溃了，expire就没有执行，结果就是死锁了。锁永远不会超时。</p><p>2、为什么前面的锁已经超时了，还要用getSet去设置新的时间戳的时间获取旧的值，然后和外面的判断超时时间的时间戳比较呢？</p><p><img src="/images/redis/import4325.png" alt="img">因为是分布式的环境下，可以在前一个锁失效的时候，有两个进程进入到锁超时的判断。如：</p><p>C0超时了，还持有锁,C1/C2同时请求进入了方法里面</p><p>C1/C2获取到了C0的超时时间</p><p>C1使用getSet方法</p><p>C2也执行了getSet方法</p><p>假如我们不加 oldValueStr.equals(currentValueStr) 的判断，将会C1/C2都将获得锁，加了之后，能保证C1和C2只能一个能获得锁，一个只能继续等待。</p><p><strong>注意：这里可能导致超时时间不是其原本的超时时间，C1的超时时间可能被C2覆盖了，但是他们相差的毫秒及其小，这里忽略了。</strong></p><p><a href="http://www.cnblogs.com/0201zcr/p/5942748.html" target="_blank" rel="noopener">http://www.cnblogs.com/0201zcr/p/5942748.html</a></p><p><a href="http://blog.csdn.net/ugg/article/details/41894947" target="_blank" rel="noopener">http://blog.csdn.net/ugg/article/details/41894947</a></p><p>仅有一个setnx命令，redis遇到的问题跟数据库锁一样，但是过期时间这一项，redis自带的expire功能可以不需要应用主动去删除锁。而且从 Redis 2.6.12 版本开始，redis的set命令直接直接设置NX和EX属性，NX即附带了setnx数据，key存在就无法插入，EX是过期属性，可以设置过期时间。这样一个命令就能原子的完成加锁和设置过期时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分布式锁可以基于很多种方式实现，比如zookeeper、redis…。不管哪种方式，他的&lt;strong&gt;基本原理&lt;/strong&gt;是不变的：&lt;strong&gt;用一个状态值表示锁，对锁的占用和释放通过状态值来标识。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;三、使用redis的setNX
      
    
    </summary>
    
      <category term="redis" scheme="http://www.iforfee.com/categories/redis/"/>
    
    
      <category term="lock" scheme="http://www.iforfee.com/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>网络协议</title>
    <link href="http://www.iforfee.com/protocols/"/>
    <id>http://www.iforfee.com/protocols/</id>
    <published>2018-05-07T01:38:12.000Z</published>
    <updated>2018-05-07T02:07:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://lib.csdn.net/article/computernetworks/20534" target="_blank" rel="noopener">TCP/IP、Http、Socket的区别</a></p><p><a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="noopener">通俗大白话来理解TCP协议的三次握手和四次分手</a></p><p><a href="https://www.dozer.cc/2014/12/netty-long-connection.html" target="_blank" rel="noopener">Netty 长连接服务</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://lib.csdn.net/article/computernetworks/20534&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TCP/IP、Http、Socket的区别&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;htt
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>索引系列</title>
    <link href="http://www.iforfee.com/BitMap/"/>
    <id>http://www.iforfee.com/BitMap/</id>
    <published>2018-05-06T06:47:32.000Z</published>
    <updated>2018-05-06T07:14:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h1><p><a href="https://www.cnblogs.com/LBSer/p/3322630.html" target="_blank" rel="noopener">https://www.cnblogs.com/LBSer/p/3322630.html</a></p><p><a href="https://www.cnblogs.com/yangjiannr/p/da-shu-ju-chu-libitmap.html" target="_blank" rel="noopener">https://www.cnblogs.com/yangjiannr/p/da-shu-ju-chu-libitmap.html</a></p><p><a href="https://www.cnblogs.com/scott19820130/p/6058677.html" target="_blank" rel="noopener">https://www.cnblogs.com/scott19820130/p/6058677.html</a></p><p><a href="http://blog.renbaobin.com/bitmap.html" target="_blank" rel="noopener">http://blog.renbaobin.com/bitmap.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BitMap&quot;&gt;&lt;a href=&quot;#BitMap&quot; class=&quot;headerlink&quot; title=&quot;BitMap&quot;&gt;&lt;/a&gt;BitMap&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/LBSer/p/3322630.html&quot;
      
    
    </summary>
    
      <category term="索引" scheme="http://www.iforfee.com/categories/%E7%B4%A2%E5%BC%95/"/>
    
    
      <category term="索引" scheme="http://www.iforfee.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>jvm参数</title>
    <link href="http://www.iforfee.com/java/jvm/jvm%E5%8F%82%E6%95%B0/"/>
    <id>http://www.iforfee.com/java/jvm/jvm参数/</id>
    <published>2018-04-27T14:15:08.000Z</published>
    <updated>2018-04-27T14:18:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>-Xms10m 设置堆的最小空间大小。</p><p>-Xmx10m 设置堆的最大空间大小。</p><p>-Xmn10m  设置年轻代大小</p><p>-XX:NewSize=256m 设置新生代最小空间大小。</p><p>-XX:MaxNewSize=256m 设置新生代最大空间大小。</p><p>-XX:PermSize=256m 设置永久代最小空间大小。</p><p>-XX:MaxPermSize=256m 设置永久代最大空间大小。</p><p>-Xss128k 设置每个线程的堆栈大小。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;-Xms10m 设置堆的最小空间大小。&lt;/p&gt;
&lt;p&gt;-Xmx10m 设置堆的最大空间大小。&lt;/p&gt;
&lt;p&gt;-Xmn10m  设置年轻代大小&lt;/p&gt;
&lt;p&gt;-XX:NewSize=256m 设置新生代最小空间大小。&lt;/p&gt;
&lt;p&gt;-XX:MaxNewSize=256m 设置
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>类加载机制</title>
    <link href="http://www.iforfee.com/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.iforfee.com/java/jvm/类加载机制/</id>
    <published>2018-04-27T08:21:32.000Z</published>
    <updated>2018-04-27T14:06:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要关注点：</p><ul><li>什么是类的加载</li><li>类的生命周期</li><li>类加载器</li><li>双亲委派模型</li></ul><h1 id="什么是类的加载"><a href="#什么是类的加载" class="headerlink" title="什么是类的加载"></a>什么是类的加载</h1><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p><h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>类的生命周期包括这几个部分，加载、连接、初始化、使用和卸载，其中前三部是类的加载的过程,如下图；</p><p><img src="/images/java/jvm/class.png" alt="img"></p><ul><li>加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象</li><li>连接，连接又包含三块内容：验证、准备、初始化。1）验证，文件格式、元数据、字节码、符号引用验证；2）准备，为类的静态变量分配内存，并将其初始化为默认值；3）解析，把类中的符号引用转换为直接引用</li><li>初始化，为类的静态变量赋予正确的初始值</li><li>使用，new出对象程序中使用</li><li>卸载，执行垃圾回收</li></ul><p>其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备、初始化和卸载这5个阶段发生的顺序是确定的，<strong>而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持 Java 语言的运行时绑定（也成为动态绑定或晚期绑定）。</strong>另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（比如从jar包和war包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP文件转换成对应的Class类）。</p><ol><li>通过一个类的全限定名获取描述此类的二进制字节流；</li><li>将这个字节流所代表的静态存储结构保存为方法区的运行时数据结构；</li><li>在内存（并不一定是java堆，可能在方法区，取决于vm的实现）中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>这一阶段的主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><ol><li>文件格式</li><li>元数据</li><li>字节码</li><li>符号引用验证</li></ol><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> v = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure><p>实际上变量v在准备阶段过后的初始值为0而不是8080，将v赋值为8080的putstatic指令是程序被编译后，存放于类构造器&lt;clinit&gt;方法之中，这里我们后面会解释。<br>但是注意如果声明为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> v = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure><p>在编译阶段会为v生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将v赋值为8080。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是class文件中的：</p><ul><li>CONSTANT_Class_info</li><li>CONSTANT_Field_info</li><li>CONSTANT_Method_info</li></ul><p>等类型的常量。</p><p>下面我们解释一下符号引用和直接引用的概念：</p><ul><li>符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</li><li>直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>何时开始初始化：</p><p><strong>Java并没有规定什么时候开始第一个阶段：加载，但是Java虚拟机规范规定有且只有5种情况必须立即对类进行初始化（而加载、验证、准备自然需要在此之前开始）</strong><br>1）遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。<br>2）使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。<br>3）当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类初始化。<br>4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的），虚拟机会优先初始化这个主类。<br>5）当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic等时， 这个方法的类还没有进行过初始化，则需要先触发其初始化。</p><p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由JVM主导。到了初始阶段，才开始真正执行类中定义的Java程序代码。</p><p>初始化阶段是执行类构造器&lt;clinit&gt;方法的过程。&lt;clinit&gt;方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。&lt;clinit&gt;方法不需要显式调用父类的构造器，虚拟机会保证&lt;clinit&gt;方法执行之前，父类的&lt;clinit&gt;方法已经执行完毕。p.s: 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成&lt;clinit&gt;()方法。</p><p><strong>最后看一下接口的初始化过程与类初始化过程的不同。</strong><br>接口也有初始化过程，上面的代码中我们都是用静态语句块来输出初始化信息的，而在接口中不能使用“static{}”语句块，但编译器仍然会为接口生成&lt;clinit&gt;类构造器，用于初始化接口中定义的成员变量（实际上是static final修饰的全局常量）。<br>二者在初始化时最主要的区别是：当一个类在初始化时，要求其父类全部已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量），才会初始化该父接口。这点也与类初始化的情况很不同，调用类中的static final常量时并不会 触发该类的初始化，但是调用接口中的static final常量时便会触发该接口的初始化。</p><p>注意以下几种情况不会执行类初始化：</p><ul><li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</li><li>定义对象数组，不会触发该类的初始化。</li><li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。</li><li>通过类名获取Class对象，不会触发类的初始化。</li><li>通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。</li><li>通过ClassLoader默认的loadClass方法，也不会触发初始化动作。</li></ul><blockquote><p><em>几个小问题？</em><br><em>1、JVM初始化步骤 ？ 2、类初始化时机 ？3、哪几种情况下，Java虚拟机将结束生命周期？</em><br><em>答案参考这篇文章</em><a href="http://www.importnew.com/?p=23742" target="_blank" rel="noopener">JVM（1）：Java 类的加载机制</a></p></blockquote><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p><img src="/images/java/jvm/calssloader.png" alt="img"></p><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><ul><li>启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库</li><li>扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</li><li>应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器</li></ul><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><ul><li>全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li>父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li><li>缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li></ul><p>好处：</p><p>解决基础类的统一问题。比如位于rt.jar包中的类java.lang.Object，无论哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，确保了Object类在各种加载器环境中都是同一个类。</p><h2 id="双亲委托模型打破"><a href="#双亲委托模型打破" class="headerlink" title="双亲委托模型打破"></a>双亲委托模型打破</h2><ol><li><a href="https://blog.csdn.net/yangcheng33/article/details/52631940" target="_blank" rel="noopener">线程上下文类加载器（Thread Context Classloader）</a></li><li>OSGI</li></ol><p><a href="http://www.cnblogs.com/lanxuezaipiao/p/4138511.html" target="_blank" rel="noopener">http://www.cnblogs.com/lanxuezaipiao/p/4138511.html</a><br><a href="/java/SPI和DriverManager/">SPI和DriverManager</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">https://blog.csdn.net/briblue/article/details/54973413</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要关注点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是类的加载&lt;/li&gt;
&lt;li&gt;类的生命周期&lt;/li&gt;
&lt;li&gt;类加载器&lt;/li&gt;
&lt;li&gt;双亲委派模型&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;什么是类的加载&quot;&gt;&lt;a href=&quot;#什么是类的加载&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="java" scheme="http://www.iforfee.com/categories/java/"/>
    
    
      <category term="jvm" scheme="http://www.iforfee.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvm梳理</title>
    <link href="http://www.iforfee.com/java/jvm/jvm%E6%A2%B3%E7%90%86/"/>
    <id>http://www.iforfee.com/java/jvm/jvm梳理/</id>
    <published>2018-04-27T06:57:36.000Z</published>
    <updated>2018-04-27T08:25:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在江湖中要练就绝世武功必须内外兼备，精妙的招式和深厚的内功，武功的基础是内功。对于武功低（就像江南七怪）的人，招式更重要，因为他们不能靠内功直接去伤人，只能靠招式，利刃上优势来取胜了，但是练到高手之后，内功就更主要了。一个内功低的人招式在奇妙也打不过一个内功高的人。比如，你剑法再厉害，一剑刺过来，别人一掌打断你的剑，你还怎么使剑法，你一掌打到一个武功高的人身上，那人没什么事，却把你震伤了，你还怎么打。同样两者也是相辅相成的，内功深厚之后，原来普通的一招一式威力也会倍增。</p><p>对于搞开发的我们其实也是一样，现在流行的框架越来越多，封装的也越来越完善，各种框架可以搞定一切，几乎不用关注底层的实现，初级程序员只要熟悉基本的使用方法，便可以快速的开发上线；但对于高级程序员来讲，内功的修炼却越发的重要，比如算法、<a href="http://www.amazon.cn/gp/product/B001130JN8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=importnew-23&amp;linkCode=as2&amp;camp=536&amp;creative=3200&amp;creativeASIN=B001130JN8" target="_blank" rel="noopener">设计模式</a>、底层原理等，只有把这些基础熟练之后，才能在开发过程中知其然知其所以然，出现问题时能快速定位到问题的本质。</p><p>对于Java程序员来讲，spring全家桶几乎可以搞定一切，spring全家桶便是精妙的招式，jvm就是内功心法很重要的一块，线上出现性能问题，jvm调优更是不可回避的问题。因此JVM基础知识对于高级程序员的重要性不必言语，我司在面试高级开发的时候，jvm相关知识也必定是考核的标准之一。本篇文章会根据之前写的jvm系列文章梳理出jvm需要关注的所有考察点。</p><h2 id="jvm-总体梳理"><a href="#jvm-总体梳理" class="headerlink" title="jvm 总体梳理"></a>jvm 总体梳理</h2><p>jvm体系总体分四大块：</p><ul><li>类的加载机制</li><li>jvm内存结构</li><li>GC算法 垃圾回收</li><li>GC分析 命令调优</li></ul><p><em>当然这些知识点在之前的文章中都有详细的介绍，这里只做主干的梳理</em></p><p>这里画了一个思维导图，将所有的知识点进行了陈列，因为图比较大可以点击右键下载了放大查看。</p><p><img src="/images/java/jvm/JVM.jpg" alt="img"></p><h2 id="类的加载机制"><a href="#类的加载机制" class="headerlink" title="类的加载机制"></a>类的加载机制</h2><p>主要关注点：</p><ul><li>什么是类的加载</li><li>类的生命周期</li><li>类加载器</li><li>双亲委派模型</li></ul><p><a href="/java/jvm/类加载机制">类加载机制</a></p><h2 id="jvm内存结构"><a href="#jvm内存结构" class="headerlink" title="jvm内存结构"></a>jvm内存结构</h2><p>主要关注点：</p><ul><li>jvm内存结构都是什么</li><li>对象分配规则</li></ul><p>jvm内存结构</p><p><a href="/java/jvm内存模型">jvm内存模型</a></p><p>对象分配规则</p><p><a href="/java/jvm内存模型">对象分配规则</a></p><blockquote><p><em>如何通过参数来控制个各个内存区域</em><br><em>参考此文章：</em><a href="http://www.importnew.com/?p=23746" target="_blank" rel="noopener">JVM（2）：JVM内存结构</a></p></blockquote><h2 id="GC算法-垃圾回收"><a href="#GC算法-垃圾回收" class="headerlink" title="GC算法 垃圾回收"></a>GC算法 垃圾回收</h2><p>主要关注点：</p><ul><li>对象存活判断</li><li>GC算法</li><li>垃圾回收器</li></ul><p><a href="/java/jvm/GC/">GC</a></p><blockquote><p><em>GC算法和垃圾回收器算法图解以及更详细内容参考</em><a href="http://www.importnew.com/?p=23752" target="_blank" rel="noopener">JVM（3）：Java GC算法 垃圾收集器</a></p></blockquote><h2 id="GC分析-命令调优"><a href="#GC分析-命令调优" class="headerlink" title="GC分析 命令调优"></a>GC分析 命令调优</h2><p>主要关注点：</p><ul><li>GC日志分析</li><li>调优命令</li><li>调优工具</li></ul><p>GC日志分析</p><p>摘录GC日志一部分（前部分为年轻代gc回收；后部分为full gc回收）：</p><p>通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数</p><p>young gc 日志:</p><p><img src="/images/java/jvm/yong.jpg" alt="img"></p><p>Full GC日志:</p><p><img src="/images/java/jvm/full.jpg" alt="img"></p><p>调优命令</p><p>Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo</p><ul><li>jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</li><li>jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</li><li>jmap，JVM Memory Map命令用于生成heap dump文件</li><li>jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看</li><li>jstack，用于生成java虚拟机当前时刻的线程快照。</li><li>jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。</li></ul><blockquote><p><em>详细的命令使用参考这里</em><a href="http://www.importnew.com/?p=23761" target="_blank" rel="noopener">JVM（4）：Jvm调优-命令篇</a></p></blockquote><p>调优工具</p><p>常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。</p><ul><li>jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控</li><li>jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。</li><li>MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗</li><li>GChisto，一款专业分析gc日志的工具</li></ul><blockquote><p><em>工具使用参考</em><a href="http://www.importnew.com/?p=23786" target="_blank" rel="noopener">JVM（7）：JVM调优-工具篇</a></p></blockquote><h3 id="本系列："><a href="#本系列：" class="headerlink" title="本系列："></a>本系列：</h3><ul><li><a href="http://www.importnew.com/?p=23742" target="_blank" rel="noopener">JVM（1）：Java 类的加载机制</a></li><li><a href="http://www.importnew.com/?p=23746" target="_blank" rel="noopener">JVM（2）：JVM内存结构</a></li><li><a href="http://www.importnew.com/?p=23752" target="_blank" rel="noopener">JVM（3）：Java GC算法 垃圾收集器</a></li><li><a href="http://www.importnew.com/?p=23761" target="_blank" rel="noopener">JVM（4）：Jvm调优-命令篇</a></li><li><a href="http://www.importnew.com/?p=23774" target="_blank" rel="noopener">JVM（5）：tomcat性能调优和性能监控（visualvm）</a></li><li><a href="http://www.importnew.com/?p=23780" target="_blank" rel="noopener">JVM（6）：JVM调优-从eclipse开始</a></li><li><a href="http://www.importnew.com/?p=23786" target="_blank" rel="noopener">JVM（7）：JVM调优-工具篇</a></li><li><a href="http://www.importnew.com/?p=23792" target="_blank" rel="noopener">JVM（8）：JVM知识点总览-高级Java工程师面试必备</a></li><li><a href="http://www.importnew.com/25295.html" target="_blank" rel="noopener">http://www.importnew.com/25295.html</a></li><li><a href="https://www.ziwenxie.site/2017/06/07/java-jvm-classloader/" target="_blank" rel="noopener">https://www.ziwenxie.site/2017/06/07/java-jvm-classloader/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在江湖中要练就绝世武功必须内外兼备，精妙的招式和深厚的内功，武功的基础是内功。对于武功低（就像江南七怪）的人，招式更重要，因为他们不能靠内功直接去伤人，只能靠招式，利刃上优势来取胜了，但是练到高手之后，内功就更主要了。一个内功低的人招式在奇妙也打不过一个内功高的人。比如，你
      
    
    </summary>
    
      <category term="java" scheme="http://www.iforfee.com/categories/java/"/>
    
    
      <category term="jvm" scheme="http://www.iforfee.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>关于幽默</title>
    <link href="http://www.iforfee.com/%E5%B9%BD%E9%BB%98/"/>
    <id>http://www.iforfee.com/幽默/</id>
    <published>2018-04-27T06:23:13.000Z</published>
    <updated>2018-04-27T06:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>男生怎么让自己变得幽默风趣</p><p>要练口才,内功第一</p><p>很多人觉得,风趣幽默就好像一种技能一样,能够速成。其实没那么简单的,就像所有武功一样,要练招式,必须内功先行。对于口才而言,所谓的内功,就是内涵,就是阅读量,就是多读书。</p><p>要活用段子</p><p>在这里举个例子吧:男:Hi,我想借一下纸巾。女:给你。男:谢谢,你电话多少,我改天还你。女:不用了。接下来要怎么破呢?你是不是就放弃了?千万不要啊。你可以这样接话:早知道问你借钱了。总之,想变得幽默,就不能按照套路出牌啊!</p><p>零门槛幽默大法,自黑无底线</p><p>有一句话说得好,黑到深处自然粉,被黑到深处自然红。懂自黑、自嘲的人,更自信、更大度,表现出来更懂得分寸和尊重别人,简直就是活生生的段子手啊!自己有什么缺点,比如矮,比如黑,比如学历低,比如挣得少,比如不聪明……。不要等别人拿你开涮,自己先拿自己开涮,这样其他人也就无话可说了!</p><p>熟悉各种网络梗,很有必要</p><p>如果说80后是互联网移民,现在的90后、00后妹子,就是互联网的原住民,她们天然地熟悉各种网络梗、各种网络段子。比如”不管你信不信,反正我信了”,”100块钱都不给我”,”我只想做一个安静的美男子”等句子,一定要在生活中活学活用,会很容易拉进与妹子的距离的!</p><p>善于运用逆向思维</p><p>比如和妹子在一起,迎面走来一只小狗,妹子想必会抱住它亲切交流,这时候,你上去亲切地叫一声”喵”,妹子会是什么反应呢?一定会觉得你这个人挺有意思的,很有生活情趣。</p><p>男生必学的5种幽默方式</p><p>曲解式幽默</p><p>什么叫曲解?就是把意思理解歪了。尤其是在恋爱中。举个例子:男:你吃饭了吗?女:干嘛?男:不干!</p><p>上面的例子大家看出来了吗?歪曲女孩的话的意思。这里不仅在在和女孩聊天,朋友,公共场合都可以使用的。看了这条回复,都会认为你是个很幽默的人,并不是色。</p><p>夸大式幽默</p><p>什么叫夸大?就是一件平常的事扩大化。尤其是对方在做某一件事的时候。例:女:你蹲在那里干嘛呢?男:我在测试地球的吸引力有多大。</p><p>这样的一件平常的事,蹲在那里还能干嘛?找东西,厕所,这都是平常的事说的跟专家似的,听起来是不是让人笑呢?可以去和女孩子试试哦。</p><p>缩小式幽默</p><p>既然有扩大,那么必有缩小。可以让大事化小小事化了的幽默。例子:女:你今天彻底把我惹毛了,我以后再也不理你了。男:我哪有惹毛你了。你的头发我都没碰一下!女:滚!男:好呀,晚上我滚床单给你暖床。</p><p>女生很怒火了,可是在你简简单单的两句话中,就直接转移话题,大事化小,最后直接说成你们两个人别的事了。是不是很强大呢?可以去试试。效果威力绝对大!</p><p>目的式曲解</p><p>目的是,把别人说话的目的直接曲解,引起对方的好奇与笑点。例:女:我现在只想把你送到外星球上!男:这样做是不是太花钱了呀?</p><p>目的式曲解,一种是迎着对方的目的去说,一种是嘲讽对方。大家谨慎使用。</p><p>日常式幽默</p><p>这种幽默用的太多了。我们平常是不是用过呢?举例:女:谢谢你。男:不用谢,请叫我雷锋。女:你看我是不是很漂亮呢?男:仔细看很漂亮。不过得仔细看!(内涵式幽默)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;男生怎么让自己变得幽默风趣&lt;/p&gt;
&lt;p&gt;要练口才,内功第一&lt;/p&gt;
&lt;p&gt;很多人觉得,风趣幽默就好像一种技能一样,能够速成。其实没那么简单的,就像所有武功一样,要练招式,必须内功先行。对于口才而言,所谓的内功,就是内涵,就是阅读量,就是多读书。&lt;/p&gt;
&lt;p&gt;要活用段子&lt;
      
    
    </summary>
    
      <category term="聊天" scheme="http://www.iforfee.com/categories/%E8%81%8A%E5%A4%A9/"/>
    
    
      <category term="幽默" scheme="http://www.iforfee.com/tags/%E5%B9%BD%E9%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>拒绝输出是荒废一个人最好的办法</title>
    <link href="http://www.iforfee.com/%E8%81%8A%E5%A4%A9/%E6%8B%92%E7%BB%9D%E8%BE%93%E5%87%BA%E6%98%AF%E8%8D%92%E5%BA%9F%E4%B8%80%E4%B8%AA%E4%BA%BA%E6%9C%80%E5%A5%BD%E7%9A%84%E5%8A%9E%E6%B3%95/"/>
    <id>http://www.iforfee.com/聊天/拒绝输出是荒废一个人最好的办法/</id>
    <published>2018-04-27T06:17:06.000Z</published>
    <updated>2018-04-27T06:21:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>你是这样的人么？</p><p>沉溺于「轻易获得高成就感」的事情，比如打游戏比如等朋友圈的点赞。</p><p>只接收「低信息密度」的信息源。比如不看书，就爱看新闻和八卦。</p><p>习惯用「错位成就感」麻痹自己。比如把自己擅长的和别人不擅长的比，甚至总爱和别人比，没有内部计分卡，不关心自我成长。</p><p><img src="http://m.gmw.cn/thumb/d/data/attachement/jpg/site2/20180316/2108794795406965349.jpg" alt="拒绝输出是荒废一个人最好的办法"></p><p>我们每个人的生活，基本上都是信息的投入产出组成的，你看视频，刷新闻，读公众号，都是一种输入，当你开始输出的时候，你的投入才会通过大脑的思考和逻辑，内化成对你而言有价值的东西。</p><p>因此，不论是打游戏成瘾，还是看电视剧看到疯魔，在我眼里，都是一种失控的输入，是一种零输出，是一种对生活完全的透支。</p><p>最可怕的地方在于，输出的能力是需要培养和训练的。就好比我们高中的时候，练作文，你光看范文半点用没有，必须自己动笔写才会有提高。</p><p>一个人如果很长时间不输出自己的知识，自然就没有兴趣去做这件事，继而更加不会锻炼到这种能力，这样的恶性循环，就会导致被吸收的知识不断被遗忘，知识变成废料。</p><p>而这，也是生活中大多数人每天在做的事。想想你上次看的公众号内容，你还记得多少呢？</p><p>但是碎片化的内容也是能够让你保持成长的，只要你这么做↓</p><p><img src="http://m.gmw.cn/thumb/d/data/attachement/jpg/site2/20180316/821851032469483690.jpg" alt="拒绝输出是荒废一个人最好的办法"></p><p>1、先花一点时间，建立自己的知识体系。</p><p>把你已经知道的东西梳理一遍。如何梳理呢？以你能够说出某个知识点的影响因素，以及它对其他事物的影响为准。顺着这样的知识点捋一遍，这个网络就是你已经构建完成的知识网络。</p><p>2、找到知识网络的触点。</p><p>亦即自己感兴趣的、但尚未进行探索和了解的知识点。</p><p>阅读、学习的时候，有意识地去接触这些触点的知识，延展自己的知识网络。</p><p>3、当接触到一个新的知识点时，先考虑如何将其纳入知识体系。</p><p>亦即在脑子里回想你的知识网络，思考它可以如何跟你已经知道的东西联系起来。</p><p>4、如果找到了对应的点，弄通路径。</p><p>亦即，将这个新的知识点，跟已经知道的某个点之间的路径，查清楚、弄清楚，将它们连接起来，使这个知识点成为你新的“触点”，拓展你的思维网络。</p><p>5、检验并输出。</p><p>将这两个点之间的联系讲清楚。最简单的办法，就是通过口述、写文章，去教会别人这个知识。或者，在心里把它讲一遍，看是否能够讲得清晰易懂，没有障碍。只有能够输出的东西，才是真正属于你的东西。</p><p>6、不符合以上方式的内容，果断舍弃。</p><p>如果一个东西无法纳入你的认知体系，那说明你现在还不能掌握它，那就果断放弃，因为它对你来说是没有价值的，或者说（记忆的）成本是远高于收益的。</p><p><img src="http://m.gmw.cn/thumb/d/data/attachement/jpg/site2/20180316/9035705576979975622.jpg" alt="拒绝输出是荒废一个人最好的办法"></p><p>再多谈几点：</p><p>1、读书不用追求“读完一本书”，而应该追求“从这本书中获得了什么东西”。</p><p>一本书的内容不可能100%对你有用，其中肯定有你所不感兴趣的东西，也有你所无法接受的东西，没关系，接受你所能接受的即可。不用务求全部读完。甚至，读一半，放回去，再跳着读别的书，也是很好的方式。读书应该为自己所用，而不是让自己去迁就它。</p><p>2、如何处理微博上、知乎上那些有趣的碎片化知识？</p><p>个人建议，最好的方式，是将它们作为起点。如果你觉得一个知识很有趣，就以它为出发点，去探索它背后的原理、背景、应用，去查资料、GOOGLE，顺藤摸瓜。这个知识点本身是没有太大价值的，有价值的是你去探索的过程。你经过探索了解到的东西，才能纳入你的知识体系，成为你思维的一部分。</p><p>3、以上种种都需要不菲的时间，但学习本就是一件艰难的事情，所以优秀的人永远是凤毛麟角，所谓聪明的人，无非他们把走路、等车、休息等更多的时间花在这上面罢了。再说，学习本身，岂非也是一件很有趣的事情？</p><p>版权声明：如涉及版权问题，请作者持权属证明与本网联系</p><p><a href="http://m.gmw.cn/toutiao/2018-04/26/content_120791964.htm" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你是这样的人么？&lt;/p&gt;
&lt;p&gt;沉溺于「轻易获得高成就感」的事情，比如打游戏比如等朋友圈的点赞。&lt;/p&gt;
&lt;p&gt;只接收「低信息密度」的信息源。比如不看书，就爱看新闻和八卦。&lt;/p&gt;
&lt;p&gt;习惯用「错位成就感」麻痹自己。比如把自己擅长的和别人不擅长的比，甚至总爱和别人比，没有
      
    
    </summary>
    
      <category term="阅读" scheme="http://www.iforfee.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="碎片化" scheme="http://www.iforfee.com/tags/%E7%A2%8E%E7%89%87%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>生活语录</title>
    <link href="http://www.iforfee.com/%E7%94%9F%E6%B4%BB%E8%AF%AD%E5%BD%95/"/>
    <id>http://www.iforfee.com/生活语录/</id>
    <published>2018-04-26T06:34:20.000Z</published>
    <updated>2018-04-26T06:35:17.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>关于读书，掌握重点就好，细节的东西，往往来自经验。</li><li>事务的出现是因为有使用的需要，所以掌握事务的第一关键是学会使用。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;关于读书，掌握重点就好，细节的东西，往往来自经验。&lt;/li&gt;
&lt;li&gt;事务的出现是因为有使用的需要，所以掌握事务的第一关键是学会使用。&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>G1 GC</title>
    <link href="http://www.iforfee.com/java/G1GC/"/>
    <id>http://www.iforfee.com/java/G1GC/</id>
    <published>2018-04-24T07:29:17.000Z</published>
    <updated>2018-04-24T13:38:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GarbageFirst（G1）"><a href="#GarbageFirst（G1）" class="headerlink" title="GarbageFirst（G1）"></a>GarbageFirst（G1）</h1><p><strong>G1（Garbage-First）</strong>收集器是当今收集器技术发展最前沿的成果之一，它是一款<strong>面向服务端应用</strong>的垃圾收集器，HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：</p><ul><li><strong>并行与并发</strong> G1 能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li><li><strong>分代收集</strong> 与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次GC的旧对象来获取更好的收集效果。</li><li><strong>空间整合</strong> G1从整体来看是基于<strong>“标记-整理”</strong>算法实现的收集器，从局部（两个Region之间）上来看是基于<strong>“复制”</strong>算法实现的。这意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。此特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</li><li><strong>可预测的停顿</strong> 这是G1相对CMS的一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li></ul><h2 id="内存划分Region"><a href="#内存划分Region" class="headerlink" title="内存划分Region"></a>内存划分Region</h2><p>G1算法将堆划分为若干个区域（Region），它仍然属于分代收集器。不过，这些区域的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间。老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了。</p><p><img src="/images/image-20180420173712264.png" alt="image-20180420173712264"></p><p>在G1中，还有一种特殊的区域，叫Humongous区域。 <strong>如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象</strong>。这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。</p><p>PS：在java 8中，持久代也移动到了普通的堆内存空间中，改为元空间。</p><p><strong>对象分配策略</strong></p><p>说起大对象的分配，我们不得不谈谈对象的分配策略。它分为3个阶段：</p><ol><li>TLAB(Thread Local Allocation Buffer)线程本地分配缓冲区</li><li>Eden区中分配</li><li>Humongous区分配</li></ol><p>TLAB为线程本地分配缓冲区，它的目的为了使对象尽可能快的分配出来。如果对象在一个共享的空间中分配，我们需要采用一些同步机制来管理这些空间内的空闲空间指针。在Eden空间中，每一个线程都有一个固定的分区用于分配对象，即一个TLAB。分配对象时，线程之间不再需要进行任何的同步。</p><p>对TLAB空间中无法分配的对象，JVM会尝试在Eden空间中进行分配。如果Eden空间无法容纳该对象，就只能在老年代中进行分配空间。</p><p><strong>建立可预测的时间模型</strong></p><p>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以<strong>有计划地避免在整个Java堆中进行全区域的垃圾收集</strong>。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），<strong>在后台维护一个优先列表</strong>，每次根据允许的收集时间，<strong>优先回收价值最大的Region（这也就是Garbage-First名称的来由）</strong>。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p><p><strong>避免全堆扫描——Remembered Set</strong></p><p>G1把Java堆分为多个Region，就是“化整为零”。但是Region不可能是孤立的，一个对象分配在某个Region中，可以与整个Java堆任意的对象发生引用关系。在做可达性分析确定对象是否存活的时候，需要扫描整个Java堆才能保证准确性，这显然是对GC效率的极大伤害。</p><p>为了避免全堆扫描的发生，虚拟机<strong>为G1中每个Region维护了一个与之对应的Remembered Set</strong>。虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable<strong>把相关引用信息记录到被引用对象所属的Region的Remembered Set之中</strong>。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p><p>如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：</p><ul><li><strong>初始标记（Initial Marking）</strong> 仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改<strong>TAMS（Nest Top Mark Start）</strong>的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要<strong>停顿线程</strong>，但耗时很短。</li><li><strong>并发标记（Concurrent Marking）</strong> 从GC Root 开始对堆中对象进行<strong>可达性分析</strong>，找到存活对象，此阶段耗时较长，但<strong>可与用户程序并发执行</strong>。</li><li><strong>最终标记（Final Marking）</strong> 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在<strong>线程的Remembered Set Logs</strong>里面，最终标记阶段需要<strong>把Remembered Set Logs的数据合并到Remembered Set中</strong>，这阶段需要<strong>停顿线程</strong>，但是<strong>可并行执行</strong>。</li><li><strong>筛选回收（Live Data Counting and Evacuation）</strong> 首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p><img src="/images/0bce1667.png" alt="img"></p><h2 id="GC模式"><a href="#GC模式" class="headerlink" title="GC模式"></a>GC模式</h2><h3 id="G1-Young-GC"><a href="#G1-Young-GC" class="headerlink" title="G1 Young GC"></a>G1 Young GC</h3><p>Young GC主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。在这种情况下，Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到年老代空间。Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。最终Eden空间的数据为空，GC停止工作，应用线程继续执行。</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/50877d4b41c80010b1f131de5759b689.png" target="_blank" rel="noopener"><img src="/images/50877d4b41c80010b1f131de5759b689.png" alt="3"></a></p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/a245f9decda81cbf12f69412d38f3177.png" target="_blank" rel="noopener"><img src="/images/a245f9decda81cbf12f69412d38f3177.png" alt="4"></a></p><p>这时，我们需要考虑一个问题，如果仅仅GC 新生代对象，我们如何找到所有的根对象呢？ 老年代的所有对象都是根么？那这样扫描下来会耗费大量的时间。于是，G1引进了RSet的概念。它的全称是Remembered Set，作用是跟踪指向某个heap区内的对象引用。</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/bd7d9f4a8e43312cb189863a568c4630.png" target="_blank" rel="noopener"><img src="/images/bd7d9f4a8e43312cb189863a568c4630.png" alt="5"></a></p><p>在CMS中，也有RSet的概念，在老年代中有一块区域用来记录指向新生代的引用。这是一种point-out，在进行Young GC时，扫描根时，仅仅需要扫描这一块区域，而不需要扫描整个老年代。</p><p>但在G1中，并没有使用point-out，这是由于一个分区太小，分区数量太多，如果是用point-out的话，会造成大量的扫描浪费，有些根本不需要GC的分区引用也扫描了。于是G1中使用point-in来解决。point-in的意思是哪些分区引用了当前分区中的对象。这样，仅仅将这些对象当做根来扫描就避免了无效的扫描。由于新生代有多个，那么我们需要在新生代之间记录引用吗？这是不必要的，原因在于每次GC时，所有新生代都会被扫描，所以只需要记录老年代到新生代之间的引用即可。</p><p>需要注意的是，如果引用的对象很多，赋值器需要对每个引用做处理，赋值器开销会很大，为了解决赋值器开销这个问题，在G1 中又引入了另外一个概念，卡表（Card Table）。一个Card Table将一个分区在逻辑上划分为固定大小的连续区域，每个区域称之为卡。卡通常较小，介于128到512字节之间。Card Table通常为字节数组，由Card的索引（即数组下标）来标识每个分区的空间地址。默认情况下，每个卡都未被引用。当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为”0″，即标记为脏被引用，此外RSet也将这个数组下标记录下来。一般情况下，这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。</p><p>Young GC 阶段：</p><ul><li>阶段1：根扫描<br>静态和本地对象被扫描</li><li>阶段2：更新RS<br>处理dirty card队列更新RS</li><li>阶段3：处理RS<br>检测从年轻代指向年老代的对象</li><li>阶段4：对象拷贝<br>拷贝存活的对象到survivor/old区域</li><li>阶段5：处理引用队列<br>软引用，弱引用，虚引用处理</li></ul><h3 id="G1-Mix-GC"><a href="#G1-Mix-GC" class="headerlink" title="G1 Mix GC"></a>G1 Mix GC</h3><p>Mix GC是伴随着Young GC一起发生的。</p><p>Mix GC不仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的老年代分区。</p><p>它的GC步骤分2步：</p><ol><li>全局并发标记（global concurrent marking）</li><li>拷贝存活对象（evacuation）</li></ol><p>在进行Mix GC之前，会先进行global concurrent marking（全局并发标记）。 global concurrent marking的执行过程是怎样的呢？</p><p>在G1 GC中，它主要是为Mixed GC提供标记服务的，并不是一次GC过程的一个必须环节。global concurrent marking的执行过程分为五个步骤：</p><table><thead><tr><th>Phase</th><th>Description</th></tr></thead><tbody><tr><td>(1) Initial Mark<em>(Stop the World Event)</em><br>初始标记</td><td>This is a stop the world event. With G1, it is piggybacked on a normal young GC. Mark survivor regions (root regions) which may have references to objects in old generation.<br>是STW的事件，并且依赖于young GC的发生。标记survivor regions作为root regions，因为它可能有指向老年代的引用。</td></tr><tr><td>(2) Root Region Scanning<br>root region 扫描</td><td>Scan survivor regions for references into the old generation. This happens while the application continues to run. The phase must be completed before a young GC can occur.<br>扫描survivor regions 中指向 old generation 的引用。同时，应用还在继续执行。这个阶段必须在young GC发生之前完成。</td></tr><tr><td>(3) Concurrent Marking<br>并发标记</td><td>Find live objects over the entire heap. This happens while the application is running. This phase can be interrupted by young generation garbage collections.<br>找到整个heap 中存活的对象。同时，应用程序继续执行。这个阶段可以被young GC中断。</td></tr><tr><td>(4) Remark<em>(Stop the World Event)</em><br>最终标记</td><td>Completes the marking of live object in the heap. Uses an algorithm called snapshot-at-the-beginning (SATB) which is much faster than what was used in the CMS collector.<br>使用SATB算法完成heap中活对象的标记。</td></tr><tr><td>(5) Cleanup<em>(Stop the World Event and Concurrent)</em></td><td>- Performs accounting on live objects and completely free regions. (Stop the world)<br>- Scrubs the Remembered Sets. (Stop the world)<br>- Reset the empty regions and return them to the free list. (Concurrent)<br>- 计算存活对象和完全空闲的regions。<br>- 重置remember set。 <br>- 重置空闲regions，并放入空闲列表中。</td></tr><tr><td>(<em>) Copying</em>(Stop the World Event)*</td><td>These are the stop the world pauses to evacuate or copy live objects to new unused regions. This can be done with young generation regions which are logged as <code>[GC pause (young)]</code>. Or both young and old generation regions which are logged as <code>[GC Pause (mixed)]</code>.<br>计算并拷贝存活对象到新的regions中。这个阶段可能发生在yong GC 和mixed GC 中。</td></tr></tbody></table><p><strong>三色标记算法</strong></p><p>提到并发标记，我们不得不了解并发标记的三色标记算法。它是描述追踪式回收器的一种有用的方法，利用它可以推演回收器的正确性。 首先，我们将对象分成三种类型的。</p><ul><li>黑色:根对象，或者该对象与它的子对象都被扫描</li><li>灰色:对象本身被扫描,但还没扫描完该对象中的子对象</li><li>白色:未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象</li></ul><p>当GC开始扫描对象时，按照如下图步骤进行对象的扫描：</p><p>根对象被置为黑色，子对象被置为灰色。</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/8efbc44ba3b845e6086a83377e912bb9.png" target="_blank" rel="noopener"><img src="/images/8efbc44ba3b845e6086a83377e912bb9.png" alt="6"></a></p><p>继续由灰色遍历,将已扫描了子对象的对象置为黑色。</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/f56ab01de2138dc3b4a4bb3d50f54594.png" target="_blank" rel="noopener"><img src="/images/f56ab01de2138dc3b4a4bb3d50f54594.png" alt="7"></a></p><p>遍历了所有可达的对象后，所有可达的对象都变成了黑色。不可达的对象即为白色，需要被清理。<br><a href="http://jbcdn2.b0.upaiyun.com/2016/12/c4f581fd4a8877375d54a55e4af27841.png" target="_blank" rel="noopener"><img src="/images/c4f581fd4a8877375d54a55e4af27841.png" alt="8"></a></p><p>这看起来很美好，但是如果在标记过程中，应用程序也在运行，那么对象的指针就有可能改变。这样的话，我们就会遇到一个问题：对象丢失问题</p><p>我们看下面一种情况，当垃圾收集器扫描到下面情况时：</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/5dd0686b02e1898ec1a987c2e1571548.png" target="_blank" rel="noopener"><img src="/images/5dd0686b02e1898ec1a987c2e1571548.png" alt="9"></a></p><p>这时候应用程序执行了以下操作：</p><blockquote><p>A.c=C<br>B.c=null</p></blockquote><p>这样，对象的状态图变成如下情形：</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/78ad6fbc199fca514a5336b2167bd8f7.png" target="_blank" rel="noopener"><img src="/images/78ad6fbc199fca514a5336b2167bd8f7.png" alt="10"></a></p><p>这时候垃圾收集器再标记扫描的时候就会下图成这样：</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/f4765bacd1941792df63c6296ad12e3a.png" target="_blank" rel="noopener"><img src="/images/f4765bacd1941792df63c6296ad12e3a.png" alt="11"></a></p><p>很显然，此时C是白色，被认为是垃圾需要清理掉，显然这是不合理的。那么我们如何保证应用程序在运行的时候，GC标记的对象不丢失呢？有如下2中可行的方式：</p><ol><li>在插入的时候记录对象</li><li>在删除的时候记录对象</li></ol><p>刚好这对应CMS和G1的2种不同实现方式：</p><p>在CMS采用的是增量更新（Incremental update），只要在写屏障（write barrier）里发现要有一个白对象的引用被赋值到一个黑对象 的字段里，那就把这个白对象变成灰色的。即插入的时候记录下来。</p><p>在G1中，使用的是STAB（snapshot-at-the-beginning）的方式，删除的时候记录所有的对象，它有3个步骤：</p><p>1，在开始标记的时候生成一个快照图标记存活对象</p><p>2，在并发标记的时候所有被改变的对象入队（在write barrier里把所有旧的引用所指向的对象都变成非白的）</p><p>3，可能存在游离的垃圾，将在下次被收集</p><p>这样，G1到现在可以知道哪些老的分区可回收垃圾最多。 当全局并发标记完成后，在某个时刻，就开始了Mix GC。这些垃圾回收被称作“混合式”是因为他们不仅仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的分区。混合式垃圾收集如下图：</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/0860c63775ccbc265095b5a844f0d381.png" target="_blank" rel="noopener"><img src="/images/0860c63775ccbc265095b5a844f0d381.png" alt="12"></a></p><p>混合式GC也是采用的复制的清理策略，当GC完成后，会重新释放空间。</p><p><a href="http://jbcdn2.b0.upaiyun.com/2016/12/599b50c478126754a1cc614a85b149bd.png" target="_blank" rel="noopener"><img src="/images/599b50c478126754a1cc614a85b149bd.png" alt="13"></a></p><p>至此，混合式GC告一段落了。下一小节我们讲进入调优实践。</p><h3 id="G1-Full-GC"><a href="#G1-Full-GC" class="headerlink" title="G1 Full GC"></a>G1 Full GC</h3><p>如果对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发一次full gc，G1的full gc算法就是单线程执行的serial old gc，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免full gc.</p><h1 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h1><h2 id="Remember-Set和Card-Table"><a href="#Remember-Set和Card-Table" class="headerlink" title="Remember Set和Card Table"></a>Remember Set和Card Table</h2><p>RS(Remember Set)是一种抽象概念，用于记录从非收集部分指向收集部分的指针的集合。<br>在传统的分代垃圾回收算法里面，RS(Remember Set)被用来记录分代之间的指针。在G1回收器里面，RS被用来记录从其他Region指向一个Region的指针情况。因此，一个Region就会有一个RS。这种记录可以带来一个极大的好处：在回收一个Region的时候不需要执行全堆扫描，只需要检查它的RS就可以找到外部引用，而这些引用就是initial mark的根之一。</p><p>那么，如果一个线程修改了Region内部的引用，就必须要去通知RS，更改其中的记录。为了达到这种目的，G1回收器引入了一种新的结构，CT(Card Table)——卡表。每一个Region，又被分成了固定大小的若干张卡(Card)。每一张卡，都用一个Byte来记录是否修改过。卡表即这些byte的集合。实际上，如果把RS理解成一个概念模型，那么CT就可以说是RS的一种实现方式。</p><blockquote><p>从第一感觉，或者出于直觉的考虑，使用一个bit来记录一张卡是否被修改过，就已经足够了。而使用一个byte会造成更多的空间开销。但是实际上，使用一个byte来记录一张卡是否被修改过，会比使用一个bit来记录效率更高。更多细节参阅资料3。</p></blockquote><p>在RS的修改上也会遇到并发的问题。因为一个Region可能有多个线程在并发修改，因此它们也会并发修改RS。为了避免这样一种冲突，G1垃圾回收器进一步把RS划分成了多个哈希表。每一个线程都在各自的哈希表里面修改。最终，从逻辑上来说，RS就是这些哈希表的集合。哈希表是实现RS的一种通常的方式之一。它有一个极大的好处就是能够去除重复。这意味着，RS的大小将和修改的指针数量相当。而在不去重的情况下，RS的数量和写操作的数量相当。</p><p>整个关系如下：</p><p><img src="/images/693.png" alt="img"></p><p>Remember Set</p><p>图中RS的虚线表名的是，RS并不是一个和Card Table独立的，不同的数据结构，而是指RS是一个概念模型。实际上，Card Table是RS的一种实现方式。</p><h3 id="Remember-Set的写屏障"><a href="#Remember-Set的写屏障" class="headerlink" title="Remember Set的写屏障"></a>Remember Set的写屏障</h3><p>写屏障是指，在改变特定内存的值（实际上也就是写入内存）的时候额外执行的一些动作。在大多数的垃圾回收算法中，都利用到了写屏障。写屏障通常用于在运行时探测并记录回收相关指针(interesting pointer)，在回收器只回收堆中部分区域的时候，任何来自该区域外的指针都需要被写屏障捕获，这些指针将会在垃圾回收的时候作为标记开始的根。JAVA使用的其余的分代的垃圾回收器，都有写屏障。举例来说，每一次将一个老年代对象的引用修改为指向年轻代对象，都会被写屏障捕获，并且记录下来。因此在年轻代回收的时候，就可以避免扫描整个老年代来查找根。</p><p>G1垃圾回收器的写屏障和RS是相辅相成的，也就是记录Region内部的指针。这种记录发生在写操作之后。对于一个写屏障来说，过滤掉不必要的写操作是十分有必要的。这种过滤既能加快赋值器的速度，也能减轻回收器的负担。G1垃圾回收器采用的双重过滤</p><ol><li>过滤掉同一个Region内部引用；</li><li>过滤掉空引用；</li></ol><p>过滤掉这两个部分之后，可以使RS的大小大大减小。</p><p>G1的垃圾回收器的写屏障使用一种两级的log buffer结构：</p><ol><li>global set of filled buffer：所有线程共享的一个全局的，存放填满了的log buffer的集合；</li><li>thread log buffer：每个线程自己的log buffer。所有的线程都会把写屏障的记录先放进去自己的log buffer中，装满了之后，就会把log buffer放到 global set of filled buffer中，而后再申请一个log buffer；</li></ol><h2 id="Collect-Set"><a href="#Collect-Set" class="headerlink" title="Collect Set"></a>Collect Set</h2><p>Collect Set(CSet)是指，在Evacuation阶段，由G1垃圾回收器选择的待回收的Region集合。G1垃圾回收器的软实时的特性就是通过CSet的选择来实现的。对应于算法的两种模式fully-young generational mode和partially-young mode，CSet的选择可以分成两种：</p><ol><li>在fully-young generational mode下：顾名思义，该模式下CSet将只包含young的Region。G1将调整young的Region的数量来匹配软实时的目标；</li><li>在partially-young mode下：该模式会选择所有的young region，并且选择一部分的old region。old region的选择将依据在Marking cycle phase中对存活对象的计数。G1选择存活对象最少的Region进行回收。</li></ol><h2 id="SATB-snapshot-at-the-beginning"><a href="#SATB-snapshot-at-the-beginning" class="headerlink" title="SATB(snapshot-at-the-beginning)"></a>SATB(snapshot-at-the-beginning)</h2><p>SATB(snapshot-at-the-beginning)，是最开始用于实时垃圾回收器的一种技术。G1垃圾回收器使用该技术在标记阶段记录一个存活对象的快照(“logically takes a snapshot of the set of live objects in the heap at the start of marking cycle”)。然而在并发标记阶段，应用可能修改了原本的引用，比如删除了一个原本的引用。这就会导致并发标记结束之后的存活对象的快照和SATB不一致。G1是通过在并发标记阶段引入一个写屏障来解决这个问题的：每当存在引用更新的情况，G1会将修改之前的值写入一个log buffer（这个记录会过滤掉原本是空引用的情况），在最终标记(final marking phase)阶段扫描SATB，修正SATB的误差。</p><p>SATB的log buffer如RS的写屏障使用的log buffer一样，都是两级结构，作用机制也是一样的。</p><blockquote><p>细节可以参阅资料2，6</p></blockquote><h2 id="Marking-bitmaps和TAMS"><a href="#Marking-bitmaps和TAMS" class="headerlink" title="Marking bitmaps和TAMS"></a>Marking bitmaps和TAMS</h2><p>Marking bitmap是一种数据结构，其中的每一个bit代表的是一个可用于分配给对象的起始地址。举例来说：</p><p><img src="/images/700.png" alt="img"></p><p>其中addrN代表的是一个对象的起始地址。绿色的块代表的是在该起始地址处的对象是存活对象，而其余白色的块则代表了垃圾对象。<br>G1使用了两个bitmap，一个叫做previous bitmap，另外一个叫做next bitmap。previous bitmap记录的是上一次的标记阶段完成之后的构造的bitmap；next bitmap则是当前正在标记阶段正在构造的bitmap。在当前标记阶段结束之后，当前标记的next bitmap就变成了下一次标记阶段的previous bitmap。<br>TAMS(top at mark start)变量，是一对用于区分在标记阶段新分配对象的变量，分别被称为previous TAMS和next TAMS。在previous TAMS和next TAMS之间的对象则是本次标记阶段时候新分配的对象。如图：</p><p><img src="/images/700-20180424103245937.png" alt="img"></p><p>白色region代表的是空闲空间，绿色region代表是存活对象，橙色region代表的在此次标记阶段新分配的对象。注意的是，在橙色区域的对象，并不能确保它们都事实上是存活的。</p><h2 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h2><p>整个算法可以分成两大部分：</p><ol><li>Marking cycle phase：标记阶段，该阶段是不断循环进行的；</li><li>Evacuation phase：该阶段是负责把一部分region的活对象拷贝到空Region里面去，然后回收原本的Region空间，该阶段是STW(stop-the-world)的；</li></ol><p>而算法也可以分成两种模式：</p><ol><li>fully-young generational mode：有时候也会被称为young GC，该模式只会回收young region，算法是通过调整young region的数量来达到软实时目标的；</li><li>partially-young mode：也被称为Mixed GC，该阶段会回收young region和old region，算法通过调整old region的数量来达到软实时目标；</li></ol><p>有趣的地方是不论处在何种模式之下，yong region都在被回收的范围内。而old region只能期望于Mixed GC。但是，如同在CMS垃圾回收器中遇到的困境一样，Mixed GC可能来不及回收old region。也就说，在需要分配老年代的对象的时候，并没有足够的空间。这个时候就只能触发一次full GC。</p><p>算法会自动在young GC和mixed GC之间切换，并且定期触发Marking cycle phase。HotSpot的G1实现允许指定一个参数InitiatingHeapOccupancyPercent，在达到该参数的情况下，就会执行marking cycle phase。</p><p>算法并不使用在对象头增加字段来标记该对象，而是采用bitmap的方式来记录一个对象被标记的情况。这种记录方法的好处就是在使用这些标记信息的时候，仅仅需要扫描bitmap而已。G1统计一个region的存活的对象，就是依赖于bitmap的标记。</p><h1 id="调优实践"><a href="#调优实践" class="headerlink" title="调优实践"></a>调优实践</h1><p>MaxGCPauseMillis调优</p><p>前面介绍过使用GC的最基本的参数：</p><blockquote><p>-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=200</p></blockquote><p>前面2个参数都好理解，后面这个MaxGCPauseMillis参数该怎么配置呢？这个参数从字面的意思上看，就是允许的GC最大的暂停时间。G1尽量确保每次GC暂停的时间都在设置的MaxGCPauseMillis范围内。 那G1是如何做到最大暂停时间的呢？这涉及到另一个概念，CSet(collection set)。它的意思是在一次垃圾收集器中被收集的区域集合。</p><ul><li>Young GC：选定所有新生代里的region。通过控制新生代的region个数来控制young GC的开销。</li><li>Mixed GC：选定所有新生代里的region，外加根据global concurrent marking统计得出收集收益高的若干老年代region。在用户指定的开销目标范围内尽可能选择收益高的老年代region。</li></ul><p>在理解了这些后，我们再设置最大暂停时间就好办了。 首先，我们能容忍的最大暂停时间是有一个限度的，我们需要在这个限度范围内设置。但是应该设置的值是多少呢？我们需要在吞吐量跟MaxGCPauseMillis之间做一个平衡。如果MaxGCPauseMillis设置的过小，那么GC就会频繁，吞吐量就会下降。如果MaxGCPauseMillis设置的过大，应用程序暂停时间就会变长。G1的默认暂停时间是200毫秒，我们可以从这里入手，调整合适的时间。</p><p><strong>其他调优参数</strong></p><p>-XX:G1HeapRegionSize=n</p><p>设置的 G1 区域的大小。值是 2 的幂，范围是 1 MB 到 32 MB 之间。目标是根据最小的 Java 堆大小划分出约 2048 个区域。</p><p>-XX:ParallelGCThreads=n</p><p>设置 STW 工作线程数的值。将 n 的值设置为逻辑处理器的数量。n 的值与逻辑处理器的数量相同，最多为 8。</p><p>如果逻辑处理器不止八个，则将 n 的值设置为逻辑处理器数的 5/8 左右。这适用于大多数情况，除非是较大的 SPARC 系统，其中 n 的值可以是逻辑处理器数的 5/16 左右。</p><p>-XX:ConcGCThreads=n</p><p>设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (ParallelGCThreads) 的 1/4 左右。</p><p>-XX:InitiatingHeapOccupancyPercent=45</p><p>设置触发标记周期的 Java 堆占用率阈值。默认占用率是整个 Java 堆的 45%。</p><p>避免使用以下参数：</p><p>避免使用 -Xmn 选项或 -XX:NewRatio 等其他相关选项显式设置年轻代大小。固定年轻代的大小会覆盖暂停时间目标。</p><p><strong>触发Full GC</strong></p><p>在某些情况下，G1触发了Full GC，这时G1会退化使用Serial收集器来完成垃圾的清理工作，它仅仅使用单线程来完成GC工作，GC暂停时间将达到秒级别的。整个应用处于假死状态，不能处理任何请求，我们的程序当然不希望看到这些。那么发生Full GC的情况有哪些呢？</p><ul><li>并发模式失败</li></ul><p>G1启动标记周期，但在Mix GC之前，老年代就被填满，这时候G1会放弃标记周期。这种情形下，需要增加堆大小，或者调整周期（例如增加线程数-XX:ConcGCThreads等）。</p><ul><li>晋升失败或者疏散失败</li></ul><p>G1在进行GC的时候没有足够的内存供存活对象或晋升对象使用，由此触发了Full GC。可以在日志中看到(to-space exhausted)或者（to-space overflow）。解决这种问题的方式是：</p><p>a,增加 -XX:G1ReservePercent 选项的值（并相应增加总的堆大小），为“目标空间”增加预留内存量。</p><p>b,通过减少 -XX:InitiatingHeapOccupancyPercent 提前启动标记周期。</p><p>c,也可以通过增加 -XX:ConcGCThreads 选项的值来增加并行标记线程的数目。</p><ul><li>巨型对象分配失败</li></ul><p>当巨型对象找不到合适的空间进行分配时，就会启动Full GC，来释放空间。这种情况下，应该避免分配大量的巨型对象，增加内存或者增大-XX:G1HeapRegionSize，使巨型对象不再是巨型对象。</p><p>由于篇幅有限，G1还有很多调优实践，在此就不一一列出了，大家在平常的实践中可以慢慢探索。最后，期待java 9能正式发布，默认使用G1为垃圾收集器的java性能会不会又提高呢？</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>The first focus of G1 is to provide a solution for users running applications that require large heaps with limited GC latency. This means heap sizes of around 6GB or larger, and stable and predictable pause time below 0.5 seconds.</p><p>Applications running today with either the CMS or the ParallelOldGC garbage collector would benefit switching to G1 if the application has one or more of the following traits.</p><ul><li>Full GC durations are too long or too frequent.</li><li>The rate of object allocation rate or promotion varies significantly.</li><li>Undesired long garbage collection or compaction pauses (longer than 0.5 to 1 second)</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>regions 划分：Eden、Survivor、Old、Humongous</li><li>young gc 和 mixed gc</li><li>remember set、card table、satb(snapshot-at-the-beginning)</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://crowhawk.github.io/2017/08/15/jvm_3/" target="_blank" rel="noopener">https://crowhawk.github.io/2017/08/15/jvm_3/</a><br><a href="http://blog.jobbole.com/109170/" target="_blank" rel="noopener">http://blog.jobbole.com/109170/</a><br><a href="https://www.jianshu.com/p/8bd15969a641" target="_blank" rel="noopener">https://www.jianshu.com/p/8bd15969a641</a><br><a href="http://www.importnew.com/27793.html" target="_blank" rel="noopener">http://www.importnew.com/27793.html</a><br><a href="https://tech.meituan.com/g1.html" target="_blank" rel="noopener">https://tech.meituan.com/g1.html</a><br><a href="http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html</a><br><a href="https://blog.csdn.net/renfufei/article/details/41897113" target="_blank" rel="noopener">https://blog.csdn.net/renfufei/article/details/41897113</a><br><a href="https://www.jianshu.com/p/870abddaba41" target="_blank" rel="noopener">https://www.jianshu.com/p/870abddaba41</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GarbageFirst（G1）&quot;&gt;&lt;a href=&quot;#GarbageFirst（G1）&quot; class=&quot;headerlink&quot; title=&quot;GarbageFirst（G1）&quot;&gt;&lt;/a&gt;GarbageFirst（G1）&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;G1（Gar
      
    
    </summary>
    
      <category term="java" scheme="http://www.iforfee.com/categories/java/"/>
    
    
      <category term="gc" scheme="http://www.iforfee.com/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机字节码执行引擎</title>
    <link href="http://www.iforfee.com/java/jvm/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>http://www.iforfee.com/java/jvm/虚拟机字节码执行引擎/</id>
    <published>2018-04-20T07:33:07.000Z</published>
    <updated>2018-04-20T07:36:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多态性实现机制——静态分派与动态分派"><a href="#多态性实现机制——静态分派与动态分派" class="headerlink" title="多态性实现机制——静态分派与动态分派"></a>多态性实现机制——静态分派与动态分派</h1><h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><p>Class 文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。这个特性给 Java 带来了更强大的动态扩展能力，使得可以在类运行期间才能确定某些目标方法的直接引用，称为动态连接，也有一部分方法的符号引用在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析。这在前面的“<a href="http://wiki.jikexueyuan.com/project/java-vm/storage.html" target="_blank" rel="noopener">Java 内存区域与内存溢出</a>”一文中有提到。</p><p>静态解析成立的前提是：方法在程序真正执行前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在编译器进行编译时就必须确定下来，这类方法的调用称为解析。</p><p>在 Java 语言中，符合“编译器可知，运行期不可变”这个要求的方法主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法都不可能通过继承或别的方式重写出其他的版本，因此它们都适合在类加载阶段进行解析。</p><p>Java 虚拟机里共提供了四条方法调用字节指令，分别是：</p><ul><li>invokestatic：调用静态方法。</li><li>invokespecial：调用实例构造器方法、私有方法和父类方法。</li><li>invokevirtual：调用所有的虚方法。</li><li>invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。</li></ul><p>只要能被 invokestatic 和 invokespecial 指令调用的方法，都可以在解析阶段确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器和父类方法四类，它们在类加载时就会把符号引用解析为该方法的直接引用。这些方法可以称为非虚方法（还包括 final 方法），与之相反，其他方法就称为虚方法（final 方法除外）。这里要特别说明下 final 方法，虽然调用 final 方法使用的是 invokevirtual 指令，但是由于它无法覆盖，没有其他版本，所以也无需对方发接收者进行多态选择。Java 语言规范中明确说明了 final 方法是一种非虚方法。</p><p>解析调用一定是个静态过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用转化为可确定的直接引用，不会延迟到运行期再去完成。而分派调用则可能是静态的也可能是动态的，根据分派依据的宗量数（<strong>方法的调用者和方法的参数统称为方法的宗量</strong>）又可分为单分派和多分派。两类分派方式两两组合便构成了静态单分派、静态多分派、动态单分派、动态多分派四种分派情况。</p><h2 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h2><p><strong>所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派</strong>，静态分派的最典型应用就是多态性中的方法重载。静态分派发生在编译阶段，因此确定静态分配的动作实际上不是由虚拟机来执行的。下面通过一段方法重载的示例程序来更清晰地说明这种分派机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;  </span><br><span class="line">&#125;    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticPai</span></span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Human hum)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"I am human"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Man hum)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"I am man"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Woman hum)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"I am woman"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Human man = <span class="keyword">new</span> Man();  </span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();  </span><br><span class="line">        StaticPai sp = <span class="keyword">new</span> StaticPai();  </span><br><span class="line">        sp.say(man);  </span><br><span class="line">        sp.say(woman);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的执行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am human</span><br><span class="line">I am human</span><br></pre></td></tr></table></figure><p>以上结果的得出应该不难分析。在分析为什么会选择参数类型为 Human 的重载方法去执行之前，先看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man（）;</span><br></pre></td></tr></table></figure><p>我们把上面代码中的“Human”称为变量的静态类型，后面的“Man”称为变量的实际类型。静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的，而实际类型变化的结果在运行期才可确定。</p><p>回到上面的代码分析中，在调用 say()方法时，方法的调用者（回忆上面关于宗量的定义，<strong>方法的调用者属于宗量</strong>）都为 sp 的前提下，使用哪个重载版本，完全取决于传入参数的数量和数据类型（<strong>方法的参数也是属于宗量</strong>）。代码中刻意定义了两个静态类型相同、实际类型不同的变量，可见编译器（不是虚拟机，因为如果是根据静态类型做出的判断，那么在编译期就确定了）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。并且静态类型是编译期可知的，所以在编译阶段，javac 编译器就根据参数的静态类型决定使用哪个重载版本。这就是静态分派最典型的应用。</p><h2 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h2><p>动态分派与多态性的另一个重要体现——方法覆写有着很紧密的关系。向上转型后调用子类覆写的方法便是一个很好地说明动态分派的例子。这种情况很常见，因此这里不再用示例程序进行分析。很显然，在判断执行父类中的方法还是子类中覆盖的方法时，如果用静态类型来判断，那么无论怎么进行向上转型，都只会调用父类中的方法，但实际情况是，根据对父类实例化的子类的不同，调用的是不同子类中覆写的方法，很明显，这里是要根据变量的实际类型来分派方法的执行版本的。而实际类型的确定需要在程序运行时才能确定下来，<strong>这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派</strong>。</p><h2 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h2><p>前面给出：方法的接受者（亦即方法的调用者）与方法的参数统称为方法的宗量。单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。</p><p>为了方便理解，下面给出一段示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Eat</span></span>&#123;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drink</span></span>&#123;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Eat arg)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"爸爸在吃饭"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Drink arg)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"爸爸在喝水"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Eat arg)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"儿子在吃饭"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Drink arg)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"儿子在喝水"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDoublePai</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Father father = <span class="keyword">new</span> Father();  </span><br><span class="line">        Father child = <span class="keyword">new</span> Child();  </span><br><span class="line">        father.doSomething(<span class="keyword">new</span> Eat());  </span><br><span class="line">        child.doSomething(<span class="keyword">new</span> Drink());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果应该很容易预测到，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">爸爸在吃饭</span><br><span class="line">儿子在喝水</span><br></pre></td></tr></table></figure><p>我们首先来看编译阶段编译器的选择过程，即静态分派过程。这时候选择目标方法的依据有两点：一是方法的接受者（即调用者）的静态类型是 Father 还是 Child，二是方法参数类型是 Eat 还是 Drink。因为是根据两个宗量进行选择，所以 Java 语言的静态分派属于多分派类型。</p><p>再来看运行阶段虚拟机的选择，即动态分派过程。由于编译期已经了确定了目标方法的参数类型（编译期根据参数的静态类型进行静态分派），因此唯一可以影响到虚拟机选择的因素只有此方法的接受者的实际类型是 Father 还是 Child。因为只有一个宗量作为选择依据，所以 Java 语言的动态分派属于单分派类型。</p><p><img src="/images/child.png" alt="img"></p><p>根据以上论证，我们可以总结如下：<strong>目前的</strong>Java 语言（JDK1.6）是一门<strong>静态多分派、动态单分派</strong>的语言。</p><h2 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h2><p>其实上面的叙述已经把虚拟机重写与重载的本质讲清楚了，那么Java虚拟机是如何做到这点的呢？</p><p>由于动态分派是非常频繁的操作，实际实现中不可能真正如此实现。Java虚拟机是通过“稳定优化”的手段——在方法区中建立一个虚方法表（Virtual Method Table），通过使用方法表的索引来代替元数据查找以提高性能。虚方法表中存放着各个方法的实际入口地址（由于Java虚拟机自己建立并维护的方法表，所以没有必要使用符号引用，那不是跟自己过不去嘛），如果子类没有覆盖父类的方法，那么子类的虚方法表里面的地址入口与父类是一致的；如果重写父类的方法，那么子类的方法表的地址将会替换为子类实现版本的地址。</p><p>方法表是在类加载的连接阶段（验证、准备、解析）进行初始化，准备了子类的初始化值后，虚拟机会把该类的虚方法表也进行初始化。</p><h2 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h2><p><a href="https://my.oschina.net/itblog/blog/538748" target="_blank" rel="noopener">https://my.oschina.net/itblog/blog/538748</a></p><p><a href="https://blog.souche.com/invokedynamic/" target="_blank" rel="noopener">https://blog.souche.com/invokedynamic/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多态性实现机制——静态分派与动态分派&quot;&gt;&lt;a href=&quot;#多态性实现机制——静态分派与动态分派&quot; class=&quot;headerlink&quot; title=&quot;多态性实现机制——静态分派与动态分派&quot;&gt;&lt;/a&gt;多态性实现机制——静态分派与动态分派&lt;/h1&gt;&lt;h2 id=&quot;方
      
    
    </summary>
    
      <category term="java" scheme="http://www.iforfee.com/categories/java/"/>
    
    
      <category term="jvm" scheme="http://www.iforfee.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>SPI和DriverManager</title>
    <link href="http://www.iforfee.com/java/SPI%E5%92%8CDriverManager/"/>
    <id>http://www.iforfee.com/java/SPI和DriverManager/</id>
    <published>2018-04-19T07:16:02.000Z</published>
    <updated>2018-04-19T07:31:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">Java中SPI机制深入及源码解析</a><br><a href="https://blog.csdn.net/yangcheng33/article/details/52631940" target="_blank" rel="noopener">真正理解线程上下文类加载器（多案例分析）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/&quot; t
      
    
    </summary>
    
      <category term="java" scheme="http://www.iforfee.com/categories/java/"/>
    
    
      <category term="spi" scheme="http://www.iforfee.com/tags/spi/"/>
    
      <category term="driver manager" scheme="http://www.iforfee.com/tags/driver-manager/"/>
    
  </entry>
  
  <entry>
    <title>LockSupport</title>
    <link href="http://www.iforfee.com/java/LockSupport/"/>
    <id>http://www.iforfee.com/java/LockSupport/</id>
    <published>2018-04-17T10:15:02.000Z</published>
    <updated>2018-04-17T10:55:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LockSupport-用法简介"><a href="#LockSupport-用法简介" class="headerlink" title="LockSupport 用法简介"></a>LockSupport 用法简介</h2><p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。LockSupport 提供park()和unpark()方法实现阻塞线程和解除线程阻塞，LockSupport和每个使用它的线程都与一个许可(permit)关联。permit相当于1，0的开关，默认是0，调用一次unpark就加1变成1，调用一次park会消费permit, 也就是将1变成0，同时park立即返回。再次调用park会变成block（因为permit为0了，会阻塞在这里，直到permit变为1）, 这时调用unpark会把permit置为1。每个线程都有一个相关的permit, permit最多只有一个，重复调用unpark也不会积累。</p><p>park()和unpark()不会有 “Thread.suspend和Thread.resume所可能引发的死锁” 问题，由于许可的存在，调用 park 的线程和另一个试图将其 unpark 的线程之间的竞争将保持活性。</p><p>如果调用线程被中断，则park方法会返回。同时park也拥有可以设置超时时间的版本。</p><p>三种形式的 park 还各自支持一个 blocker 对象参数。此对象在线程受阻塞时被记录，以允许监视工具和诊断工具确定线程受阻塞的原因。（这样的工具可以使用方法 getBlocker(java.lang.Thread) 访问 blocker。）建议最好使用这些形式，而不是不带此参数的原始形式。在锁实现中提供的作为 blocker 的普通参数是 this。<br>看下线程dump的结果来理解blocker的作用。</p><p><img src="/images/java/1467374850-58aba3ef836ab_articlex.png" alt=""></p><h2 id="LockSupport-源码解读"><a href="#LockSupport-源码解读" class="headerlink" title="LockSupport 源码解读"></a>LockSupport 源码解读</h2><ol><li>LockSupport中主要的两个成员变量：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hotspot implementation via intrinsics API</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> parkBlockerOffset;</span><br></pre></td></tr></table></figure><p>再来看parkBlockerOffset:<br>parkBlocker就是第一部分说到的用于记录线程被谁阻塞的，用于线程监控和分析工具来定位原因的，可以通过LockSupport的getBlocker获取到阻塞的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; tk = Thread.class;</span><br><span class="line">        parkBlockerOffset = UNSAFE.objectFieldOffset</span><br><span class="line">            (tk.getDeclaredField(<span class="string">"parkBlocker"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个静态语句块可以看的出来，先是通过反射机制获取Thread类的parkBlocker字段对象。然后通过sun.misc.Unsafe对象的objectFieldOffset方法获取到parkBlocker在内存里的偏移量，parkBlockerOffset的值就是这么来的.</p><p>JVM的实现可以自由选择如何实现Java对象的“布局”，也就是在内存里Java对象的各个部分放在哪里，包括对象的实例字段和一些元数据之类。 sun.misc.Unsafe里关于对象字段访问的方法把对象布局抽象出来，它提供了objectFieldOffset()方法用于获取某个字段相对 Java对象的“起始地址”的偏移量，也提供了getInt、getLong、getObject之类的方法可以使用前面获取的偏移量来访问某个Java 对象的某个字段。</p><p>为什么要用偏移量来获取对象？干吗不要直接写个get，set方法。多简单？<br>仔细想想就能明白，这个parkBlocker就是在线程处于阻塞的情况下才会被赋值。线程都已经阻塞了，如果不通过这种内存的方法，而是直接调用线程内的方法，线程是不会回应调用的。</p><p>2.LockSupport的方法：</p><p><img src="/images/java/bVJu1i.png" alt="img"></p><p>可以看到，LockSupport中主要是park和unpark方法以及设置和读取parkBlocker方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBlocker</span><span class="params">(Thread t, Object arg)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Even though volatile, hotspot doesn't need a write barrier here.</span></span><br><span class="line">       UNSAFE.putObject(t, parkBlockerOffset, arg);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>对给定线程t的parkBlocker赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBlocker</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.getObjectVolatile(t, parkBlockerOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从线程t中获取它的parkBlocker对象，即返回的是阻塞线程t的Blocker对象。</p><p>接下来主查两类方法，一类是阻塞park方法，一类是解除阻塞unpark方法</p><p><strong>阻塞线程</strong></p><ul><li>park()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用native方法阻塞当前线程。</p><ul><li>parkNanos(long nanos)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(<span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>)</span><br><span class="line">            UNSAFE.park(<span class="keyword">false</span>, nanos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阻塞当前线程，最长不超过nanos纳秒，返回条件在park()的基础上增加了超时返回。</p><ul><li>parkUntil(long deadline)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(<span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">  UNSAFE.park(<span class="keyword">true</span>, deadline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阻塞当前线程，知道deadline时间（deadline - 毫秒数）。</p><p>JDK1.6引入这三个方法对应的拥有Blocker版本。</p><ul><li>park(Object blocker)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  setBlocker(t, blocker);</span><br><span class="line">  UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">  setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1) 记录当前线程等待的对象（阻塞对象）；<br>2) 阻塞当前线程；<br>3) 当前线程等待对象置为null。</p><ul><li>parkNanos(Object blocker, long nanos)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkNanos</span><span class="params">(Object blocker, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      Thread t = Thread.currentThread();</span><br><span class="line">      setBlocker(t, blocker);</span><br><span class="line">      UNSAFE.park(<span class="keyword">false</span>, nanos);</span><br><span class="line">      setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阻塞当前线程，最长等待时间不超过nanos毫秒，同样，在阻塞当前线程的时候做了记录当前线程等待的对象操作。</p><ul><li>parkUntil(Object blocker, long deadline)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parkUntil</span><span class="params">(Object blocker, <span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  setBlocker(t, blocker);</span><br><span class="line">  UNSAFE.park(<span class="keyword">true</span>, deadline);</span><br><span class="line">  setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阻塞当前线程直到deadline时间，相同的，也做了阻塞前记录当前线程等待对象的操作。</p><p><strong>唤醒线程</strong></p><ul><li>unpark(Thread thread)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">      UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唤醒处于阻塞状态的线程Thread。</p><h2 id="Locksupport-底层"><a href="#Locksupport-底层" class="headerlink" title="Locksupport 底层"></a>Locksupport 底层</h2><p>在Linux系统下，是用的Posix线程库pthread中的mutex（互斥量），condition（条件变量）来实现的。<br><strong>mutex和condition保护了一个_counter的变量，当park时，这个变量被设置为0，当unpark时，这个变量被设置为1。</strong></p><p>看看Locksupport的源码中的注释可知，Locksupport是实现别的锁和同步类的基本原语。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Parker : public os::PlatformParker &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> _counter ;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">park</span><span class="params">(bool isAbsolute, jlong time)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unpark</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">class PlatformParker : public CHeapObj&lt;mtInternal&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    pthread_mutex_t _mutex [<span class="number">1</span>] ;</span><br><span class="line">    pthread_cond_t  _cond  [<span class="number">1</span>] ;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Parker类实际上用Posix的mutex，condition来实现的。<br>在Parker类里的_counter字段，就是用来记录“许可”的。</p><ul><li><strong>park 过程</strong></li></ul><p>当调用park时，先尝试能否直接拿到“许可”，即_counter&gt;0时，如果成功，则把_counter设置为0，并返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Parker::park(bool isAbsolute, jlong time) &#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Ideally we'd do something useful while spinning, such  </span></span><br><span class="line">  <span class="comment">// as calling unpackTime().  </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Optional fast-path check:  </span></span><br><span class="line">  <span class="comment">// Return immediately if a permit is available.  </span></span><br><span class="line">  <span class="comment">// We depend on Atomic::xchg() having full barrier semantics  </span></span><br><span class="line">  <span class="comment">// since we are doing a lock-free update to _counter.  </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (Atomic::xchg(<span class="number">0</span>, &amp;_counter) &gt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>如果不成功，则构造一个ThreadBlockInVM，然后检查_counter是不是&gt;0，如果是，则把_counter设置为0，unlock mutex并返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadBlockInVM <span class="title">tbivm</span><span class="params">(jt)</span></span>;  </span><br><span class="line"><span class="keyword">if</span> (_counter &gt; <span class="number">0</span>)  &#123; <span class="comment">// no wait needed  </span></span><br><span class="line">  _counter = <span class="number">0</span>;  </span><br><span class="line">  status = pthread_mutex_unlock(_mutex);</span><br></pre></td></tr></table></figure><p>否则，再判断等待的时间，然后再调用pthread_cond_wait函数等待，如果等待返回，则把_counter设置为0，unlock mutex并返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (time == <span class="number">0</span>) &#123;  </span><br><span class="line">  status = pthread_cond_wait (_cond, _mutex) ;  </span><br><span class="line">&#125;  </span><br><span class="line">_counter = <span class="number">0</span> ;  </span><br><span class="line">status = pthread_mutex_unlock(_mutex) ;  </span><br><span class="line">assert_status(status == <span class="number">0</span>, status, <span class="string">"invariant"</span>) ;  </span><br><span class="line">OrderAccess::fence();</span><br></pre></td></tr></table></figure><ul><li><strong>unpark 过程</strong></li></ul><p>当unpark时，则简单多了，直接设置_counter为1，再unlock mutex返回。如果_counter之前的值是0，则还要调用pthread_cond_signal唤醒在park中等待的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Parker::unpark() &#123;  </span><br><span class="line">  <span class="keyword">int</span> s, status ;  </span><br><span class="line">  status = pthread_mutex_lock(_mutex);  </span><br><span class="line">  <span class="keyword">assert</span> (status == <span class="number">0</span>, <span class="string">"invariant"</span>) ;  </span><br><span class="line">  s = _counter;  </span><br><span class="line">  _counter = <span class="number">1</span>;  </span><br><span class="line">  <span class="keyword">if</span> (s &lt; <span class="number">1</span>) &#123;  </span><br><span class="line">     <span class="keyword">if</span> (WorkAroundNPTLTimedWaitHang) &#123;  </span><br><span class="line">        status = pthread_cond_signal (_cond) ;  </span><br><span class="line">        <span class="keyword">assert</span> (status == <span class="number">0</span>, <span class="string">"invariant"</span>) ;  </span><br><span class="line">        status = pthread_mutex_unlock(_mutex);  </span><br><span class="line">        <span class="keyword">assert</span> (status == <span class="number">0</span>, <span class="string">"invariant"</span>) ;  </span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        status = pthread_mutex_unlock(_mutex);  </span><br><span class="line">        <span class="keyword">assert</span> (status == <span class="number">0</span>, <span class="string">"invariant"</span>) ;  </span><br><span class="line">        status = pthread_cond_signal (_cond) ;  </span><br><span class="line">        <span class="keyword">assert</span> (status == <span class="number">0</span>, <span class="string">"invariant"</span>) ;  </span><br><span class="line">     &#125;  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    pthread_mutex_unlock(_mutex);  </span><br><span class="line">    <span class="keyword">assert</span> (status == <span class="number">0</span>, <span class="string">"invariant"</span>) ;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LockSupport的特性"><a href="#LockSupport的特性" class="headerlink" title="LockSupport的特性"></a>LockSupport的特性</h2><h3 id="先释放许可，再获取许可"><a href="#先释放许可，再获取许可" class="headerlink" title="先释放许可，再获取许可"></a>先释放许可，再获取许可</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     Thread thread = Thread.currentThread();</span><br><span class="line">     LockSupport.unpark(thread);<span class="comment">//释放许可</span></span><br><span class="line">     LockSupport.park();<span class="comment">// 获取许可</span></span><br><span class="line">     System.out.println(<span class="string">"b"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不可重入"><a href="#不可重入" class="headerlink" title="不可重入"></a>不可重入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Thread thread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">LockSupport.unpark(thread);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"a"</span>);</span><br><span class="line">LockSupport.park();</span><br><span class="line">System.out.println(<span class="string">"b"</span>);</span><br><span class="line">LockSupport.park();</span><br><span class="line">System.out.println(<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码打印出a和b，不会打印c，因为第二次调用park的时候，线程无法获取许可出现死锁。</p><h3 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h3><p>LockSupport.part()方法是响应中断地，当线程中断后，会从park方法返回执行后续逻辑，所以，LockSupport中的对中断地响应可以灵活控制。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> joyo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/4/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportInterruptTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    LockSupport.park();</span><br><span class="line">                    System.out.println(<span class="string">"come back here"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终输出结果：come back here，而不是打印异常栈。</p><p>而Object.wait()方法并没有这个特性，会直接抛出中断异常。</p><h2 id="LockSupport-和-Object的区别"><a href="#LockSupport-和-Object的区别" class="headerlink" title="LockSupport 和 Object的区别"></a>LockSupport 和 Object的区别</h2><p>两者区别总结如下：</p><ol><li>Object.wait和notify都是针对对象的，notify实际上是不知道唤醒具体哪个线程的，而Locksupport支持指定线程唤醒</li><li>实现原理不同，Locksupport是基于Unsafe.park来实现的。具体可以见参考资料3</li><li>Locksupport功能更加强大些： 基于“许可”的同步实现，提供parkBlocker来监视锁的持有等。而Object.wait方法来完成同步，需要依赖监视器锁。</li><li>JDK1.6之后针对synchrnized引入了分级的锁，根据后面的代码示例发现两类同步原语的开销是差不多的</li></ol><p>两者相同点：</p><ol><li>park和wait都会阻塞线程，释放锁</li><li>虽然响应中断行动不同，但是都会更改中断标志位</li><li>功能上其实相近，但是为了易用性和功能妥协，park和unpark基本可以替代Object.wait和notify等</li></ol><p>从区别上来看可知，使用Locksupport能更加精细、灵活地控制线程的同步，利于实现各种同步工具和锁。精细体现在针对线程的同步控制，灵活体现在通过“许可”获取的方式来保证活性。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000008420938" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008420938</a><br><a href="https://www.jianshu.com/p/e3afe8ab8364" target="_blank" rel="noopener">https://www.jianshu.com/p/e3afe8ab8364</a><br><a href="https://blog.csdn.net/u013851082/article/details/70242395" target="_blank" rel="noopener">https://blog.csdn.net/u013851082/article/details/70242395</a><br><a href="https://kaimingwan.com/post/java/javabing-fa-yu-suo/liao-liao-locksupport" target="_blank" rel="noopener">https://kaimingwan.com/post/java/javabing-fa-yu-suo/liao-liao-locksupport</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;LockSupport-用法简介&quot;&gt;&lt;a href=&quot;#LockSupport-用法简介&quot; class=&quot;headerlink&quot; title=&quot;LockSupport 用法简介&quot;&gt;&lt;/a&gt;LockSupport 用法简介&lt;/h2&gt;&lt;p&gt;LockSupport是用来
      
    
    </summary>
    
      <category term="java" scheme="http://www.iforfee.com/categories/java/"/>
    
    
      <category term="LockSupport" scheme="http://www.iforfee.com/tags/LockSupport/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="http://www.iforfee.com/java/datastructure/ThreadLocal/"/>
    <id>http://www.iforfee.com/java/datastructure/ThreadLocal/</id>
    <published>2018-04-15T06:24:23.000Z</published>
    <updated>2018-04-26T08:06:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal 作为 Thread 中的 ThreadLocalMap 的 key 。</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            threadLocal.set((<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>D));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         MyRunnable sharedRunnableInstance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">         Thread thread1 = <span class="keyword">new</span> Thread(sharedRunnableInstance);</span><br><span class="line">         Thread thread2 = <span class="keyword">new</span> Thread(sharedRunnableInstance);</span><br><span class="line">         thread1.start();</span><br><span class="line">         thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-and-Set"><a href="#get-and-Set" class="headerlink" title="get and Set"></a>get and Set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment">    * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment">    * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment">    * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment"> *        this thread-local.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment">    * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment">    * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment">    * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hash冲突"><a href="#hash冲突" class="headerlink" title="hash冲突"></a>hash冲突</h2><p>当set发生hash冲突时，获取数组中下一个可插入的位置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 走到这里，说明key不相等，即发生了key的冲突，通过nextIndex 获取下一个可用的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。<br>其实，ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/" target="_blank" rel="noopener">深入分析 ThreadLocal 内存泄漏问题</a><br><a href="http://blog.xiaohansong.com/2016/08/09/ThreadLocal-leak-analyze/" target="_blank" rel="noopener">ThreadLocal 内存泄露的实例分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ThreadLocal 作为 Thread 中的 ThreadLocalMap 的 key 。&lt;/p&gt;
&lt;h2 id=&quot;Example&quot;&gt;&lt;a href=&quot;#Example&quot; class=&quot;headerlink&quot; title=&quot;Example&quot;&gt;&lt;/a&gt;Example&lt;/h
      
    
    </summary>
    
      <category term="java" scheme="http://www.iforfee.com/categories/java/"/>
    
    
      <category term="data structure" scheme="http://www.iforfee.com/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>redis缓存</title>
    <link href="http://www.iforfee.com/redis/redis%E7%BC%93%E5%AD%98/"/>
    <id>http://www.iforfee.com/redis/redis缓存/</id>
    <published>2018-04-13T09:24:55.000Z</published>
    <updated>2018-04-14T07:01:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>什么是缓存穿透？<br>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。如果key对应的value是一定不存在的，并且对该key并发请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p><p>如何避免？<br>1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。<br>2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。【感觉应该用的不多吧】</p><p>开发提示：<br>有关布隆过滤器的相关知识，可以参考：<a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bloom_filter</a><br>可以利用 Redis 的 Bitmaps 实现布隆过滤器，GitHub 上已经开源了类似的方案，读者可以进行参考：<br><a href="https://github.com/erikdubbelboer/Redis-Lua-scaling-bloom-filter" target="_blank" rel="noopener">https://github.com/erikdubbelboer/Redis-Lua-scaling-bloom-filter</a></p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>什么是缓存雪崩？<br>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。</p><p>如何避免？</p><p>预防</p><ul><li>保证缓存层服务高可用性（多个节点）</li><li>不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</li><li>从缓存层面来看，不设置过期时间，每个 value 设置一个逻辑过期时间</li><li>可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存</li><li>做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期</li><li>提前演练</li></ul><p>事后处理</p><ul><li>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</li><li>依赖隔离组件为后端限流并降级</li></ul><h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样避免，用户请求的时候，再去加载相关的数据。</p><p>解决思路：</p><ol><li>直接写个缓存刷新页面，上线时手工操作下。</li><li>数据量不大，可以在WEB系统启动的时候加载。</li><li>定时刷新缓存</li></ol><h2 id="缓存数据的淘汰"><a href="#缓存数据的淘汰" class="headerlink" title="缓存数据的淘汰"></a>缓存数据的淘汰</h2><p>缓存淘汰的策略有两种： (1) 定时去清理过期的缓存。 （2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。<br>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂，具体用哪种方案，大家可以根据自己的应用场景来权衡。</p><p>淘汰机制</p><ul><li>LRU</li><li>TTL</li></ul><p><a href="https://github.com/bingbo/blog/wiki/Redis%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">Redis数据淘汰机制</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/fidelQuan/p/4543387.html" target="_blank" rel="noopener">缓存穿透与缓存雪崩</a><br><a href="https://www.jianshu.com/p/5c6f3ec161f1" target="_blank" rel="noopener">Redis架构之防雪崩设计：网站不宕机背后的兵法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;缓存穿透&quot;&gt;&lt;a href=&quot;#缓存穿透&quot; class=&quot;headerlink&quot; title=&quot;缓存穿透&quot;&gt;&lt;/a&gt;缓存穿透&lt;/h2&gt;&lt;p&gt;什么是缓存穿透？&lt;br&gt;一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB
      
    
    </summary>
    
      <category term="redis" scheme="http://www.iforfee.com/categories/redis/"/>
    
    
      <category term="cache" scheme="http://www.iforfee.com/tags/cache/"/>
    
  </entry>
  
</feed>
