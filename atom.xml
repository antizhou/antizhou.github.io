<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>World of Anti Zhou</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.antizhou.com/"/>
  <updated>2018-12-04T16:05:07.333Z</updated>
  <id>http://www.antizhou.com/</id>
  
  <author>
    <name>Anti Zhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6的7个实用技巧</title>
    <link href="http://www.antizhou.com/es6/ES6%E7%9A%847%E4%B8%AA%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.antizhou.com/es6/ES6的7个实用技巧/</id>
    <published>2018-12-04T16:04:27.000Z</published>
    <updated>2018-12-04T16:05:07.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hack-1-交换元素"><a href="#Hack-1-交换元素" class="headerlink" title="Hack #1 交换元素"></a>Hack #1 交换元素</h2><p>利用<code>数组解构</code>来实现值的互换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'world'</span>, b = <span class="string">'hello'</span></span><br><span class="line">[a, b] = [b, a]</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// -&gt; hello</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// -&gt; world</span></span><br></pre></td></tr></table></figure><h2 id="Hack-2-调试"><a href="#Hack-2-调试" class="headerlink" title="Hack #2 调试"></a>Hack #2 调试</h2><p>我们经常使用<code>console.log()</code>来进行调试，试试<code>console.table()</code>也无妨。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">5</span>, b = <span class="number">6</span>, c = <span class="number">7</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123; a, b, c &#125;);</span><br><span class="line"><span class="built_in">console</span>.table(&#123;a, b, c, <span class="attr">m</span>: &#123;<span class="attr">name</span>: <span class="string">'xixi'</span>, <span class="attr">age</span>: <span class="number">27</span>&#125;&#125;);</span><br></pre></td></tr></table></figure><h2 id="Hack-3-单条语句"><a href="#Hack-3-单条语句" class="headerlink" title="Hack #3 单条语句"></a>Hack #3 单条语句</h2><p>ES6时代，操作数组的语句将会更加的紧凑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找数组中的最大值</span></span><br><span class="line"><span class="keyword">const</span> max = <span class="function">(<span class="params">arr</span>) =&gt;</span> <span class="built_in">Math</span>.max(...arr);</span><br><span class="line">max([<span class="number">123</span>, <span class="number">321</span>, <span class="number">32</span>]) <span class="comment">// outputs: 321</span></span><br><span class="line"><span class="comment">// 计算数组的总和</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">arr</span>) =&gt;</span> arr.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (a + b), <span class="number">0</span>)</span><br><span class="line">sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) <span class="comment">// output: 10</span></span><br></pre></td></tr></table></figure><h2 id="Hack-4-数组拼接"><a href="#Hack-4-数组拼接" class="headerlink" title="Hack #4 数组拼接"></a>Hack #4 数组拼接</h2><p>展开运算符可以取代<code>concat</code>的地位了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">const</span> two = [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>]</span><br><span class="line"><span class="keyword">const</span> three = [<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = [...one, ...two, ...three]</span><br></pre></td></tr></table></figure><h2 id="Hack-5-制作副本"><a href="#Hack-5-制作副本" class="headerlink" title="Hack #5 制作副本"></a>Hack #5 制作副本</h2><p>我们可以很容易的实现数组和对象的<del><code>浅拷贝</code></del><code>拷贝</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; ...oldObj &#125;</span><br><span class="line"><span class="keyword">const</span> arr = [ ...oldArr ]</span><br></pre></td></tr></table></figure><p><code>拷贝</code> = <code>深拷贝</code> ? <code>浅拷贝</code> ？<br>好像有些朋友对这里我说的<code>浅拷贝</code>有些质疑，我也能理解大家所说的。下面数组为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组元素为简单数据类型非引用类型</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> newArr = [...arr];</span><br><span class="line"><span class="comment">// 数组元素为引用类型</span></span><br><span class="line"><span class="keyword">const</span> person01 = &#123;<span class="attr">name</span>: <span class="string">'name01'</span>, <span class="attr">age</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> person02 = &#123;<span class="attr">name</span>: <span class="string">'name01'</span>, <span class="attr">age</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> person03 = &#123;<span class="attr">name</span>: <span class="string">'name03'</span>, <span class="attr">age</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [person01, person02, person03];</span><br><span class="line"><span class="keyword">const</span> newArr = [...arr];</span><br><span class="line"><span class="built_in">console</span>.log(newArr[<span class="number">0</span>] === person01);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>第二个 demo 就是我想表达的浅拷贝，若有不同意见欢迎讨论~</p><h2 id="Hack-6-命名参数"><a href="#Hack-6-命名参数" class="headerlink" title="Hack #6 命名参数???"></a>Hack #6 命名参数???</h2><p>解构使得函数声明和函数的调用更加可读</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们尝尝使用的写法</span></span><br><span class="line"><span class="keyword">const</span> getStuffNotBad = <span class="function">(<span class="params">id, force, verbose</span>) =&gt;</span> &#123;</span><br><span class="line">  ...do stuff</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当我们调用函数时， 明天再看，尼玛 150是啥，true是啥</span></span><br><span class="line">getStuffNotBad(<span class="number">150</span>, <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看完本文你啥都可以忘记, 希望够记住下面的就可以了</span></span><br><span class="line"><span class="keyword">const</span> getStuffAwesome = <span class="function">(<span class="params">&#123;id, name, force, verbose&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  ...do stuff</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完美</span></span><br><span class="line">getStuffAwesome(&#123; <span class="attr">id</span>: <span class="number">150</span>, <span class="attr">force</span>: <span class="literal">true</span>, <span class="attr">verbose</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure><h2 id="Hack-7-Async-Await结合数组解构"><a href="#Hack-7-Async-Await结合数组解构" class="headerlink" title="Hack #7 Async/Await结合数组解构"></a>Hack #7 Async/Await结合数组解构</h2><p>数组解构非常赞!结合<code>Promise.all</code>和<code>解构</code>和<code>await</code>会使代码变得更加的简洁</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [user, account] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">  fetch(<span class="string">'/user'</span>),</span><br><span class="line">  fetch(<span class="string">'/account'</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Hack-1-交换元素&quot;&gt;&lt;a href=&quot;#Hack-1-交换元素&quot; class=&quot;headerlink&quot; title=&quot;Hack #1 交换元素&quot;&gt;&lt;/a&gt;Hack #1 交换元素&lt;/h2&gt;&lt;p&gt;利用&lt;code&gt;数组解构&lt;/code&gt;来实现值的互换&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="es6" scheme="http://www.antizhou.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://www.antizhou.com/tags/es6/"/>
    
      <category term="js" scheme="http://www.antizhou.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>es6</title>
    <link href="http://www.antizhou.com/es6/es6%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.antizhou.com/es6/es6小技巧/</id>
    <published>2018-12-04T15:52:10.000Z</published>
    <updated>2018-12-04T15:53:41.216Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.</strong> 强制要求参数</p><p><strong>ES6</strong>提供了默认参数值机制，允许你为参数设置默认值，防止在函数被调用时没有传入这些参数。 在下面的例子中，我们写了一个<strong>required</strong>()函数作为参数<strong>a</strong>和<strong>b</strong>的默认值。这意味着如果<strong>a</strong>或<strong>b</strong>其中有一个参数没有在调用时传值，会默认<strong>required</strong>()函数，然后抛出错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> required = <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing parameter'</span>)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a = required(</span>), <span class="params">b</span> = <span class="params">required</span><span class="params">()</span>) =&gt;</span> a + b;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>) <span class="comment">// Error: Missing parameter.</span></span><br></pre></td></tr></table></figure><p><strong>2.</strong> 强大的<strong>reduce</strong></p><p>数组的<strong>reduce</strong>方法用途很广。它一般被用来把数组中每一项规约到单个值。但是你可以利用它做更多的事。</p><p><strong>2.1</strong> 使用<strong>reduce</strong>同时实现<strong>map</strong>和<strong>filter</strong></p><p>假设现在有一个数列，你希望更新它的每一项（<strong>map</strong>的功能）然后筛选出一部分（<strong>filter</strong>的功能）。如果是先使用<strong>map</strong>然后<strong>filter</strong>的话，你需要遍历这个数组两次。 在下面的代码中，我们将数列中的值翻倍，然后挑选出那些大于<strong>50</strong>的数。有注意到我们是如何非常高效地使用<strong>reduce</strong>来同时完成<strong>map</strong>和<strong>filter</strong>方法的吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> doubledOver50 = numbers.reduce(<span class="function">(<span class="params">finalList, num</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line"> num = num * <span class="number">2</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (num &gt; <span class="number">50</span>) &#123;</span><br><span class="line"></span><br><span class="line"> finalList.push(num);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> finalList;</span><br><span class="line"></span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line">doubledOver50; <span class="comment">// [60, 80]</span></span><br></pre></td></tr></table></figure><p><strong>2.2</strong> 使用<strong>reduce</strong>取代<strong>map</strong>和<strong>filter</strong></p><p>如果你认真阅读了上面的代码，你应该能理解<strong>reduce</strong>是可以取代<strong>map</strong>和<strong>filter</strong>的。</p><p><strong>2.3</strong> 使用<strong>reduce</strong>匹配圆括号</p><p><strong>reduce</strong>的另外一个用途是能够匹配给定字符串中的圆括号。对于一个含有圆括号的字符串，我们需要知道(和)的数量是否一致，并且(是否出现在)之前。 下面的代码中我们使用<strong>reduce</strong>可以轻松地解决这个问题。我们只需要先声明一个<strong>counter</strong>变量，初值为<strong>0</strong>。在遇到(时<strong>counter</strong>加一，遇到)时<strong>counter</strong>减一。如果左右括号数目匹配，那最终结果为<strong>0</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Returns 0 if balanced.</span></span><br><span class="line"><span class="keyword">const</span> isParensBalanced = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> str.split(<span class="string">''</span>).reduce(<span class="function">(<span class="params">counter, char</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(counter &lt; <span class="number">0</span>) &#123; <span class="comment">//matched ")" before "("</span></span><br><span class="line">            <span class="keyword">return</span> counter;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(char === <span class="string">'('</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ++counter;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(char === <span class="string">')'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> --counter;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//matched some other char</span></span><br><span class="line">            <span class="keyword">return</span> counter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>); <span class="comment">//&lt;-- starting value of the counter</span></span><br><span class="line">&#125;</span><br><span class="line">isParensBalanced(<span class="string">'(())'</span>) <span class="comment">// 0 &lt;-- balanced</span></span><br><span class="line">isParensBalanced(<span class="string">'(asdfds)'</span>) <span class="comment">//0 &lt;-- balanced</span></span><br><span class="line">isParensBalanced(<span class="string">'(()'</span>) <span class="comment">// 1 &lt;-- not balanced</span></span><br><span class="line">isParensBalanced(<span class="string">')('</span>) <span class="comment">// -1 &lt;-- not balanced</span></span><br></pre></td></tr></table></figure><p><strong>2.4</strong> 统计数组中相同项的个数</p><p>很多时候，你希望统计数组中重复出现项的个数然后用一个对象表示。那么你可以使用<strong>reduce</strong>方法处理这个数组。 下面的代码将统计每一种车的数目然后把总数用一个对象表示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cars = [<span class="string">'BMW'</span>,<span class="string">'Benz'</span>, <span class="string">'Benz'</span>, <span class="string">'Tesla'</span>, <span class="string">'BMW'</span>, <span class="string">'Toyota'</span>];</span><br><span class="line"><span class="keyword">var</span> carsObj = cars.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">obj, name</span>) </span>&#123; </span><br><span class="line">obj[name] = obj[name] ? ++obj[name] : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line">carsObj; <span class="comment">// =&gt; &#123; BMW: 2, Benz: 2, Tesla: 1, Toyota: 1 &#125;</span></span><br></pre></td></tr></table></figure><p><strong>reduce</strong>的其他用处实在是太多了，我建议你阅读<strong>MDN</strong>的相关代码示例。</p><p><strong>3.</strong> 对象解构</p><p><strong>3.1</strong> 删除不需要的属性</p><p>有时候你不希望保留某些对象属性，也许是因为它们包含敏感信息或仅仅是太大了（<strong>just too big</strong>）。你可能会枚举整个对象然后删除它们，但实际上只需要简单的将这些无用属性赋值给变量，然后把想要保留的有用部分作为剩余参数就可以了。 下面的代码里，我们希望删除<strong>_internal</strong>和<strong>tooBig</strong>参数。我们可以把它们赋值给<strong>internal</strong>和<strong>tooBig</strong>变量，然后在<strong>cleanObject</strong>中存储剩下的属性以备后用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;_internal, tooBig, ...cleanObject&#125; = &#123;</span><br><span class="line">    el1: <span class="string">'1'</span>, <span class="attr">_internal</span>:<span class="string">"secret"</span>, <span class="attr">tooBig</span>:&#123;&#125;, <span class="attr">el2</span>: <span class="string">'2'</span>, <span class="attr">el3</span>: <span class="string">'3'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(cleanObject); <span class="comment">// &#123;el1: '1', el2: '2', el3: '3'&#125;</span></span><br></pre></td></tr></table></figure><p><strong>3.2</strong> 在函数参数中解构嵌套对象</p><p>在下面的代码中，<strong>engine</strong>是对象<strong>car</strong>中嵌套的一个对象。如果我们对<strong>engine</strong>的<strong>vin</strong>属性感兴趣，使用解构赋值可以很轻松地得到它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> car = &#123;</span><br><span class="line">    model: <span class="string">'bmw 2018'</span>,</span><br><span class="line">    engine: &#123;</span><br><span class="line">        v6: <span class="literal">true</span>,</span><br><span class="line">        turbo: <span class="literal">true</span>,</span><br><span class="line">        vin: <span class="number">12345</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> modelAndVIN = <span class="function">(<span class="params">&#123;model, engine: &#123;vin&#125;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(model: $&#123;model&#125; vin: $&#123;vin&#125;);</span><br><span class="line">&#125;</span><br><span class="line">modelAndVIN(car); <span class="comment">// =&gt; model: bmw 2018 vin: 12345</span></span><br></pre></td></tr></table></figure><p><strong>3.3</strong> 合并对象</p><p><strong>ES6</strong>带来了扩展运算符（<strong>…</strong>）。它一般被用来解构数组，但你也可以用它处理对象。 接下来，我们使用扩展运算符来展开一个新的对象，第二个对象中的属性值会改写第一个对象的属性值。比如<strong>object2</strong>的<strong>b</strong>和<strong>c</strong>就会改写<strong>object1</strong>的同名属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> object1 = &#123; <span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>,<span class="attr">c</span>:<span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">let</span> object2 = &#123; <span class="attr">b</span>:<span class="number">30</span>, <span class="attr">c</span>:<span class="number">40</span>, <span class="attr">d</span>:<span class="number">50</span>&#125;</span><br><span class="line"><span class="keyword">let</span> merged = &#123;…object1, …object2&#125; <span class="comment">//spread and re-add into merged</span></span><br><span class="line"><span class="built_in">console</span>.log(merged) <span class="comment">// &#123;a:1, b:30, c:40, d:50&#125;</span></span><br></pre></td></tr></table></figure><p><strong>4. Sets</strong></p><p><strong>4.1</strong> 使用<strong>Set</strong>实现数组去重</p><p>在<strong>ES6</strong>中，因为<strong>Set</strong>只存储唯一值，所以你可以使用<strong>Set</strong>删除重复项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> deduped = [...new <span class="built_in">Set</span>(arr)] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p><strong>4.2</strong> 对<strong>Set</strong>使用数组方法</p><p>使用扩展运算符就可以简单的将<strong>Set</strong>转换为数组。所以你可以对<strong>Set</strong>使用<strong>Array</strong>的所有原生方法。 比如我们想要对下面的<strong>Set</strong>进行<strong>filter</strong>操作，获取大于<strong>3</strong>的项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySet = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="keyword">var</span> filtered = [...mySet].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> x &gt; <span class="number">3</span>) <span class="comment">// [4, 5]</span></span><br></pre></td></tr></table></figure><p><strong>5.</strong> 数组解构</p><p>有时候你会将函数返回的多个值放在一个数组里。我们可以使用数组解构来获取其中每一个值。</p><p><strong>5.1</strong> 数值交换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> param1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> param2 = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//swap and assign param1 &amp; param2 each others values</span></span><br><span class="line">[param1, param2] = [param2, param1];</span><br><span class="line"><span class="built_in">console</span>.log(param1) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(param2) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><strong>5.2</strong> 接收函数返回的多个结果</p><p>在下面的代码中，我们从<strong>/post</strong>中获取一个帖子，然后在<strong>/comments</strong>中获取相关评论。由于我们使用的是<strong>async/await</strong>，函数把返回值放在一个数组中。而我们使用数组解构后就可以把返回值直接赋给相应的变量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 强制要求参数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ES6&lt;/strong&gt;提供了默认参数值机制，允许你为参数设置默认值，防止在函数被调用时没有传入这些参数。 在下面的例子中，我们写了一个&lt;strong&gt;required&lt;/strong&gt;()
      
    
    </summary>
    
      <category term="es6" scheme="http://www.antizhou.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://www.antizhou.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>报警规则类型</title>
    <link href="http://www.antizhou.com/alarm/%E6%8A%A5%E8%AD%A6%E8%A7%84%E5%88%99%E7%B1%BB%E5%9E%8B/"/>
    <id>http://www.antizhou.com/alarm/报警规则类型/</id>
    <published>2018-07-17T11:07:06.000Z</published>
    <updated>2018-07-17T11:10:10.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>单数据源简单规则。简单规则通过对每次最新的监控数据进行阈值比较，来获得报警，比如：<ol><li>上下限阈值比较。这种是最简单的，定义好上限和下限，就可以发现异常值</li><li>数据存活性比较。当发现某一监控项的数据存在（或消失）时，即报警，用来检查错误指标（或存活指标）</li></ol></li><li>单数据源组合规则。简单规则产生的报警有可能非常多，我们可以通过对简单规则产生的结果进行进一步的处理，来减少报警量，比如：<ol><li>多次报警。当简单规则触发的内部报警在一段时间内超过一定的次数时，才进行真正的报警。</li><li>报警cooldown。当同一报警不停出现时，此规则会进行相应的抑制。</li><li>断崖式报警。当监控数据出现断崖式特征时，才进行报警。</li></ol></li><li>多数据源组合规则。有时候，单一的数据源还不够，需要对多个数据源进行计算后获得，比如：<ol><li>同环比报警。对同一监控项可以拉取不同时间段的两条数据，就可以进行相应的报警。</li><li>组合运算报警。比如说nginx 2xx状态比例的监控，可以通过对2xx次数和总访问次数的计算来获取。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;单数据源简单规则。简单规则通过对每次最新的监控数据进行阈值比较，来获得报警，比如：&lt;ol&gt;
&lt;li&gt;上下限阈值比较。这种是最简单的，定义好上限和下限，就可以发现异常值&lt;/li&gt;
&lt;li&gt;数据存活性比较。当发现某一监控项的数据存在（或消失）时，即报警，用来检查错误
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>select</title>
    <link href="http://www.antizhou.com/golang/select/"/>
    <id>http://www.antizhou.com/golang/select/</id>
    <published>2018-07-06T06:24:15.000Z</published>
    <updated>2018-07-06T06:25:09.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> c, c1, c2, c3, c4 <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> i1, i2 <span class="keyword">int</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"received "</span>, i1, <span class="string">" from c1\n"</span>)</span><br><span class="line"><span class="keyword">case</span> c2 &lt;- i2:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"sent "</span>, i2, <span class="string">" to c2\n"</span>)</span><br><span class="line"><span class="keyword">case</span> i3, ok := (&lt;-c3):  <span class="comment">// same as: i3, ok := &lt;-c3</span></span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"received "</span>, i3, <span class="string">" from c3\n"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"c3 is closed\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> a[f()] = &lt;-c4:</span><br><span class="line">    <span class="comment">// same as:</span></span><br><span class="line">    <span class="comment">// case t := &lt;-c4</span></span><br><span class="line">    <span class="comment">//    a[f()] = t</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"no communication\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;  <span class="comment">// 向 channel c 发送随机 bit 串</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> c &lt;- <span class="number">0</span>:  <span class="comment">// note: no statement, no fallthrough, no folding of cases</span></span><br><span class="line">    <span class="keyword">case</span> c &lt;- <span class="number">1</span>:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;&#125;  <span class="comment">// 永久阻塞</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>import详解</title>
    <link href="http://www.antizhou.com/golang/import/"/>
    <id>http://www.antizhou.com/golang/import/</id>
    <published>2018-07-06T03:23:45.000Z</published>
    <updated>2018-07-06T03:25:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>语法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ImportDeclaration = <span class="string">"import"</span> ImportSpec</span><br><span class="line">ImportSpec        = [ <span class="string">"."</span> | <span class="string">"_"</span> | Identifier ] ImportPath</span><br></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> . <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">"io"</span></span><br><span class="line"><span class="keyword">import</span> log <span class="string">"github.com/sirupsen/logrus"</span></span><br><span class="line"><span class="keyword">import</span> m <span class="string">"math"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"io"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"bufio"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;语法：&lt;br&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>golang字符串</title>
    <link href="http://www.antizhou.com/golang/golang%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://www.antizhou.com/golang/golang字符串/</id>
    <published>2018-07-05T08:04:41.000Z</published>
    <updated>2018-07-05T08:06:24.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"123123"</span></span><br><span class="line">s = s[<span class="number">0</span>:<span class="built_in">len</span>(s)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td
      
    
    </summary>
    
      <category term="golang" scheme="http://www.antizhou.com/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>goalng类型转换</title>
    <link href="http://www.antizhou.com/golang/goalng%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://www.antizhou.com/golang/goalng类型转换/</id>
    <published>2018-07-05T07:50:58.000Z</published>
    <updated>2018-07-05T08:53:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="int-转-string"><a href="#int-转-string" class="headerlink" title="int 转 string"></a>int 转 string</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 通过Itoa方法转换</span></span><br><span class="line">str1 := strconv.Itoa(i)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过Sprintf方法转换</span></span><br><span class="line">str2 := fmt.Sprintf(<span class="string">"%d"</span>, i)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 打印str1</span></span><br><span class="line">fmt.Println(str1)</span><br><span class="line"><span class="comment">// 打印str2</span></span><br><span class="line">fmt.Println(str2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T-转-interface"><a href="#T-转-interface" class="headerlink" title="[]T 转 []interface{}"></a>[]T 转 []interface{}</h1><p>Can I convert a []T to an []interface{}?<br>Not directly, because they do not have the same representation in memory. It is necessary to copy the elements individually to the destination slice. This example converts a slice of int to a slice of interface{}:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(t))</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> t &#123;</span><br><span class="line">    s[i] = v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;int-转-string&quot;&gt;&lt;a href=&quot;#int-转-string&quot; class=&quot;headerlink&quot; title=&quot;int 转 string&quot;&gt;&lt;/a&gt;int 转 string&lt;/h1&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;tab
      
    
    </summary>
    
      <category term="golang" scheme="http://www.antizhou.com/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>golang类型断言(Type Assertion)的应用</title>
    <link href="http://www.antizhou.com/typeassertion/"/>
    <id>http://www.antizhou.com/typeassertion/</id>
    <published>2018-07-05T07:47:53.000Z</published>
    <updated>2018-07-05T07:50:17.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    add(<span class="keyword">int16</span>(<span class="number">1</span>), <span class="keyword">int16</span>(<span class="number">2</span>))</span><br><span class="line">    add(<span class="keyword">float32</span>(<span class="number">1.1</span>), <span class="keyword">float32</span>(<span class="number">2.2</span>))</span><br><span class="line">    add(<span class="keyword">float64</span>(<span class="number">1.1</span>), <span class="keyword">float64</span>(<span class="number">2.2</span>))</span><br><span class="line">    add(<span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> t := a.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"type [%T] add res[%d]\n"</span>, t, a.(<span class="keyword">int</span>)+b.(<span class="keyword">int</span>))</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int16</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"type [%T] add res[%d]\n"</span>, t, a.(<span class="keyword">int16</span>)+b.(<span class="keyword">int16</span>))</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">float32</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"type [%T] add res[%f]\n"</span>, t, a.(<span class="keyword">float32</span>)+b.(<span class="keyword">float32</span>))</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"type [%T] add res[%f]\n"</span>, t, a.(<span class="keyword">float64</span>)+b.(<span class="keyword">float64</span>))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"type [%T] not support!\n"</span>, t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p>type [int] add res[3]<br>type [int16] add res[3]<br>type [float32] add res[3.300000]<br>type [float64] add res[3.300000]<br>type [bool] not support!</p><p>用interface{}作参数，是不是很像C++的模板函数,而类型断言是不是很像C++的类层次间的下行转换(也是不一定成功的)。需要注意的是，a.(type)只能和switch搭配使用。在使用前得用断言指明变量的类型，如果断言错误就会触发panic。</p><p>如果不想触发panic，先做判断再使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="keyword">int16</span>(<span class="number">2</span>)</span><br><span class="line">    b := <span class="keyword">int32</span>(<span class="number">3</span>)</span><br><span class="line">    add(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    _, ok := a.(<span class="keyword">int32</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">"error type assertion!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    b = b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>error type assertion!<br>2.用于转换结构体的interface{}类型字段<br>例如，我们写handler去接收消息，不可能每个发来的消息都写个函数去handle。利用空接口和类型断言的特性，就可以将业务抽象出来:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line">    <span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">type</span> NetMsg <span class="keyword">struct</span> &#123;</span><br><span class="line">        MsgID <span class="keyword">int16</span></span><br><span class="line">        Data  <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">        name <span class="keyword">string</span></span><br><span class="line">        age  <span class="keyword">int16</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">        name <span class="keyword">string</span></span><br><span class="line">        age  <span class="keyword">int32</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">type</span> human <span class="keyword">struct</span> &#123;</span><br><span class="line">        name <span class="keyword">string</span></span><br><span class="line">        age  <span class="keyword">int64</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        msg1 := NetMsg&#123;<span class="number">1</span>, Cat&#123;<span class="string">"Qian"</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line">        msg2 := NetMsg&#123;<span class="number">2</span>, Dog&#123;<span class="string">"doge"</span>, <span class="number">8</span>&#125;&#125;</span><br><span class="line">        msg3 := NetMsg&#123;<span class="number">3</span>, Dog&#123;<span class="string">"allu"</span>, <span class="number">18</span>&#125;&#125;</span><br><span class="line">        msg_handler(msg1)</span><br><span class="line">        time.Sleep(<span class="number">2000</span> * time.Millisecond)</span><br><span class="line">        msg_handler(msg2)</span><br><span class="line">        time.Sleep(<span class="number">2000</span> * time.Millisecond)</span><br><span class="line">        msg_handler(msg3)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">msg_handler</span><span class="params">(msg NetMsg)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> msg.MsgID &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            cat := msg.Data.(Cat)</span><br><span class="line">            fmt.Printf(<span class="string">"Do Something with Msg 1 %v \n"</span>, cat)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            dog := msg.Data.(Dog)</span><br><span class="line">            fmt.Printf(<span class="string">"Do Something with Msg 2 %v \n"</span>, dog)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"Error MsgID [%d] \n"</span>, msg.MsgID)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>运行结果:<br>Do Something with Msg 1 {Qian 1}<br>Do Something with Msg 2 {doge 8}<br>Error MsgID [3]</p><p><a href="https://segmentfault.com/a/1190000012495480" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012495480</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
      <category term="golang" scheme="http://www.antizhou.com/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>binlog</title>
    <link href="http://www.antizhou.com/binlog/"/>
    <id>http://www.antizhou.com/binlog/</id>
    <published>2018-07-03T13:03:57.000Z</published>
    <updated>2018-07-03T13:04:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>操作binglog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">查看是否启用了日志</span><br><span class="line">mysql&gt; show variables like &apos;log_%&apos;; </span><br><span class="line"></span><br><span class="line">查看所有binlog日志列表</span><br><span class="line">mysql&gt; show master logs;</span><br><span class="line"></span><br><span class="line">查看master状态，即最后(最新)一个binlog日志的编号名称，及其最后一个操作事件pos结束点(Position)值</span><br><span class="line">mysql&gt; show master status;</span><br><span class="line"></span><br><span class="line">刷新log日志，自此刻开始产生一个新编号的binlog日志文件</span><br><span class="line">mysql&gt; flush logs;</span><br><span class="line"></span><br><span class="line">重置(清空)所有binlog日志</span><br><span class="line">mysql&gt; reset master;</span><br></pre></td></tr></table></figure><p>MySQLbinlog模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看MySQLbinlog模式</span><br><span class="line">show global variables like &quot;binlog%&quot;;</span><br><span class="line"></span><br><span class="line">MySQL中设置binlog模式</span><br><span class="line">set global binlog_format=&apos;ROW&apos;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;操作binglog&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/spa
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.antizhou.com/categories/mysql/"/>
    
    
      <category term="binlog" scheme="http://www.antizhou.com/tags/binlog/"/>
    
      <category term="mysql" scheme="http://www.antizhou.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>homebrew 安装 mysql 以及配置</title>
    <link href="http://www.antizhou.com/mysqlinstall/"/>
    <id>http://www.antizhou.com/mysqlinstall/</id>
    <published>2018-07-03T12:53:08.000Z</published>
    <updated>2018-07-03T12:55:13.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><code>brew install mysql</code> (安装)</p></li><li><p>添加修改mysql配置</p><p><code>mysqld --help --verbose | more</code> (查看帮助, 按空格下翻)</p><p>你会看到开始的这一行(表示配置文件默认读取顺序)</p><p>Default options are read from the following files in the given order:<br>/etc/my.cnf /etc/mysql/my.cnf /usr/local/etc/my.cnf ~/.my.cnf</p><p>通常这些位置是没有配置文件的, 所以要自己建一个</p><p><code>ls $(brew --prefix mysql)/support-files/my-*</code> (用这个可以找到样例.cnf)</p><p><code>cp /usr/local/opt/mysql/support-files/my-default.cnf /etc/my.cnf</code> (拷贝到第一个默认读取目录)</p><p>按需修改my.cnf</p></li><li><p>brew services start mysql (启动)</p></li><li><p>brew services stop mysql (停止)</p></li></ol><p><a href="https://segmentfault.com/q/1010000000475470" target="_blank" rel="noopener">https://segmentfault.com/q/1010000000475470</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;brew install mysql&lt;/code&gt; (安装)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加修改mysql配置&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mysqld --help --verbose | more&lt;/code&gt; (查看帮助, 按空格下
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.antizhou.com/categories/mysql/"/>
    
    
      <category term="install" scheme="http://www.antizhou.com/tags/install/"/>
    
      <category term="config" scheme="http://www.antizhou.com/tags/config/"/>
    
  </entry>
  
  <entry>
    <title>构建应用服务的监控报警系统</title>
    <link href="http://www.antizhou.com/alarm/%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://www.antizhou.com/alarm/构建应用服务的监控报警系统/</id>
    <published>2018-06-29T08:41:25.000Z</published>
    <updated>2018-06-29T08:58:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨晚做了个技术分享, 今天整理一下发上来.</p><h2 id="Be-unknown-hard-to-survive"><a href="#Be-unknown-hard-to-survive" class="headerlink" title="Be unknown, hard to survive"></a>Be unknown, hard to survive</h2><p>对于我们应用开发团队来说, 上层应用开发每天要面对最多的就是业务逻辑.<br>而我们都知道, 业务逻辑的最大特点就是 <strong>量大,复杂,多变</strong>.<br>三天两头变动的需求以及突发的任务都会很大程度的影响业务逻辑, 导致它们状态很难控制.</p><p>也正因如此, 特别是创业团队, 在开发之初往往着重于功能的实现上, 很可能就降低了对代码质量, 算法性能以及架构设计的要求.<br>这种情况下对某些环节的监控基本上就被遗漏了, 于是导致潜在的问题不易发现, 突发问题不易排查.<br>所以最开始产出的代码质量很难保证, 即便是上线了后能否稳定运行心里也不敢打保票.</p><h3 id="当线上服务出现问题时…"><a href="#当线上服务出现问题时…" class="headerlink" title="当线上服务出现问题时…"></a>当线上服务出现问题时…</h3><p>当有人告诉你服务挂了时, 怎么办呢, 你可能会很淡定的先去服务器上查查日志来看看他究竟怎么了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail -n500 /.../service/output.log | grep ...</span><br><span class="line">tail -n500 /.../service/error.log | grep ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后呢, 你发现那个错误并不能按照以往的经验来准确判断, 或者 errorlog 里啥都没有,<br>再有可能 error log 里面一大堆, 你慢慢找吧.</p><p>好吧, 那就再等等, 看看他能不能重现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -F ...</span><br></pre></td></tr></table></figure><p>然后再看看 Kibana 的 dashboard. 然而折腾半天之前的问题就是没出现…</p><p>有的人说: 那个错误至今没有复现, 应该不算啥大的问题吧..?<br>也有人说: 是不是发生遵循什么规律但我们没发现..?</p><p>不过眼前还有其他好多要紧的任务呢, 这个问题反正不常出现, 日后再说..</p><p>好吧, 那就日后再说… 直到某一天, “卧槽, 怎么又莫名其妙的出现了 ?!”</p><p>开发有点慌了, 这时候才真正开始重视这个问题…</p><p>他在想, “要是能尽早的得知问题就好了”, “要是突发问题有提醒就好了, 不用自己盯着日志一行行看…”</p><h2 id="别担心-交给自动化工具完成"><a href="#别担心-交给自动化工具完成" class="headerlink" title="别担心, 交给自动化工具完成"></a>别担心, 交给自动化工具完成</h2><p>其实不用慌, 看来他只是缺少一个自动化的工具嘛~</p><p>那么这个自动化工具是做什么的? 其实就是解决上面两个问题的:</p><ul><li>在真正更严重的问题出现之前预防它.</li><li>当出现了未知问题时及时得知.</li></ul><h3 id="什么值得去监控和报警"><a href="#什么值得去监控和报警" class="headerlink" title="什么值得去监控和报警?"></a>什么值得去监控和报警?</h3><p>那么, 怎么做? 换句话说, 什么 <strong>值得</strong> 我们去监控和报警?<br>要回答这个问题, 首先我们要明确一点:<br>公司中的每个技术团队都有其存在的价值与意义, 他们的工作作用于不同层面,<br>对于我们应用开发来说, 没必要越疱代俎去重复底层运维的任务.</p><p>我们要做什么呢? 我们面对的是大量复杂的 <strong>业务逻辑</strong>, 这才是关注的重点.<br>就我们的团队而言, 比如说:</p><ul><li>哪些接口的平均/瞬时访问量比较大?</li><li>一个微服务架构的调用链中, 哪些环节的耗时比较长? 各自对应了哪些业务?</li><li>一个服务/接口的可用性有多少?</li><li>哪些接口的吞吐率较低?</li><li>…</li></ul><p>好了, 基于以上分析, 我们就可以明确到底要监测哪些指标, 也能够清楚每个监测指标的报警条件了.<br>接下来, 就谈谈我们的报警系统的构架.</p><h2 id="Alarm-System"><a href="#Alarm-System" class="headerlink" title="Alarm System"></a>Alarm System</h2><p>我们把整个系统分为四大环节:</p><ol><li>指标数据的 <strong>采集</strong></li><li><strong>传输</strong> &amp; 处理</li><li><strong>分析</strong>计算</li><li>(有问题的话) <strong>通知</strong></li></ol><h3 id="收集代理"><a href="#收集代理" class="headerlink" title="收集代理"></a>收集代理</h3><h4 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h4><p>首先来看一下采集环, 这是所有工作的第一个环节.<br>最基本的数据来源无非是以下三个:</p><ul><li>代码埋点</li><li>日志</li><li>数据库</li></ul><p>因为数据源特点的不同, 我们在采集时也面临一些问题.</p><p>有些项目可能由于历史原因, 对其代码中插入埋点十分不便, 并且容易牵连到很多其他组件.<br>数据库如 elasticsearch 并没有(也不可能)提供 changefeed 能力, 此外 elasticsearch 侧重于读优化而不是快速写入,<br>也就是说通过它采集数据的方式可能并不适合某些对实时性要求严格的分析过程.<br>而日志呢, 它们的收集以及格式处理又需要额外的工具(比如 logstash).</p><p>为了解决数据来源的不确定性, 统一数据格式, 我们在采集这个环节中增加了一个 collect agent: Portal.<br>它除了用于收集实时的指标, 还用于数据的广播, 解耦系统以及快速持久化.</p><p>现在, 待检测的指标都可以发送到 Portal 了.</p><h4 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h4><p>那么从数据源到 portal 这段过程, 指标是以什么形式传输的? 使用了什么协议?<br>这部分就讲一下从 <strong>日志/埋点</strong> 收集的指标数据的传输处理过程.</p><h5 id="我们收集的数据是什么"><a href="#我们收集的数据是什么" class="headerlink" title="我们收集的数据是什么?"></a>我们收集的数据是什么?</h5><p>这是在设计前要考虑的问题, 与其说是什么, 不如说是什么性质的.<br>既然是用于检测的指标, 那么它应该与业务数据隔离开, 也就是说它们是非业务数据,<br>属于样本性质, 那么也就容忍了部分丢失的可能.</p><h5 id="最佳选择"><a href="#最佳选择" class="headerlink" title="最佳选择"></a>最佳选择</h5><p>既然这样, 那么我们的选择显而易见: UDP 数据报.<br>它的特点大家都清楚: 速度快, 不用维护连接开销.</p><h5 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h5><p>理论上来说, 应该是直接从数据源发送到分析系统, 这是最快捷的方式,<br>但是现在中间多了一层 agent,<br>为了把效率的影响降低到最小, 必须要求数据的传输足够快, 转发上消耗的时间足够少.<br>因此, 我们的设计遵循了 KISS 原则:</p><ul><li>格式简单容易解析</li><li>无分片</li></ul><p>为了在 MTU 不确定的链路环境下尽量不产生分片, 我们将 UDP 数据报的大小限制在 508 byte 之内.</p><blockquote><p>min MTU (576 byte) - max IP Header (60 byte) - UDP Header (8<br>byte)</p></blockquote><p>在这种限制下, 数据报的格式是这样的:</p><p><img src="/images/70722656-b314-11e6-87f5-43d3376421ad-20180629161442930.png" alt="2016-11-25 12 12 28"></p><p>虽然保证了效率, 但这一做法严格限制了数据的使用, 这就要求指标只携带那些绝对有价值的信息.</p><p>Portal 架构如下:</p><p><img src="/images/9998d65c-c858-11e6-8cd1-8d8e2ba2b1c8-20180629161446018.png" alt="archangel architecture - new page"></p><h3 id="规则引擎"><a href="#规则引擎" class="headerlink" title="规则引擎"></a>规则引擎</h3><p>当 portal 拿到指标之后, 下一步就通过一个 TCP 长连接将数据交给整个系统的核心组件进行处理了.<br>在设计部分组件之前, 我考虑的问题一直是如何让它更容易使用.<br>因为规则引擎是这个系统与使用者(维护者)交互的唯一入口: 由使用者配置报警规则.<br>如何 <strong>对开发者友好</strong>?<br>我觉得用简单的描述性语言写一个配置文件, 然后告诉系统你想要配置的报警规则是再简单不过了.</p><p>比如说… 一个 YAML 语法的配置:</p><p><img src="/images/a162535c-b315-11e6-9a68-e755b0fa6a9e-20180629161559038.png" alt="2016-11-25 12 19 32"></p><p>受到 Ansible 的启发, 我就选择了 YAML 描述语言作为规则的基础语法.</p><p>下面介绍一下研发的这个规则引擎 Luna. 它是由三部分构成:</p><ul><li>翻译引擎(YAML 语法)</li><li>异常分析</li><li>报警器</li></ul><p>其工作原理就是: 将规则语法翻译成一个上下文对象 (你可以理解为 SDT 语法制导翻译的过程),<br>异常分析通过这个上下文对象初始化一个探测器, 并作用于符合条件的监控指标,<br>一旦检测到异常, 那么就调用报警器生成一个警报对象, 并将其格式化后发送给通知系统.</p><p>Luna 架构如下:</p><p><img src="/images/d6d4fe1e-c859-11e6-9778-21b765fc5979-20180629161607890.png" alt="fff - new page"></p><h4 id="检测指标类型"><a href="#检测指标类型" class="headerlink" title="检测指标类型"></a>检测指标类型</h4><p>对于异常分析来说, 他要做的就是对所有指标做分析, 计算, 观察他们是否符合既定的报警条件.<br>那么这些指标都有什么意义呢? 或者说那些维度可以衡量?</p><p>早在 2008 年, flicker 的工程师在一片技术博客里提到了 counting &amp; timing 的计量思路, 就是计数和计时.</p><p>Luna 为了提供更多的便捷分析途径, 在此基础上衍生出了更多的测量维度:</p><ul><li>count</li><li>time</li><li>value (例如: 满足值为 xx 的指标)</li><li>rate (例如: 成功率)</li><li>binary (只要拿到这个指标就满足条件)</li><li>complex condition</li></ul><h4 id="周期分析-or-实时计算"><a href="#周期分析-or-实时计算" class="headerlink" title="周期分析 or 实时计算?"></a>周期分析 or 实时计算?</h4><p>就拿 count 计量维度来讲, 数量肯定说的是一个时间区间内的, 这就产生了一个问题: 时间区间怎么定,<br>是滑动窗口还是跃迁窗口?</p><p>那为什么要划分实时和周期计量呢? 要回答这个问题, 得清楚几点:</p><ul><li>不同类型(测量维度)指标的获取方式可能不同.</li><li>同类(维度)指标的获取方式也可能不同.</li><li>指标的监视粒度粗细不同.</li></ul><p>因此两种方案都有意义, 并且 Luna 都提供了, 但应用哪种取决于很多因素.<br>Luna 中由以下因素决定使用哪种时间窗口:</p><ul><li>数据源类型(elasticsearch, stream)</li><li>时间区间标识(in, each)</li><li>指标维度</li></ul><p>通常, 从 elasticsearch 取出的数据应该使用 in 作为时间区间, 这种就属于周期性计算.<br>而来自实时流 stream 中的数据应该使用 each 作为时间区间, 这种情况则是实时计算.<br>另外, binary, value, time 只能用于实时计算, 而 count, rate 以及复杂规则既能用于实时又能进行周期计算.</p><p> 使用案例</p><p>这里拿出几个应用开发中常见需求, 整理几个常用的报警规则示例:</p><ol><li>从实时流中获取接口 a 的耗时指标, 如果耗时超过 200ms, 那么触发 warn 等级警报.<br><img src="/images/861d2b54-b314-11e6-9859-9fbe921ce4e8-20180629161741481.png" alt="2016-11-25 12 46 19"></li><li>从 elasticsearch 里获取接口 a 的访问计数指标, 如果每分钟的访问量低于 10 或高于 10_000, 触发 warn 等级警报.<br><img src="/images/8e8bec94-b314-11e6-8150-e0b0cbbe54b9.png" alt="2016-11-25 12 48 04"></li><li>从 elasticsearch 里获取接口 a 的可用性指标, 如果每分钟访问成功率(指标携带的数据中包含 state 字段为 200 的比率)低于 60%, 报 crash 警报.<br><img src="/images/97cb9f20-b314-11e6-9fc0-257294732950.png" alt="2016-11-25 12 48 52"></li><li>从实时流中获取项目 A 的错误日志, 一旦有, 则触发 error 警报.<br><img src="/images/a520853c-b314-11e6-863c-33d29f71bbf0.png" alt="2016-11-25 12 49 44"></li></ol><h4 id="SMMR"><a href="#SMMR" class="headerlink" title="SMMR"></a>SMMR</h4><p>上面演示的四个例子中, 每个都只是对单个测量指标数据应用了单个规则, 那么若果我想要施加多份规则呢?<br>没关系, Luna 提供了 S(ingle)M(easure)M(utiple)R(rules), 你可以这么写:</p><p><img src="/images/ed620a00-b314-11e6-8fcf-904b6d764b10.png" alt="2016-11-25 12 53 27"></p><h4 id="更灵活的规则设置"><a href="#更灵活的规则设置" class="headerlink" title="更灵活的规则设置"></a>更灵活的规则设置</h4><p>但是尽管可以 SMMR, 上面的规则都太简单了, 如果我的需求很古怪, 很复杂怎么办?<br>在设计之初就考虑到了这点, 在基本规则不够使用时, 允许你根据自己的需求灵活的定义规则.</p><p>这就要提到另外的两个计量维度: fit/bulk.</p><p>分别表示: 对每个实时指标的自定义处理, 对一个时间窗口内的数据集合自定义处理.</p><p>当指定 <code>for</code> 指令为 <code>fit</code> 或 <code>bulk</code> 时, Luna 就启用了规则自定义:</p><p><img src="/images/f764b6ba-b314-11e6-9625-8ea558157f66.png" alt="2016-11-25 12 58 15"></p><p>那么我要如何生成自己的规则检测逻辑呢? 这里要使用一个新的指令: <code>handle</code>,<br>你可以通过在 handle 中编写 Ruby 代码来自定义数据处理过程:</p><p><img src="/images/002c20f8-b315-11e6-9bd5-e2a175762fed.png" alt="2016-11-25 13 00 04"></p><p>其中 handle 里可以使用两个重要变量: data, vars.</p><p>data 依据 <code>for</code> 的不同可能是一个实时数据或者是一个时间区间内的数据集.<br>vars 是通过 <code>vars</code> 指令设置的预定义变量列表.</p><p>那么何时报警呢?</p><p>在自定义过程中, Luna 默认不会触发任何警报, 除非 handle 的代码中返回一个 Hash,<br>其中可以包含 <code>:reason</code> (报警理由), <code>:timestamp</code> 等字段.</p><h3 id="通知系统"><a href="#通知系统" class="headerlink" title="通知系统"></a>通知系统</h3><p>当 Luna 得出了产生异常的结论, 就可以告知通知系统去通知相关人员了.<br>这一环节我们基于 GitHub 的开源项目 Hubot 完成.</p><p>Hubot 算是一种 ChatOps 思想的产物(交互式 DevOps), 我们团队中好多管理工作都交给 Hubot 完成,<br>当然报警系统也不例外.</p><p>通过与 Slack 的高度整合, 可以很容易的完成按项目分群组通知的功能. 数据流见下图:</p><p><img src="/images/08d4ad7e-b315-11e6-8b4e-b97fdd098667.png" alt="2016-11-25 13 09 11"></p><p>即由 Hubot 决定是发送邮件给对应项目成员还是广播到 Slack 相应的 channel.</p><p><img src="/images/14817300-b315-11e6-9ac6-b610ddea942b.png" alt="2016-11-25 13 10 25"></p><h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><p>接下来谈谈系统的扩展能力.<br>我们知道, 当应用规模/数据规模达到一定程度时, 单一节点的处理能力是远远不够的, 这时候需要横向扩展.<br>那么 Luna 能否水平扩展? 很幸运, 这非常简单, 因为 Luna 本身是一个无状态系统.</p><p>扩展方案有很多, 给出两个最简单的场景:</p><ol><li>人工将测量指标划分成槽, 每个 Luna 实例负责一个槽的计算.</li><li>借助 Portal 的分布式特性完成自动化负载均衡.</li></ol><p>这样便可以达到分散单一节点的计算压力以及降低资源开销的目的了.</p><h3 id="What-and-Not"><a href="#What-and-Not" class="headerlink" title="What and Not"></a>What and Not</h3><p>因为有些问题并不是单单从错误就能看出来的,<br>所以我们这个报警系统的目的只是 <strong>尽早的自动化告知可能存在的隐患</strong>.<br>所以它并不是为了取缔目前的监控工具链存在, 像 ELK 全家桶之类的工具依然在后续的分析过程中扮演了重要角色.</p><h3 id="未来发展"><a href="#未来发展" class="headerlink" title="未来发展"></a>未来发展</h3><p>最后谈谈今后的计划, 首先会从以下几点完善整个系统:</p><ul><li>适配更多数据源. 目前仅仅支持两个, 未来可能会加入 <code>script</code> 源, 允许更灵活的配置.</li><li>支持更丰富的规则语法. 比如现在 <code>which</code> 指令只允许写入固定值, 无法模糊匹配.</li><li>提供智能化异常检测(动态范围阈值). 因为当前的规则设定都需要人为写死的, 某些场景可能需要大量历史数据来判断当前区域内是否有异常出现, 这个目前最简单的方案就是用统计学中的 3-sigma 标准来判断, 或者使用更高级的手段如 Airbnb 内部使用的快速傅里叶变换等数学方法.</li><li>持久化报警事件. 比如可以根据报警事件的产生频率做进一步的统计分析.</li><li>规则热加载(开发中). 现在 Luna 只支持冷加载, 启动时将所有规则文件读入内存解析, 要想更新或加入其它规则文件必须要重启.</li><li>命令行管理工具(开发中). 每次都去修改规则文件可能并不合适, 提供一个轻便的配置工具以 RPC 形式控制 Luna 应该会更方便.</li></ul><h3 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h3><p>关于 Luna 的规则语法以及使用方案还有很多, 但目前只在内部使用阶段, 未来会考虑开源相关项目同时开放详细文档.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://github.com/abbshr/abbshr.github.io/issues/59" target="_blank" rel="noopener">https://github.com/abbshr/abbshr.github.io/issues/59</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨晚做了个技术分享, 今天整理一下发上来.&lt;/p&gt;
&lt;h2 id=&quot;Be-unknown-hard-to-survive&quot;&gt;&lt;a href=&quot;#Be-unknown-hard-to-survive&quot; class=&quot;headerlink&quot; title=&quot;Be unknown,
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>秒级监控</title>
    <link href="http://www.antizhou.com/%E7%A7%92%E7%BA%A7%E7%9B%91%E6%8E%A7/"/>
    <id>http://www.antizhou.com/秒级监控/</id>
    <published>2018-06-08T06:10:32.000Z</published>
    <updated>2018-06-08T06:27:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5a50d0c55188257322588532" target="_blank" rel="noopener">阿里数据库进入全网秒级实时监控时代</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5a50d0c55188257322588532&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阿里数据库进入全网秒级实时监控时代&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mysql加锁处理分析</title>
    <link href="http://www.antizhou.com/mysql%E5%8A%A0%E9%94%81%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://www.antizhou.com/mysql加锁处理分析/</id>
    <published>2018-05-24T14:02:29.000Z</published>
    <updated>2018-05-24T14:03:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>MySQL/InnoDB的加锁分析，一直是一个比较困难的话题。我在工作过程中，经常会有同事咨询这方面的问题。同时，微博上也经常会收到MySQL锁相关的私信，让我帮助解决一些死锁的问题。本文，准备就MySQL/InnoDB的加锁问题，展开较为深入的分析与讨论，主要是介绍一种思路，运用此思路，拿到任何一条SQL语句，都能完整的分析出这条语句会加什么锁？会有什么样的使用风险？甚至是分析线上的一个死锁场景，了解死锁产生的原因。 </p><p><strong>注：</strong>MySQL是一个支持插件式存储引擎的数据库系统。本文下面的所有介绍，都是基于InnoDB存储引擎，其他引擎的表现，会有较大的区别。</p><h2 id="MVCC：Snapshot-Read-vs-Current-Read"><a href="#MVCC：Snapshot-Read-vs-Current-Read" class="headerlink" title="MVCC：Snapshot Read vs Current Read"></a>MVCC：Snapshot Read vs Current Read</h2><p>MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (<a href="http://en.wikipedia.org/wiki/Multiversion_concurrency_control" target="_blank" rel="noopener">Multi-Version Concurrency Control</a>) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。MVCC最大的好处，相信也是耳熟能详：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，这也是为什么现阶段，几乎所有的RDBMS，都支持了MVCC。</p><p>在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</p><p>在一个支持MVCC并发控制的系统中，哪些读操作是快照读？哪些操作又是当前读呢？以MySQL InnoDB为例：</p><ul><li><p><strong>快照读：</strong>简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析)</p><ul><li>select * from table where ?;</li></ul></li><li><p><strong>当前读：</strong>特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。</p><ul><li>select * from table where ? lock in share mode;</li><li>select * from table where ? for update;</li><li>insert into table values (…);</li><li>update table set ? where ?;</li><li>delete from table where ?;</li></ul><p>所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。</p></li></ul><p>为什么将 插入/更新/删除 操作，都归为当前读？可以看看下面这个 更新 操作，在数据库中的执行流程：</p><p><a href="http://www.yupoo.com/photos/hedengcheng/90010766/" target="_blank" rel="noopener"><img src="http://pic.yupoo.com/hedengcheng/DnJ6RwcV/medish.jpg" alt="update 执行流程"></a></p><p>从图中，可以看到，一个Update操作的具体流程。当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁 (current read)。待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了一个当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。</p><p><strong>注</strong>：根据上图的交互，针对一条当前读的SQL语句，InnoDB与MySQL Server的交互，是一条一条进行的，因此，加锁也是一条一条进行的。先对一条满足条件的记录加锁，返回给MySQL Server，做一些DML操作；然后在读取下一条加锁，直至读取完毕。</p><h2 id="Cluster-Index：聚簇索引"><a href="#Cluster-Index：聚簇索引" class="headerlink" title="Cluster Index：聚簇索引"></a>Cluster Index：聚簇索引</h2><p>InnoDB存储引擎的数据组织方式，是聚簇索引表：完整的记录，存储在主键索引中，通过主键索引，就可以获取记录所有的列。关于聚簇索引表的组织方式，可以参考MySQL的官方文档：<a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-index-types.html" target="_blank" rel="noopener">Clustered and Secondary Indexes</a> 。本文假设读者对这个，已经有了一定的认识，就不再做具体的介绍。接下来的部分，主键索引/聚簇索引 两个名称，会有一些混用，望读者知晓。</p><h2 id="2PL：Two-Phase-Locking"><a href="#2PL：Two-Phase-Locking" class="headerlink" title="2PL：Two-Phase Locking"></a>2PL：Two-Phase Locking</h2><p>传统RDBMS加锁的一个原则，就是2PL (二阶段锁)：<a href="http://en.wikipedia.org/wiki/Two-phase_locking" target="_blank" rel="noopener">Two-Phase Locking</a>。相对而言，2PL比较容易理解，说的是锁操作分为两个阶段：加锁阶段与解锁阶段，并且保证加锁阶段与解锁阶段不相交。下面，仍旧以MySQL为例，来简单看看2PL在MySQL中的实现。 </p><p><a href="http://www.yupoo.com/photos/hedengcheng/90010758/" target="_blank" rel="noopener"><img src="http://pic.yupoo.com/hedengcheng/DnJ6Q15k/medish.jpg" alt="2PL"></a></p><p>从上图可以看出，2PL就是将加锁/解锁分为两个完全不相交的阶段。加锁阶段：只加锁，不放锁。解锁阶段：只放锁，不加锁。</p><h2 id="Isolation-Level"><a href="#Isolation-Level" class="headerlink" title="Isolation Level"></a>Isolation Level</h2><p>隔离级别：<a href="http://en.wikipedia.org/wiki/Isolation_(database_systems" target="_blank" rel="noopener">Isolation Level</a>)，也是RDBMS的一个关键特性。相信对数据库有所了解的朋友，对于4种隔离级别：Read Uncommited，Read Committed，Repeatable Read，Serializable，都有了深入的认识。本文不打算讨论数据库理论中，是如何定义这4种隔离级别的含义的，而是跟大家介绍一下MySQL/InnoDB是如何定义这4种隔离级别的。</p><p>MySQL/InnoDB定义的4种隔离级别：</p><ul><li><p><strong>Read Uncommited</strong></p><p>可以读取未提交记录。此隔离级别，不会使用，忽略。</p></li><li><p><strong>Read Committed (RC)</strong></p><p>快照读忽略，本文不考虑。</p><p>针对当前读，<strong>RC隔离级别保证对读取到的记录加锁 (记录锁)</strong>，存在幻读现象。</p></li><li><p><strong>Repeatable Read (RR)</strong></p><p>快照读忽略，本文不考虑。</p><p>针对当前读，<strong>RR隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入 (间隙锁)</strong>，不存在幻读现象。</p></li><li><p><strong>Serializable</strong></p><p>从MVCC并发控制退化为基于锁的并发控制。不区别快照读与当前读，所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。</p><p>Serializable隔离级别下，读写冲突，因此并发度急剧下降，在MySQL/InnoDB下不建议使用。</p></li></ul><h1 id="一条简单SQL的加锁实现分析"><a href="#一条简单SQL的加锁实现分析" class="headerlink" title="一条简单SQL的加锁实现分析"></a>一条简单SQL的加锁实现分析</h1><p> 在介绍完一些背景知识之后，本文接下来将选择几个有代表性的例子，来详细分析MySQL的加锁处理。当然，还是从最简单的例子说起。经常有朋友发给我一个SQL，然后问我，这个SQL加什么锁？就如同下面两条简单的SQL，他们加什么锁？</p><ul><li><strong>SQL1：</strong>select * from t1 where id = 10;</li><li><strong>SQL2：</strong>delete from t1 where id = 10; </li></ul><p>针对这个问题，该怎么回答？我能想象到的一个答案是：</p><ul><li><strong>SQL1：</strong>不加锁。因为MySQL是使用多版本并发控制的，读不加锁。</li><li><strong>SQL2：</strong>对id = 10的记录加写锁 (走主键索引)。</li></ul><p>这个答案对吗？说不上来。即可能是正确的，也有可能是错误的，已知条件不足，这个问题没有答案。如果让我来回答这个问题，我必须还要知道以下的一些前提，前提不同，我能给出的答案也就不同。要回答这个问题，还缺少哪些前提条件？</p><ul><li><p><strong>前提一：</strong>id列是不是主键？ </p></li><li><p><strong>前提二：</strong>当前系统的隔离级别是什么？</p></li><li><p><strong>前提三：</strong>id列如果不是主键，那么id列上有索引吗？</p></li><li><p><strong>前提四：</strong>id列上如果有二级索引，那么这个索引是唯一索引吗？</p></li><li><p><strong>前提五：</strong>两个SQL的执行计划是什么？索引扫描？全表扫描？</p></li></ul><p>没有这些前提，直接就给定一条SQL，然后问这个SQL会加什么锁，都是很业余的表现。而当这些问题有了明确的答案之后，给定的SQL会加什么锁，也就一目了然。下面，我将这些问题的答案进行组合，然后按照从易到难的顺序，逐个分析每种组合下，对应的SQL会加哪些锁？ </p><p><strong>注：</strong>下面的这些组合，我做了一个前提假设，也就是有索引时，执行计划一定会选择使用索引进行过滤 (索引扫描)。但实际情况会复杂很多，真正的执行计划，还是需要根据MySQL输出的为准。</p><ul><li><strong>组合一：</strong>id列是主键，RC隔离级别</li><li><strong>组合二：</strong>id列是二级唯一索引，RC隔离级别</li><li><strong>组合三：</strong>id列是二级非唯一索引，RC隔离级别</li><li><strong>组合四：</strong>id列上没有索引，RC隔离级别</li><li><strong>组合五：</strong>id列是主键，RR隔离级别</li><li><strong>组合六：</strong>id列是二级唯一索引，RR隔离级别</li><li><strong>组合七：</strong>id列是二级非唯一索引，RR隔离级别</li><li><strong>组合八：</strong>id列上没有索引，RR隔离级别</li><li><strong>组合九：</strong>Serializable隔离级别</li></ul><p>排列组合还没有列举完全，但是看起来，已经很多了。真的有必要这么复杂吗？事实上，要分析加锁，就是需要这么复杂。但是从另一个角度来说，只要你选定了一种组合，SQL需要加哪些锁，其实也就确定了。接下来，就让我们来逐个分析这9种组合下的SQL加锁策略。 </p><p>注：在前面八种组合下，也就是RC，RR隔离级别下，SQL1：select操作均不加锁，采用的是快照读，因此在下面的讨论中就忽略了，主要讨论SQL2：delete操作的加锁。</p><h2 id="组合一：id主键-RC"><a href="#组合一：id主键-RC" class="headerlink" title="组合一：id主键+RC"></a>组合一：id主键+RC</h2><p>这个组合，是最简单，最容易分析的组合。id是主键，Read Committed隔离级别，给定SQL：delete from t1 where id = 10; 只需要将主键上，id = 10的记录加上X锁即可。如下图所示：</p><p><a href="http://www.yupoo.com/photos/hedengcheng/90010765/" target="_blank" rel="noopener"><img src="http://pic.yupoo.com/hedengcheng/DnJ6RtaP/medish.jpg" alt="id主键+rc"></a></p><p><strong>结论：</strong>id是主键时，此SQL只需要在id=10这条记录上加X锁即可。</p><h2 id="组合二：id唯一索引-RC"><a href="#组合二：id唯一索引-RC" class="headerlink" title="组合二：id唯一索引+RC"></a>组合二：id唯一索引+RC</h2><p>这个组合，id不是主键，而是一个Unique的二级索引键值。那么在RC隔离级别下，delete from t1 where id = 10; 需要加什么锁呢？见下图：</p><p><a href="http://www.yupoo.com/photos/hedengcheng/90010759/" target="_blank" rel="noopener"><img src="http://pic.yupoo.com/hedengcheng/DnJ6PDep/medish.jpg" alt="id unique+rc"></a></p><p>此组合中，id是unique索引，而主键是name列。此时，加锁的情况由于组合一有所不同。由于id是unique索引，因此delete语句会选择走id列的索引进行where条件的过滤，在找到id=10的记录后，首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name = ‘d’ 对应的主键索引项加X锁。为什么聚簇索引上的记录也要加锁？试想一下，如果并发的一个SQL，是通过主键索引来更新：update t1 set id = 100 where name = ‘d’; 此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新/删除需要串行执行的约束。 </p><p><strong>结论</strong>：若id列是unique列，其上有unique索引。那么SQL需要加两个X锁，一个对应于id unique索引上的id = 10的记录，另一把锁对应于聚簇索引上的[name=’d’,id=10]的记录。</p><h2 id="组合三：id非唯一索引-RC"><a href="#组合三：id非唯一索引-RC" class="headerlink" title="组合三：id非唯一索引+RC"></a>组合三：id非唯一索引+RC</h2><p> 相对于组合一、二，组合三又发生了变化，隔离级别仍旧是RC不变，但是id列上的约束又降低了，id列不再唯一，只有一个普通的索引。假设delete from t1 where id = 10; 语句，仍旧选择id列上的索引进行过滤where条件，那么此时会持有哪些锁？同样见下图：</p><p><a href="http://www.yupoo.com/photos/hedengcheng/90010762/" target="_blank" rel="noopener"><img src="http://pic.yupoo.com/hedengcheng/DnJ6RA8t/medish.jpg" alt="id 非唯一索引+rc"></a></p><p>根据此图，可以看到，首先，id列索引上，满足id = 10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁。与组合二唯一的区别在于，组合二最多只有一个满足等值查询的记录，而组合三会将所有满足查询条件的记录都加锁。</p><p><strong>结论</strong>：若id列上有非唯一索引，那么对应的所有满足SQL查询条件的记录，都会被加锁。同时，这些记录在主键索引上的记录，也会被加锁。</p><h2 id="组合四：id无索引-RC"><a href="#组合四：id无索引-RC" class="headerlink" title="组合四：id无索引+RC"></a>组合四：id无索引+RC</h2><p>相对于前面三个组合，这是一个比较特殊的情况。id列上没有索引，where id = 10;这个过滤条件，没法通过索引进行过滤，那么只能走全表扫描做过滤。对应于这个组合，SQL会加什么锁？或者是换句话说，全表扫描时，会加什么锁？这个答案也有很多：有人说会在表上加X锁；有人说会将聚簇索引上，选择出来的id = 10;的记录加上X锁。那么实际情况呢？请看下图：</p><p><a href="http://www.yupoo.com/photos/hedengcheng/90010763/" target="_blank" rel="noopener"><img src="http://pic.yupoo.com/hedengcheng/DnJ6Rt0M/medish.jpg" alt="id 无索引+rc"></a></p><p>由于id列上没有索引，因此只能走聚簇索引，进行全部扫描。从图中可以看到，满足删除条件的记录有两条，但是，聚簇索引上所有的记录，都被加上了X锁。无论记录是否满足条件，全部被加上X锁。既不是加表锁，也不是在满足条件的记录上加行锁。</p><p>有人可能会问？为什么不是只在满足条件的记录上加锁呢？这是由于MySQL的实现决定的。如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由MySQL Server层进行过滤。因此也就把所有的记录，都锁上了。</p><p>注：在实际的实现中，MySQL有一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁 (违背了2PL的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。</p><p><strong>结论：</strong>若id列上没有索引，SQL会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。因此每条记录，无论是否满足条件，都会被加上X锁。但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省略。同时，优化也违背了2PL的约束。</p><h2 id="组合五：id主键-RR"><a href="#组合五：id主键-RR" class="headerlink" title="组合五：id主键+RR"></a>组合五：id主键+RR</h2><p>上面的四个组合，都是在Read Committed隔离级别下的加锁行为，接下来的四个组合，是在Repeatable Read隔离级别下的加锁行为。 </p><p>组合五，id列是主键列，Repeatable Read隔离级别，针对delete from t1 where id = 10; 这条SQL，加锁与组合一：[<a href="http://hedengcheng.com/?p=771#_%E7%BB%84%E5%90%88%E4%B8%80%EF%BC%9Aid%E4%B8%BB%E9%94%AE+RC" target="_blank" rel="noopener">id主键，Read Committed</a>]一致。</p><h2 id="组合六：id唯一索引-RR"><a href="#组合六：id唯一索引-RR" class="headerlink" title="组合六：id唯一索引+RR"></a>组合六：id唯一索引+RR</h2><p>与组合五类似，组合六的加锁，与组合二：[<a href="http://hedengcheng.com/?p=771#_%E7%BB%84%E5%90%88%E4%BA%8C%EF%BC%9Aid%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95+RC" target="_blank" rel="noopener">id唯一索引，Read Committed</a>]一致。两个X锁，id唯一索引满足条件的记录上一个，对应的聚簇索引上的记录一个。</p><h2 id="组合七：id非唯一索引-RR"><a href="#组合七：id非唯一索引-RR" class="headerlink" title="组合七：id非唯一索引+RR"></a>组合七：id非唯一索引+RR</h2><p>还记得前面提到的MySQL的四种隔离级别的区别吗？RC隔离级别允许幻读，而RR隔离级别，不允许存在幻读。但是在组合五、组合六中，加锁行为又是与RC下的加锁行为完全一致。那么RR隔离级别下，如何防止幻读呢？问题的答案，就在组合七中揭晓。 </p><p>组合七，Repeatable Read隔离级别，id上有一个非唯一索引，执行delete from t1 where id = 10; 假设选择id列上的索引进行条件过滤，最后的加锁行为，是怎么样的呢？同样看下面这幅图：</p><p><a href="http://www.yupoo.com/photos/hedengcheng/90010761/" target="_blank" rel="noopener"><img src="http://pic.yupoo.com/hedengcheng/DnJ6R7wu/medish.jpg" alt="id 非唯一索引 + rr"></a></p><p>此图，相对于组合三：[<a href="http://hedengcheng.com/?p=771#_%E7%BB%84%E5%90%88%E4%B8%89%EF%BC%9Aid%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95+RC" target="_blank" rel="noopener">id列上非唯一锁，Read Committed</a>]看似相同，其实却有很大的区别。最大的区别在于，这幅图中多了一个GAP锁，而且GAP锁看起来也不是加在记录上的，倒像是加载两条记录之间的位置，GAP锁有何用？</p><p>其实这个多出来的GAP锁，就是RR隔离级别，相对于RC隔离级别，不会出现幻读的关键。确实，GAP锁锁住的位置，也不是记录本身，而是两条记录之间的GAP。所谓幻读，就是同一个事务，连续做两次当前读 (例如：select * from t1 where id = 10 for update;)，那么这两次当前读返回的是完全相同的记录 (记录数量一致，记录本身也一致)，第二次的当前读，不会比第一次返回更多的记录 (幻象)。 </p><p>如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。为了实现这个功能，GAP锁应运而生。</p><p>如图中所示，有哪些位置可以插入新的满足条件的项 (id = 10)，考虑到B+树索引的有序性，满足条件的项一定是连续存放的。记录[6,c]之前，不会插入id=10的记录；[6,c]与[10,b]间可以插入[10, aa]；[10,b]与[10,d]间，可以插入新的[10,bb],[10,c]等；[10,d]与[11,f]间可以插入满足条件的[10,e],[10,z]等；而[11,f]之后也不会插入满足条件的记录。因此，为了保证[6,c]与[10,b]间，[10,b]与[10,d]间，[10,d]与[11,f]不会插入新的满足条件的记录，MySQL选择了用GAP锁，将这三个GAP给锁起来。</p><p>Insert操作，如insert [10,aa]，首先会定位到[6,c]与[10,b]间，然后在插入前，会检查这个GAP是否已经被锁上，如果被锁上，则Insert不能插入记录。因此，通过第一遍的当前读，不仅将满足条件的记录锁上 (X锁)，与组合三类似。同时还是增加3把GAP锁，将可能插入满足条件记录的3个GAP给锁上，保证后续的Insert不能插入新的id=10的记录，也就杜绝了同一事务的第二次当前读，出现幻象的情况。</p><p>有心的朋友看到这儿，可以会问：既然防止幻读，需要靠GAP锁的保护，为什么组合五、组合六，也是RR隔离级别，却不需要加GAP锁呢？ </p><p>首先，这是一个好问题。其次，回答这个问题，也很简单。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。而组合五，id是主键；组合六，id是unique键，都能够保证唯一性。一个等值查询，最多只能返回一条记录，而且新的相同取值的记录，一定不会在新插入进来，因此也就避免了GAP锁的使用。其实，针对此问题，还有一个更深入的问题：如果组合五、组合六下，针对SQL：select * from t1 where id = 10 for update; 第一次查询，没有找到满足查询条件的记录，那么GAP锁是否还能够省略？此问题留给大家思考。</p><p><strong>结论：</strong>Repeatable Read隔离级别下，id列上有一个非唯一索引，对应SQL：delete from t1 where id = 10; 首先，通过id索引定位到第一条满足查询条件的记录，加记录上的X锁，加GAP上的GAP锁，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。</p><h2 id="组合八：id无索引-RR"><a href="#组合八：id无索引-RR" class="headerlink" title="组合八：id无索引+RR"></a>组合八：id无索引+RR</h2><p>组合八，Repeatable Read隔离级别下的最后一种情况，id列上没有索引。此时SQL：delete from t1 where id = 10; 没有其他的路径可以选择，只能进行全表扫描。最终的加锁情况，如下图所示：</p><p><a href="http://www.yupoo.com/photos/hedengcheng/90010764/" target="_blank" rel="noopener"><img src="http://pic.yupoo.com/hedengcheng/DnJ6Rf3q/medish.jpg" alt="id 无索引+rr"></a></p><p>如图，这是一个很恐怖的现象。首先，聚簇索引上的所有记录，都被加上了X锁。其次，聚簇索引每条记录间的间隙(GAP)，也同时被加上了GAP锁。这个示例表，只有6条记录，一共需要6个记录锁，7个GAP锁。试想，如果表上有1000万条记录呢？</p><p>在这种情况下，这个表上，除了不加锁的快照度，其他任何加锁的并发SQL，均不能执行，不能更新，不能删除，不能插入，全表被锁死。</p><p>当然，跟组合四：[<a href="http://hedengcheng.com/?p=771#_%E7%BB%84%E5%90%88%E5%9B%9B%EF%BC%9Aid%E6%97%A0%E7%B4%A2%E5%BC%95+RC" target="_blank" rel="noopener">id无索引, Read Committed</a>]类似，这个情况下，MySQL也做了一些优化，就是所谓的semi-consistent read。semi-consistent read开启的情况下，对于不满足查询条件的记录，MySQL会提前放锁。针对上面的这个用例，就是除了记录[d,10]，[g,10]之外，所有的记录锁都会被释放，同时不加GAP锁。semi-consistent read如何触发：要么是read committed隔离级别；要么是Repeatable Read隔离级别，同时设置了 <a href="http://dev.mysql.com/doc/refman/5.5/en/innodb-parameters.html" target="_blank" rel="noopener">innodb_locks_unsafe_for_binlog</a> 参数。更详细的关于semi-consistent read的介绍，可参考我之前的一篇博客：<a href="http://hedengcheng.com/?p=220" target="_blank" rel="noopener">MySQL+InnoDB semi-consitent read原理及实现分析</a> 。</p><p><strong>结论：</strong>在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新/删除/插入 操作。当然，也可以通过触发semi-consistent read，来缓解加锁开销与并发影响，但是semi-consistent read本身也会带来其他问题，不建议使用。</p><h2 id="组合九：Serializable"><a href="#组合九：Serializable" class="headerlink" title="组合九：Serializable"></a>组合九：Serializable</h2><p>针对前面提到的简单的SQL，最后一个情况：Serializable隔离级别。对于SQL2：delete from t1 where id = 10; 来说，Serializable隔离级别与Repeatable Read隔离级别完全一致，因此不做介绍。</p><p> Serializable隔离级别，影响的是SQL1：select * from t1 where id = 10; 这条SQL，在RC，RR隔离级别下，都是快照读，不加锁。但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，MVCC并发控制降级为Lock-Based CC。</p><p><strong>结论：</strong>在MySQL/InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。 </p><h1 id="一条复杂的SQL"><a href="#一条复杂的SQL" class="headerlink" title="一条复杂的SQL"></a>一条复杂的SQL</h1><p>写到这里，其实MySQL的加锁实现也已经介绍的八八九九。只要将本文上面的分析思路，大部分的SQL，都能分析出其会加哪些锁。而这里，再来看一个稍微复杂点的SQL，用于说明MySQL加锁的另外一个逻辑。SQL用例如下：</p><p><a href="http://www.yupoo.com/photos/hedengcheng/90010767/" target="_blank" rel="noopener"><img src="http://pic.yupoo.com/hedengcheng/DnJ6S3ta/medish.jpg" alt="复杂SQL"></a></p><p>如图中的SQL，会加什么锁？假定在Repeatable Read隔离级别下 (Read Committed隔离级别下的加锁情况，留给读者分析。)，同时，假设SQL走的是idx_t1_pu索引。</p><p>在详细分析这条SQL的加锁情况前，还需要有一个知识储备，那就是一个SQL中的where条件如何拆分？具体的介绍，建议阅读我之前的一篇文章：<a href="http://hedengcheng.com/?p=577" target="_blank" rel="noopener">SQL中的where条件，在数据库中提取与应用浅析</a> 。在这里，我直接给出分析后的结果：</p><ul><li><strong>Index key：</strong>pubtime &gt; 1 and puptime &lt; 20。此条件，用于确定SQL在idx_t1_pu索引上的查询范围。</li></ul><ul><li><p><strong>Index Filter：</strong>userid = ‘hdc’ 。此条件，可以在idx_t1_pu索引上进行过滤，但不属于Index Key。</p></li><li><p><strong>Table Filter：</strong>comment is not NULL。此条件，在idx_t1_pu索引上无法过滤，只能在聚簇索引上过滤。</p></li></ul><p>在分析出SQL where条件的构成之后，再来看看这条SQL的加锁情况 (RR隔离级别)，如下图所示：</p><p><a href="http://www.yupoo.com/photos/hedengcheng/90010768/" target="_blank" rel="noopener"><img src="http://pic.yupoo.com/hedengcheng/DnJ6S1s7/medish.jpg" alt="SQL加锁"></a></p><p>从图中可以看出，在Repeatable Read隔离级别下，由Index Key所确定的范围，被加上了GAP锁；Index Filter锁给定的条件 (userid = ‘hdc’)何时过滤，视MySQL的版本而定，在MySQL 5.6版本之前，不支持<a href="http://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html" target="_blank" rel="noopener">Index Condition Pushdown</a>(ICP)，因此Index Filter在MySQL Server层过滤，在5.6后支持了Index Condition Pushdown，则在index上过滤。若不支持ICP，不满足Index Filter的记录，也需要加上记录X锁，若支持ICP，则不满足Index Filter的记录，无需加记录X锁 (图中，用红色箭头标出的X锁，是否要加，视是否支持ICP而定)；而Table Filter对应的过滤条件，则在聚簇索引中读取后，在MySQL Server层面过滤，因此聚簇索引上也需要X锁。最后，选取出了一条满足条件的记录[8,hdc,d,5,good]，但是加锁的数量，要远远大于满足条件的记录数量。</p><p><strong>结论：</strong>在Repeatable Read隔离级别下，针对一个复杂的SQL，首先需要提取其where条件。Index Key确定的范围，需要加上GAP锁；Index Filter过滤条件，视MySQL版本是否支持ICP，若支持ICP，则不满足Index Filter的记录，不加X锁，否则需要X锁；Table Filter过滤条件，无论是否满足，都需要加X锁。</p><h1 id="死锁原理与分析"><a href="#死锁原理与分析" class="headerlink" title="死锁原理与分析"></a>死锁原理与分析</h1><p>本文前面的部分，基本上已经涵盖了MySQL/InnoDB所有的加锁规则。深入理解MySQL如何加锁，有两个比较重要的作用：</p><ul><li>可以根据MySQL的加锁规则，写出不会发生死锁的SQL；</li></ul><ul><li>可以根据MySQL的加锁规则，定位出线上产生死锁的原因；</li></ul><p>下面，来看看两个死锁的例子 (一个是两个Session的两条SQL产生死锁；另一个是两个Session的一条SQL，产生死锁)：</p><p><a href="http://www.yupoo.com/photos/hedengcheng/90010769/" target="_blank" rel="noopener"><img src="http://pic.yupoo.com/hedengcheng/DnJ6RTaA/medish.jpg" alt="死锁用例"></a></p><p><a href="http://www.yupoo.com/photos/hedengcheng/90010770/" target="_blank" rel="noopener"><img src="http://pic.yupoo.com/hedengcheng/DnJ6S9J0/medish.jpg" alt="死锁用例2"></a></p><p>上面的两个死锁用例。第一个非常好理解，也是最常见的死锁，每个事务执行两条SQL，分别持有了一把锁，然后加另一把锁，产生死锁。</p><p>第二个用例，虽然每个Session都只有一条语句，仍旧会产生死锁。要分析这个死锁，首先必须用到本文前面提到的MySQL加锁的规则。针对Session 1，从name索引出发，读到的[hdc, 1]，[hdc, 6]均满足条件，不仅会加name索引上的记录X锁，而且会加聚簇索引上的记录X锁，加锁顺序为先[1,hdc,100]，后[6,hdc,10]。而Session 2，从pubtime索引出发，[10,6],[100,1]均满足过滤条件，同样也会加聚簇索引上的记录X锁，加锁顺序为[6,hdc,10]，后[1,hdc,100]。发现没有，跟Session 1的加锁顺序正好相反，如果两个Session恰好都持有了第一把锁，请求加第二把锁，死锁就发生了。</p><p><strong>结论：</strong>死锁的发生与否，并不在于事务中有多少条SQL语句，<strong>死锁的关键在于</strong>：两个(或以上)的Session<strong>加锁的顺序</strong>不一致。而使用本文上面提到的，分析MySQL每条SQL语句的加锁规则，分析出每条语句的加锁顺序，然后检查多个并发SQL间是否存在以相反的顺序加锁的情况，就可以分析出各种潜在的死锁情况，也可以分析出线上死锁发生的原因。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>写到这儿，本文也告一段落，做一个简单的总结，要做的完全掌握MySQL/InnoDB的加锁规则，甚至是其他任何数据库的加锁规则，需要具备以下的一些知识点：</p><ul><li>了解数据库的一些基本理论知识：数据的存储格式 (堆组织表 vs 聚簇索引表)；并发控制协议 (MVCC vs Lock-Based CC)；Two-Phase Locking；数据库的隔离级别定义 (Isolation Level)；</li><li>了解SQL本身的执行计划 (主键扫描 vs 唯一键扫描 vs 范围扫描 vs 全表扫描)；</li><li>了解数据库本身的一些实现细节 (过滤条件提取；Index Condition Pushdown；Semi-Consistent Read)；</li><li>了解死锁产生的原因及分析的方法 (加锁顺序不一致；分析每个SQL的加锁顺序)</li></ul><p>有了这些知识点，再加上适当的实战经验，全面掌控MySQL/InnoDB的加锁规则，当不在话下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;MySQL/InnoDB的加锁分析，一直是一个比较困难的话题。我在工作过程中，经常会有同事咨询这方面的问题。同时，微博上也经常会收到MySQ
      
    
    </summary>
    
      <category term="mysql" scheme="http://www.antizhou.com/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>kafka为什么快</title>
    <link href="http://www.antizhou.com/kafka%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB/"/>
    <id>http://www.antizhou.com/kafka为什么快/</id>
    <published>2018-05-24T13:13:19.000Z</published>
    <updated>2018-05-30T03:25:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.10tiao.com/html/254/201607/2648945468/1.html" target="_blank" rel="noopener">为什么Kafka那么快</a><br><a href="https://acupple.github.io/2016/04/20/Kafka%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A6%82%E6%AD%A4%E7%9A%84%E5%BF%AB/" target="_blank" rel="noopener">Kafka为什么如此的快</a><br><a href="https://www.2cto.com/kf/201705/638958.html" target="_blank" rel="noopener">KAFKA：如何做到1秒发布百万级条消息</a><br><a href="https://segmentfault.com/a/1190000007692223" target="_blank" rel="noopener">磁盘及网络IO工作方式解析</a><br><a href="https://segmentfault.com/a/1190000011989008" target="_blank" rel="noopener">零拷贝的实现机制</a><br><a href="https://blog.csdn.snet/lizhitao/article/details/51718185" target="_blank" rel="noopener">Kafka副本同步机制理解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.10tiao.com/html/254/201607/2648945468/1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;为什么Kafka那么快&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://acup
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>intern</title>
    <link href="http://www.antizhou.com/intern/"/>
    <id>http://www.antizhou.com/intern/</id>
    <published>2018-05-23T15:08:10.000Z</published>
    <updated>2018-05-23T15:12:41.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"ni "</span>).append(<span class="string">"hao"</span>).toString();</span><br><span class="line">System.out.println(str1.intern() == str1);</span><br><span class="line"></span><br><span class="line">String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">System.out.println(str2.intern() == str2);</span><br></pre></td></tr></table></figure><p>这段代码在jdk1.6中运行，会得到两个false，而在jdk1.7中运行会得到一个true一个false。产生差异的原因是：在jdk1.6中，intern()方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而用StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。而jdk1.7中的intern()实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个。对str2比较返回false是因为“java”这个字符串在执行StringBuilder.toString()之前已经出现过，字符串常量池中已经有它的引用了，不符合首次出现的原则，而“ni hao”这个字符串则是首次出现的，因此返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"Programming"</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"Programming"</span>);</span><br><span class="line">String s3 = <span class="string">"Program"</span> + <span class="string">"ming"</span>;</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line">System.out.println(s1 == s3);</span><br><span class="line">System.out.println(s1 == s1.intern());</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s1常量池中</span></span><br><span class="line">String s1 = <span class="string">"ab123"</span> ;</span><br><span class="line"><span class="comment">//s2在堆中</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String( <span class="string">"ab123"</span> ) ;</span><br><span class="line">System.out.println( s1 == s2 );</span><br><span class="line"><span class="comment">//s3到常量池中取s1的引用</span></span><br><span class="line">String s3 = s2.intern() ;</span><br><span class="line">System.out.println( s1 == s3 ) ;</span><br><span class="line"><span class="comment">//而s2在堆中，并没有在常量池中</span></span><br><span class="line">System.out.println(s2 == s3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//new会创建两个对象，两个1在堆上，而另两个1在常量池中，</span></span><br><span class="line"><span class="comment">// intern指向常量池,寻找11并没有，就在常量池中新建11，s4就指向s6，而s6==s5</span></span><br><span class="line">String s5 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">s5.intern();</span><br><span class="line">String s4 = <span class="string">"11"</span>;</span><br><span class="line">System.out.println(s5 == s4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//new会创建两个对象，一个9在堆上，而另一个在常量池中，</span></span><br><span class="line"><span class="comment">// intern指向常量池，并没有在常量池中新建9,ss指向常量池,</span></span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"9"</span>);</span><br><span class="line">s.intern();</span><br><span class="line">String ss = <span class="string">"9"</span>;</span><br><span class="line"><span class="comment">//s在堆上，而ss在常量池中</span></span><br><span class="line">System.out.println(s == ss);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cassandra</title>
    <link href="http://www.antizhou.com/cassandra/"/>
    <id>http://www.antizhou.com/cassandra/</id>
    <published>2018-05-18T16:08:17.000Z</published>
    <updated>2018-05-18T16:08:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://chrisrc.me/2017/02/08/cassandra-data-modeling/" target="_blank" rel="noopener">深入理解Cassandra中的数据建模</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://chrisrc.me/2017/02/08/cassandra-data-modeling/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深入理解Cassandra中的数据建模&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>es合集</title>
    <link href="http://www.antizhou.com/es/"/>
    <id>http://www.antizhou.com/es/</id>
    <published>2018-05-18T14:37:00.000Z</published>
    <updated>2018-05-18T14:38:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/licongyu/p/5466992.html" target="_blank" rel="noopener">分布式 ES 操作流程解析</a><br><a href="https://es.xiaoleilu.com/index.html" target="_blank" rel="noopener">Elasticsearch 权威指南（中文版）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/licongyu/p/5466992.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;分布式 ES 操作流程解析&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://es.xiaoleil
      
    
    </summary>
    
      <category term="es" scheme="http://www.antizhou.com/categories/es/"/>
    
    
  </entry>
  
  <entry>
    <title>Lucene</title>
    <link href="http://www.antizhou.com/Lucene/"/>
    <id>http://www.antizhou.com/Lucene/</id>
    <published>2018-05-17T15:40:15.000Z</published>
    <updated>2018-05-18T01:10:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/njpjsoftdev/article/details/54015485" target="_blank" rel="noopener">Lucene底层原理和优化经验分享(1)-Lucene简介和索引原理</a><br><a href="https://www.cnblogs.com/acfox/p/3688607.html" target="_blank" rel="noopener">跳跃表</a><br><a href="https://www.cnblogs.com/a8457013/p/8251967.html" target="_blank" rel="noopener">SkipList跳表基本原理</a><br><a href="http://blog.sina.com.cn/s/blog_68f6d5370102uykh.html" target="_blank" rel="noopener">跳跃表 复杂度分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/njpjsoftdev/article/details/54015485&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lucene底层原理和优化经验分享(1)-Lucene简介和索引原理&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>storm</title>
    <link href="http://www.antizhou.com/storm/"/>
    <id>http://www.antizhou.com/storm/</id>
    <published>2018-05-17T14:29:12.000Z</published>
    <updated>2018-05-17T14:49:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cloud.tencent.com/developer/article/1120796" target="_blank" rel="noopener">Storm介绍及原理</a><br><a href="https://www.cnblogs.com/yufengof/p/storm-worker-executor-task.html" target="_blank" rel="noopener">storm源码之理解Storm中Worker、Executor、Task关系</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1120796&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Storm介绍及原理&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.cnblo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>时序数据库</title>
    <link href="http://www.antizhou.com/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://www.antizhou.com/时序数据库/</id>
    <published>2018-05-16T07:29:48.000Z</published>
    <updated>2018-05-25T16:33:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.infoq.com/cn/articles/storage-in-sequential-databases" target="_blank" rel="noopener">时序数据库深入浅出之存储篇</a><br><a href="https://www.jianshu.com/p/f5282f39317f" target="_blank" rel="noopener">Cassandra预聚合方案设计</a><br><a href="https://elasticsearch.cn/uploads/slides/20180206/b4148b335c18ce65ca1f82d56ba4bccd" target="_blank" rel="noopener">基于ES的时序数据库服务 - Elastic中文社区</a><br><a href="https://www.jianshu.com/p/9ad69141b67a" target="_blank" rel="noopener">时间序列数据的存储和计算 - 开源时序数据库解析</a><br><a href="https://kairosdb.github.io/docs/build/html/CassandraSchema.html" target="_blank" rel="noopener">KairosDB Cassandra Schema</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/storage-in-sequential-databases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;时序数据库深入浅出之存储篇&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
  </entry>
  
</feed>
